{- This file was auto-generated from lightning.proto by the proto-lens-protoc program. -}
{-# LANGUAGE ScopedTypeVariables, DataKinds, TypeFamilies, UndecidableInstances, GeneralizedNewtypeDeriving, MultiParamTypeClasses, FlexibleContexts, FlexibleInstances, PatternSynonyms, MagicHash, NoImplicitPrelude, BangPatterns, TypeApplications, OverloadedStrings, DerivingStrategies, DeriveGeneric#-}
{-# OPTIONS_GHC -Wno-unused-imports#-}
{-# OPTIONS_GHC -Wno-duplicate-exports#-}
{-# OPTIONS_GHC -Wno-dodgy-exports#-}
module Proto.Lightning (
        Lightning(..), AddressType(..), AddressType(),
        AddressType'UnrecognizedValue, BatchOpenChannel(),
        BatchOpenChannelRequest(), BatchOpenChannelResponse(), Chain(),
        ChannelAcceptRequest(), ChannelAcceptResponse(),
        ChannelCloseUpdate(), ChannelOpenUpdate(), CloseChannelRequest(),
        CloseStatusUpdate(), CloseStatusUpdate'Update(..),
        _CloseStatusUpdate'ClosePending, _CloseStatusUpdate'ChanClose,
        ClosedChannelsRequest(), ClosedChannelsResponse(),
        ConfirmationUpdate(), ConnectPeerRequest(), ConnectPeerResponse(),
        CustomMessage(), DisconnectPeerRequest(), DisconnectPeerResponse(),
        EstimateFeeRequest(), EstimateFeeRequest'AddrToAmountEntry(),
        EstimateFeeResponse(), GetInfoRequest(), GetInfoResponse(),
        GetInfoResponse'FeaturesEntry(), GetRecoveryInfoRequest(),
        GetRecoveryInfoResponse(), GetTransactionsRequest(),
        LightningAddress(), ListChannelsRequest(), ListChannelsResponse(),
        ListPeersRequest(), ListPeersResponse(), ListUnspentRequest(),
        ListUnspentResponse(), NewAddressRequest(), NewAddressResponse(),
        OpenChannelRequest(), OpenStatusUpdate(),
        OpenStatusUpdate'Update(..), _OpenStatusUpdate'ChanPending,
        _OpenStatusUpdate'ChanOpen, _OpenStatusUpdate'PsbtFund, Peer(),
        Peer'FeaturesEntry(), Peer'SyncType(..), Peer'SyncType(),
        Peer'SyncType'UnrecognizedValue, PeerEvent(),
        PeerEvent'EventType(..), PeerEvent'EventType(),
        PeerEvent'EventType'UnrecognizedValue, PeerEventSubscription(),
        ReadyForPsbtFunding(), SendCoinsRequest(), SendCoinsResponse(),
        SendCustomMessageRequest(), SendCustomMessageResponse(),
        SendManyRequest(), SendManyRequest'AddrToAmountEntry(),
        SendManyResponse(), SendRequest(),
        SendRequest'DestCustomRecordsEntry(), SendResponse(),
        SendToRouteRequest(), SignMessageRequest(), SignMessageResponse(),
        SubscribeCustomMessagesRequest(), TimestampedError(),
        Transaction(), TransactionDetails(), Utxo(),
        VerifyMessageRequest(), VerifyMessageResponse()
    ) where
import qualified Data.ProtoLens.Runtime.Control.DeepSeq as Control.DeepSeq
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Prism as Data.ProtoLens.Prism
import qualified Text.PrettyPrint.GenericPretty.Instance
import qualified GHC.Generics
import qualified Text.PrettyPrint.GenericPretty
import qualified Data.ProtoLens.Runtime.Prelude as Prelude
import qualified Data.ProtoLens.Runtime.Data.Int as Data.Int
import qualified Data.ProtoLens.Runtime.Data.Monoid as Data.Monoid
import qualified Data.ProtoLens.Runtime.Data.Word as Data.Word
import qualified Data.ProtoLens.Runtime.Data.ProtoLens as Data.ProtoLens
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Encoding.Bytes as Data.ProtoLens.Encoding.Bytes
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Encoding.Growing as Data.ProtoLens.Encoding.Growing
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Encoding.Parser.Unsafe as Data.ProtoLens.Encoding.Parser.Unsafe
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Encoding.Wire as Data.ProtoLens.Encoding.Wire
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Field as Data.ProtoLens.Field
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Message.Enum as Data.ProtoLens.Message.Enum
import qualified Data.ProtoLens.Runtime.Data.ProtoLens.Service.Types as Data.ProtoLens.Service.Types
import qualified Data.ProtoLens.Runtime.Lens.Family2 as Lens.Family2
import qualified Data.ProtoLens.Runtime.Lens.Family2.Unchecked as Lens.Family2.Unchecked
import qualified Data.ProtoLens.Runtime.Data.Text as Data.Text
import qualified Data.ProtoLens.Runtime.Data.Map as Data.Map
import qualified Data.ProtoLens.Runtime.Data.ByteString as Data.ByteString
import qualified Data.ProtoLens.Runtime.Data.ByteString.Char8 as Data.ByteString.Char8
import qualified Data.ProtoLens.Runtime.Data.Text.Encoding as Data.Text.Encoding
import qualified Data.ProtoLens.Runtime.Data.Vector as Data.Vector
import qualified Data.ProtoLens.Runtime.Data.Vector.Generic as Data.Vector.Generic
import qualified Data.ProtoLens.Runtime.Data.Vector.Unboxed as Data.Vector.Unboxed
import qualified Data.ProtoLens.Runtime.Text.Read as Text.Read
import qualified Proto.Lnrpc.Ln0
import qualified Proto.Lnrpc.Ln1
newtype AddressType'UnrecognizedValue
  = AddressType'UnrecognizedValue Data.Int.Int32
  deriving stock (Prelude.Eq,
                  Prelude.Ord,
                  Prelude.Show,
                  GHC.Generics.Generic)
instance Text.PrettyPrint.GenericPretty.Out AddressType'UnrecognizedValue
data AddressType
  = WITNESS_PUBKEY_HASH |
    NESTED_PUBKEY_HASH |
    UNUSED_WITNESS_PUBKEY_HASH |
    UNUSED_NESTED_PUBKEY_HASH |
    AddressType'Unrecognized !AddressType'UnrecognizedValue
  deriving stock (Prelude.Show,
                  Prelude.Eq,
                  Prelude.Ord,
                  GHC.Generics.Generic)
instance Data.ProtoLens.MessageEnum AddressType where
  maybeToEnum 0 = Prelude.Just WITNESS_PUBKEY_HASH
  maybeToEnum 1 = Prelude.Just NESTED_PUBKEY_HASH
  maybeToEnum 2 = Prelude.Just UNUSED_WITNESS_PUBKEY_HASH
  maybeToEnum 3 = Prelude.Just UNUSED_NESTED_PUBKEY_HASH
  maybeToEnum k
    = Prelude.Just
        (AddressType'Unrecognized
           (AddressType'UnrecognizedValue (Prelude.fromIntegral k)))
  showEnum WITNESS_PUBKEY_HASH = "WITNESS_PUBKEY_HASH"
  showEnum NESTED_PUBKEY_HASH = "NESTED_PUBKEY_HASH"
  showEnum UNUSED_WITNESS_PUBKEY_HASH = "UNUSED_WITNESS_PUBKEY_HASH"
  showEnum UNUSED_NESTED_PUBKEY_HASH = "UNUSED_NESTED_PUBKEY_HASH"
  showEnum
    (AddressType'Unrecognized (AddressType'UnrecognizedValue k))
    = Prelude.show k
  readEnum k
    | (Prelude.==) k "WITNESS_PUBKEY_HASH"
    = Prelude.Just WITNESS_PUBKEY_HASH
    | (Prelude.==) k "NESTED_PUBKEY_HASH"
    = Prelude.Just NESTED_PUBKEY_HASH
    | (Prelude.==) k "UNUSED_WITNESS_PUBKEY_HASH"
    = Prelude.Just UNUSED_WITNESS_PUBKEY_HASH
    | (Prelude.==) k "UNUSED_NESTED_PUBKEY_HASH"
    = Prelude.Just UNUSED_NESTED_PUBKEY_HASH
    | Prelude.otherwise
    = (Prelude.>>=) (Text.Read.readMaybe k) Data.ProtoLens.maybeToEnum
instance Prelude.Bounded AddressType where
  minBound = WITNESS_PUBKEY_HASH
  maxBound = UNUSED_NESTED_PUBKEY_HASH
instance Prelude.Enum AddressType where
  toEnum k__
    = Prelude.maybe
        (Prelude.error
           ((Prelude.++)
              "toEnum: unknown value for enum AddressType: " (Prelude.show k__)))
        Prelude.id (Data.ProtoLens.maybeToEnum k__)
  fromEnum WITNESS_PUBKEY_HASH = 0
  fromEnum NESTED_PUBKEY_HASH = 1
  fromEnum UNUSED_WITNESS_PUBKEY_HASH = 2
  fromEnum UNUSED_NESTED_PUBKEY_HASH = 3
  fromEnum
    (AddressType'Unrecognized (AddressType'UnrecognizedValue k))
    = Prelude.fromIntegral k
  succ UNUSED_NESTED_PUBKEY_HASH
    = Prelude.error
        "AddressType.succ: bad argument UNUSED_NESTED_PUBKEY_HASH. This value would be out of bounds."
  succ WITNESS_PUBKEY_HASH = NESTED_PUBKEY_HASH
  succ NESTED_PUBKEY_HASH = UNUSED_WITNESS_PUBKEY_HASH
  succ UNUSED_WITNESS_PUBKEY_HASH = UNUSED_NESTED_PUBKEY_HASH
  succ (AddressType'Unrecognized _)
    = Prelude.error
        "AddressType.succ: bad argument: unrecognized value"
  pred WITNESS_PUBKEY_HASH
    = Prelude.error
        "AddressType.pred: bad argument WITNESS_PUBKEY_HASH. This value would be out of bounds."
  pred NESTED_PUBKEY_HASH = WITNESS_PUBKEY_HASH
  pred UNUSED_WITNESS_PUBKEY_HASH = NESTED_PUBKEY_HASH
  pred UNUSED_NESTED_PUBKEY_HASH = UNUSED_WITNESS_PUBKEY_HASH
  pred (AddressType'Unrecognized _)
    = Prelude.error
        "AddressType.pred: bad argument: unrecognized value"
  enumFrom = Data.ProtoLens.Message.Enum.messageEnumFrom
  enumFromTo = Data.ProtoLens.Message.Enum.messageEnumFromTo
  enumFromThen = Data.ProtoLens.Message.Enum.messageEnumFromThen
  enumFromThenTo = Data.ProtoLens.Message.Enum.messageEnumFromThenTo
instance Data.ProtoLens.FieldDefault AddressType where
  fieldDefault = WITNESS_PUBKEY_HASH
instance Control.DeepSeq.NFData AddressType where
  rnf x__ = Prelude.seq x__ ()
instance Text.PrettyPrint.GenericPretty.Out AddressType
{- | Fields :
     
         * 'Proto.Lightning_Fields.nodePubkey' @:: Lens' BatchOpenChannel Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.localFundingAmount' @:: Lens' BatchOpenChannel Data.Int.Int64@
         * 'Proto.Lightning_Fields.pushSat' @:: Lens' BatchOpenChannel Data.Int.Int64@
         * 'Proto.Lightning_Fields.private' @:: Lens' BatchOpenChannel Prelude.Bool@
         * 'Proto.Lightning_Fields.minHtlcMsat' @:: Lens' BatchOpenChannel Data.Int.Int64@
         * 'Proto.Lightning_Fields.remoteCsvDelay' @:: Lens' BatchOpenChannel Data.Word.Word32@
         * 'Proto.Lightning_Fields.closeAddress' @:: Lens' BatchOpenChannel Data.Text.Text@
         * 'Proto.Lightning_Fields.pendingChanId' @:: Lens' BatchOpenChannel Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.commitmentType' @:: Lens' BatchOpenChannel Proto.Lnrpc.Ln0.CommitmentType@ -}
data BatchOpenChannel
  = BatchOpenChannel'_constructor {_BatchOpenChannel'nodePubkey :: !Data.ByteString.ByteString,
                                   _BatchOpenChannel'localFundingAmount :: !Data.Int.Int64,
                                   _BatchOpenChannel'pushSat :: !Data.Int.Int64,
                                   _BatchOpenChannel'private :: !Prelude.Bool,
                                   _BatchOpenChannel'minHtlcMsat :: !Data.Int.Int64,
                                   _BatchOpenChannel'remoteCsvDelay :: !Data.Word.Word32,
                                   _BatchOpenChannel'closeAddress :: !Data.Text.Text,
                                   _BatchOpenChannel'pendingChanId :: !Data.ByteString.ByteString,
                                   _BatchOpenChannel'commitmentType :: !Proto.Lnrpc.Ln0.CommitmentType,
                                   _BatchOpenChannel'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show BatchOpenChannel where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out BatchOpenChannel
instance Data.ProtoLens.Field.HasField BatchOpenChannel "nodePubkey" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'nodePubkey
           (\ x__ y__ -> x__ {_BatchOpenChannel'nodePubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "localFundingAmount" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'localFundingAmount
           (\ x__ y__ -> x__ {_BatchOpenChannel'localFundingAmount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "pushSat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'pushSat
           (\ x__ y__ -> x__ {_BatchOpenChannel'pushSat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "private" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'private
           (\ x__ y__ -> x__ {_BatchOpenChannel'private = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "minHtlcMsat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'minHtlcMsat
           (\ x__ y__ -> x__ {_BatchOpenChannel'minHtlcMsat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "remoteCsvDelay" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'remoteCsvDelay
           (\ x__ y__ -> x__ {_BatchOpenChannel'remoteCsvDelay = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "closeAddress" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'closeAddress
           (\ x__ y__ -> x__ {_BatchOpenChannel'closeAddress = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "pendingChanId" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'pendingChanId
           (\ x__ y__ -> x__ {_BatchOpenChannel'pendingChanId = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannel "commitmentType" Proto.Lnrpc.Ln0.CommitmentType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannel'commitmentType
           (\ x__ y__ -> x__ {_BatchOpenChannel'commitmentType = y__}))
        Prelude.id
instance Data.ProtoLens.Message BatchOpenChannel where
  messageName _ = Data.Text.pack "lnrpc.BatchOpenChannel"
  packedMessageDescriptor _
    = "\n\
      \\DLEBatchOpenChannel\DC2\US\n\
      \\vnode_pubkey\CAN\SOH \SOH(\fR\n\
      \nodePubkey\DC20\n\
      \\DC4local_funding_amount\CAN\STX \SOH(\ETXR\DC2localFundingAmount\DC2\EM\n\
      \\bpush_sat\CAN\ETX \SOH(\ETXR\apushSat\DC2\CAN\n\
      \\aprivate\CAN\EOT \SOH(\bR\aprivate\DC2\"\n\
      \\rmin_htlc_msat\CAN\ENQ \SOH(\ETXR\vminHtlcMsat\DC2(\n\
      \\DLEremote_csv_delay\CAN\ACK \SOH(\rR\SOremoteCsvDelay\DC2#\n\
      \\rclose_address\CAN\a \SOH(\tR\fcloseAddress\DC2&\n\
      \\SIpending_chan_id\CAN\b \SOH(\fR\rpendingChanId\DC2>\n\
      \\SIcommitment_type\CAN\t \SOH(\SO2\NAK.lnrpc.CommitmentTypeR\SOcommitmentType"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        nodePubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "node_pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"nodePubkey")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        localFundingAmount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "local_funding_amount"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"localFundingAmount")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        pushSat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "push_sat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pushSat")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        private__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "private"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"private")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        minHtlcMsat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_htlc_msat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minHtlcMsat")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        remoteCsvDelay__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "remote_csv_delay"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"remoteCsvDelay")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        closeAddress__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "close_address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"closeAddress")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        pendingChanId__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pending_chan_id"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"pendingChanId")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
        commitmentType__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "commitment_type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.CommitmentType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"commitmentType")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannel
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, nodePubkey__field_descriptor),
           (Data.ProtoLens.Tag 2, localFundingAmount__field_descriptor),
           (Data.ProtoLens.Tag 3, pushSat__field_descriptor),
           (Data.ProtoLens.Tag 4, private__field_descriptor),
           (Data.ProtoLens.Tag 5, minHtlcMsat__field_descriptor),
           (Data.ProtoLens.Tag 6, remoteCsvDelay__field_descriptor),
           (Data.ProtoLens.Tag 7, closeAddress__field_descriptor),
           (Data.ProtoLens.Tag 8, pendingChanId__field_descriptor),
           (Data.ProtoLens.Tag 9, commitmentType__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _BatchOpenChannel'_unknownFields
        (\ x__ y__ -> x__ {_BatchOpenChannel'_unknownFields = y__})
  defMessage
    = BatchOpenChannel'_constructor
        {_BatchOpenChannel'nodePubkey = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'localFundingAmount = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'pushSat = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'private = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'minHtlcMsat = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'remoteCsvDelay = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'closeAddress = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'pendingChanId = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'commitmentType = Data.ProtoLens.fieldDefault,
         _BatchOpenChannel'_unknownFields = []}
  parseMessage
    = let
        loop ::
          BatchOpenChannel
          -> Data.ProtoLens.Encoding.Bytes.Parser BatchOpenChannel
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "node_pubkey"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"nodePubkey") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "local_funding_amount"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"localFundingAmount") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "push_sat"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pushSat") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "private"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"private") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_htlc_msat"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minHtlcMsat") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "remote_csv_delay"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"remoteCsvDelay") y x)
                        58
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "close_address"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"closeAddress") y x)
                        66
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "pending_chan_id"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"pendingChanId") y x)
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "commitment_type"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"commitmentType") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "BatchOpenChannel"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"nodePubkey") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"localFundingAmount") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pushSat") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"private") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (\ b -> if b then 1 else 0) _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view (Data.ProtoLens.Field.field @"minHtlcMsat") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view
                                     (Data.ProtoLens.Field.field @"remoteCsvDelay") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"closeAddress") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 58)
                                        ((Prelude..)
                                           (\ bs
                                              -> (Data.Monoid.<>)
                                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                      (Prelude.fromIntegral
                                                         (Data.ByteString.length bs)))
                                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                           Data.Text.Encoding.encodeUtf8 _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"pendingChanId") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 66)
                                           ((\ bs
                                               -> (Data.Monoid.<>)
                                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                       (Prelude.fromIntegral
                                                          (Data.ByteString.length bs)))
                                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                              _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"commitmentType") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                              ((Prelude..)
                                                 ((Prelude..)
                                                    Data.ProtoLens.Encoding.Bytes.putVarInt
                                                    Prelude.fromIntegral)
                                                 Prelude.fromEnum _v))
                                     (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                        (Lens.Family2.view Data.ProtoLens.unknownFields _x))))))))))
instance Control.DeepSeq.NFData BatchOpenChannel where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_BatchOpenChannel'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_BatchOpenChannel'nodePubkey x__)
                (Control.DeepSeq.deepseq
                   (_BatchOpenChannel'localFundingAmount x__)
                   (Control.DeepSeq.deepseq
                      (_BatchOpenChannel'pushSat x__)
                      (Control.DeepSeq.deepseq
                         (_BatchOpenChannel'private x__)
                         (Control.DeepSeq.deepseq
                            (_BatchOpenChannel'minHtlcMsat x__)
                            (Control.DeepSeq.deepseq
                               (_BatchOpenChannel'remoteCsvDelay x__)
                               (Control.DeepSeq.deepseq
                                  (_BatchOpenChannel'closeAddress x__)
                                  (Control.DeepSeq.deepseq
                                     (_BatchOpenChannel'pendingChanId x__)
                                     (Control.DeepSeq.deepseq
                                        (_BatchOpenChannel'commitmentType x__) ())))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.channels' @:: Lens' BatchOpenChannelRequest [BatchOpenChannel]@
         * 'Proto.Lightning_Fields.vec'channels' @:: Lens' BatchOpenChannelRequest (Data.Vector.Vector BatchOpenChannel)@
         * 'Proto.Lightning_Fields.targetConf' @:: Lens' BatchOpenChannelRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.satPerVbyte' @:: Lens' BatchOpenChannelRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.minConfs' @:: Lens' BatchOpenChannelRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.spendUnconfirmed' @:: Lens' BatchOpenChannelRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.label' @:: Lens' BatchOpenChannelRequest Data.Text.Text@ -}
data BatchOpenChannelRequest
  = BatchOpenChannelRequest'_constructor {_BatchOpenChannelRequest'channels :: !(Data.Vector.Vector BatchOpenChannel),
                                          _BatchOpenChannelRequest'targetConf :: !Data.Int.Int32,
                                          _BatchOpenChannelRequest'satPerVbyte :: !Data.Int.Int64,
                                          _BatchOpenChannelRequest'minConfs :: !Data.Int.Int32,
                                          _BatchOpenChannelRequest'spendUnconfirmed :: !Prelude.Bool,
                                          _BatchOpenChannelRequest'label :: !Data.Text.Text,
                                          _BatchOpenChannelRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show BatchOpenChannelRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out BatchOpenChannelRequest
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "channels" [BatchOpenChannel] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'channels
           (\ x__ y__ -> x__ {_BatchOpenChannelRequest'channels = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "vec'channels" (Data.Vector.Vector BatchOpenChannel) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'channels
           (\ x__ y__ -> x__ {_BatchOpenChannelRequest'channels = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "targetConf" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'targetConf
           (\ x__ y__ -> x__ {_BatchOpenChannelRequest'targetConf = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "satPerVbyte" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'satPerVbyte
           (\ x__ y__ -> x__ {_BatchOpenChannelRequest'satPerVbyte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "minConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'minConfs
           (\ x__ y__ -> x__ {_BatchOpenChannelRequest'minConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "spendUnconfirmed" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'spendUnconfirmed
           (\ x__ y__
              -> x__ {_BatchOpenChannelRequest'spendUnconfirmed = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField BatchOpenChannelRequest "label" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelRequest'label
           (\ x__ y__ -> x__ {_BatchOpenChannelRequest'label = y__}))
        Prelude.id
instance Data.ProtoLens.Message BatchOpenChannelRequest where
  messageName _ = Data.Text.pack "lnrpc.BatchOpenChannelRequest"
  packedMessageDescriptor _
    = "\n\
      \\ETBBatchOpenChannelRequest\DC23\n\
      \\bchannels\CAN\SOH \ETX(\v2\ETB.lnrpc.BatchOpenChannelR\bchannels\DC2\US\n\
      \\vtarget_conf\CAN\STX \SOH(\ENQR\n\
      \targetConf\DC2\"\n\
      \\rsat_per_vbyte\CAN\ETX \SOH(\ETXR\vsatPerVbyte\DC2\ESC\n\
      \\tmin_confs\CAN\EOT \SOH(\ENQR\bminConfs\DC2+\n\
      \\DC1spend_unconfirmed\CAN\ENQ \SOH(\bR\DLEspendUnconfirmed\DC2\DC4\n\
      \\ENQlabel\CAN\ACK \SOH(\tR\ENQlabel"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        channels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channels"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor BatchOpenChannel)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked
                 (Data.ProtoLens.Field.field @"channels")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelRequest
        targetConf__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "target_conf"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"targetConf")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelRequest
        satPerVbyte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_vbyte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerVbyte")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelRequest
        minConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minConfs")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelRequest
        spendUnconfirmed__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "spend_unconfirmed"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"spendUnconfirmed")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelRequest
        label__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "label"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"label")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, channels__field_descriptor),
           (Data.ProtoLens.Tag 2, targetConf__field_descriptor),
           (Data.ProtoLens.Tag 3, satPerVbyte__field_descriptor),
           (Data.ProtoLens.Tag 4, minConfs__field_descriptor),
           (Data.ProtoLens.Tag 5, spendUnconfirmed__field_descriptor),
           (Data.ProtoLens.Tag 6, label__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _BatchOpenChannelRequest'_unknownFields
        (\ x__ y__ -> x__ {_BatchOpenChannelRequest'_unknownFields = y__})
  defMessage
    = BatchOpenChannelRequest'_constructor
        {_BatchOpenChannelRequest'channels = Data.Vector.Generic.empty,
         _BatchOpenChannelRequest'targetConf = Data.ProtoLens.fieldDefault,
         _BatchOpenChannelRequest'satPerVbyte = Data.ProtoLens.fieldDefault,
         _BatchOpenChannelRequest'minConfs = Data.ProtoLens.fieldDefault,
         _BatchOpenChannelRequest'spendUnconfirmed = Data.ProtoLens.fieldDefault,
         _BatchOpenChannelRequest'label = Data.ProtoLens.fieldDefault,
         _BatchOpenChannelRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          BatchOpenChannelRequest
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld BatchOpenChannel
             -> Data.ProtoLens.Encoding.Bytes.Parser BatchOpenChannelRequest
        loop x mutable'channels
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'channels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                           (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                              mutable'channels)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'channels") frozen'channels x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "channels"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'channels y)
                                loop x v
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "target_conf"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"targetConf") y x)
                                  mutable'channels
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_per_vbyte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerVbyte") y x)
                                  mutable'channels
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minConfs") y x)
                                  mutable'channels
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "spend_unconfirmed"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"spendUnconfirmed") y x)
                                  mutable'channels
                        50
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "label"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"label") y x)
                                  mutable'channels
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'channels
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'channels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                    Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'channels)
          "BatchOpenChannelRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view
                   (Data.ProtoLens.Field.field @"vec'channels") _x))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"targetConf") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerVbyte") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"minConfs") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view
                                  (Data.ProtoLens.Field.field @"spendUnconfirmed") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (\ b -> if b then 1 else 0) _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"label") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 50)
                                     ((Prelude..)
                                        (\ bs
                                           -> (Data.Monoid.<>)
                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                   (Prelude.fromIntegral
                                                      (Data.ByteString.length bs)))
                                                (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                        Data.Text.Encoding.encodeUtf8 _v))
                            (Data.ProtoLens.Encoding.Wire.buildFieldSet
                               (Lens.Family2.view Data.ProtoLens.unknownFields _x)))))))
instance Control.DeepSeq.NFData BatchOpenChannelRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_BatchOpenChannelRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_BatchOpenChannelRequest'channels x__)
                (Control.DeepSeq.deepseq
                   (_BatchOpenChannelRequest'targetConf x__)
                   (Control.DeepSeq.deepseq
                      (_BatchOpenChannelRequest'satPerVbyte x__)
                      (Control.DeepSeq.deepseq
                         (_BatchOpenChannelRequest'minConfs x__)
                         (Control.DeepSeq.deepseq
                            (_BatchOpenChannelRequest'spendUnconfirmed x__)
                            (Control.DeepSeq.deepseq
                               (_BatchOpenChannelRequest'label x__) ()))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.pendingChannels' @:: Lens' BatchOpenChannelResponse [Proto.Lnrpc.Ln0.PendingUpdate]@
         * 'Proto.Lightning_Fields.vec'pendingChannels' @:: Lens' BatchOpenChannelResponse (Data.Vector.Vector Proto.Lnrpc.Ln0.PendingUpdate)@ -}
data BatchOpenChannelResponse
  = BatchOpenChannelResponse'_constructor {_BatchOpenChannelResponse'pendingChannels :: !(Data.Vector.Vector Proto.Lnrpc.Ln0.PendingUpdate),
                                           _BatchOpenChannelResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show BatchOpenChannelResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out BatchOpenChannelResponse
instance Data.ProtoLens.Field.HasField BatchOpenChannelResponse "pendingChannels" [Proto.Lnrpc.Ln0.PendingUpdate] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelResponse'pendingChannels
           (\ x__ y__
              -> x__ {_BatchOpenChannelResponse'pendingChannels = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField BatchOpenChannelResponse "vec'pendingChannels" (Data.Vector.Vector Proto.Lnrpc.Ln0.PendingUpdate) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _BatchOpenChannelResponse'pendingChannels
           (\ x__ y__
              -> x__ {_BatchOpenChannelResponse'pendingChannels = y__}))
        Prelude.id
instance Data.ProtoLens.Message BatchOpenChannelResponse where
  messageName _ = Data.Text.pack "lnrpc.BatchOpenChannelResponse"
  packedMessageDescriptor _
    = "\n\
      \\CANBatchOpenChannelResponse\DC2?\n\
      \\DLEpending_channels\CAN\SOH \ETX(\v2\DC4.lnrpc.PendingUpdateR\SIpendingChannels"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        pendingChannels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pending_channels"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.PendingUpdate)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked
                 (Data.ProtoLens.Field.field @"pendingChannels")) ::
              Data.ProtoLens.FieldDescriptor BatchOpenChannelResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, pendingChannels__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _BatchOpenChannelResponse'_unknownFields
        (\ x__ y__ -> x__ {_BatchOpenChannelResponse'_unknownFields = y__})
  defMessage
    = BatchOpenChannelResponse'_constructor
        {_BatchOpenChannelResponse'pendingChannels = Data.Vector.Generic.empty,
         _BatchOpenChannelResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          BatchOpenChannelResponse
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Proto.Lnrpc.Ln0.PendingUpdate
             -> Data.ProtoLens.Encoding.Bytes.Parser BatchOpenChannelResponse
        loop x mutable'pendingChannels
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'pendingChannels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                                  (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                                     mutable'pendingChannels)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'pendingChannels")
                              frozen'pendingChannels x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "pending_channels"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append
                                          mutable'pendingChannels y)
                                loop x v
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'pendingChannels
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'pendingChannels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                           Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'pendingChannels)
          "BatchOpenChannelResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view
                   (Data.ProtoLens.Field.field @"vec'pendingChannels") _x))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData BatchOpenChannelResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_BatchOpenChannelResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_BatchOpenChannelResponse'pendingChannels x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.chain' @:: Lens' Chain Data.Text.Text@
         * 'Proto.Lightning_Fields.network' @:: Lens' Chain Data.Text.Text@ -}
data Chain
  = Chain'_constructor {_Chain'chain :: !Data.Text.Text,
                        _Chain'network :: !Data.Text.Text,
                        _Chain'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show Chain where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out Chain
instance Data.ProtoLens.Field.HasField Chain "chain" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Chain'chain (\ x__ y__ -> x__ {_Chain'chain = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Chain "network" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Chain'network (\ x__ y__ -> x__ {_Chain'network = y__}))
        Prelude.id
instance Data.ProtoLens.Message Chain where
  messageName _ = Data.Text.pack "lnrpc.Chain"
  packedMessageDescriptor _
    = "\n\
      \\ENQChain\DC2\DC4\n\
      \\ENQchain\CAN\SOH \SOH(\tR\ENQchain\DC2\CAN\n\
      \\anetwork\CAN\STX \SOH(\tR\anetwork"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        chain__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "chain"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"chain")) ::
              Data.ProtoLens.FieldDescriptor Chain
        network__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "network"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"network")) ::
              Data.ProtoLens.FieldDescriptor Chain
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, chain__field_descriptor),
           (Data.ProtoLens.Tag 2, network__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _Chain'_unknownFields
        (\ x__ y__ -> x__ {_Chain'_unknownFields = y__})
  defMessage
    = Chain'_constructor
        {_Chain'chain = Data.ProtoLens.fieldDefault,
         _Chain'network = Data.ProtoLens.fieldDefault,
         _Chain'_unknownFields = []}
  parseMessage
    = let
        loop :: Chain -> Data.ProtoLens.Encoding.Bytes.Parser Chain
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "chain"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"chain") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "network"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"network") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "Chain"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"chain") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"network") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData Chain where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_Chain'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_Chain'chain x__)
                (Control.DeepSeq.deepseq (_Chain'network x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.nodePubkey' @:: Lens' ChannelAcceptRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.chainHash' @:: Lens' ChannelAcceptRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.pendingChanId' @:: Lens' ChannelAcceptRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.fundingAmt' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.pushAmt' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.dustLimit' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.maxValueInFlight' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.channelReserve' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.minHtlc' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.feePerKw' @:: Lens' ChannelAcceptRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.csvDelay' @:: Lens' ChannelAcceptRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.maxAcceptedHtlcs' @:: Lens' ChannelAcceptRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.channelFlags' @:: Lens' ChannelAcceptRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.commitmentType' @:: Lens' ChannelAcceptRequest Proto.Lnrpc.Ln0.CommitmentType@ -}
data ChannelAcceptRequest
  = ChannelAcceptRequest'_constructor {_ChannelAcceptRequest'nodePubkey :: !Data.ByteString.ByteString,
                                       _ChannelAcceptRequest'chainHash :: !Data.ByteString.ByteString,
                                       _ChannelAcceptRequest'pendingChanId :: !Data.ByteString.ByteString,
                                       _ChannelAcceptRequest'fundingAmt :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'pushAmt :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'dustLimit :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'maxValueInFlight :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'channelReserve :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'minHtlc :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'feePerKw :: !Data.Word.Word64,
                                       _ChannelAcceptRequest'csvDelay :: !Data.Word.Word32,
                                       _ChannelAcceptRequest'maxAcceptedHtlcs :: !Data.Word.Word32,
                                       _ChannelAcceptRequest'channelFlags :: !Data.Word.Word32,
                                       _ChannelAcceptRequest'commitmentType :: !Proto.Lnrpc.Ln0.CommitmentType,
                                       _ChannelAcceptRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ChannelAcceptRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ChannelAcceptRequest
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "nodePubkey" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'nodePubkey
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'nodePubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "chainHash" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'chainHash
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'chainHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "pendingChanId" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'pendingChanId
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'pendingChanId = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "fundingAmt" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'fundingAmt
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'fundingAmt = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "pushAmt" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'pushAmt
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'pushAmt = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "dustLimit" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'dustLimit
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'dustLimit = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "maxValueInFlight" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'maxValueInFlight
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'maxValueInFlight = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "channelReserve" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'channelReserve
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'channelReserve = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "minHtlc" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'minHtlc
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'minHtlc = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "feePerKw" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'feePerKw
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'feePerKw = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "csvDelay" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'csvDelay
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'csvDelay = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "maxAcceptedHtlcs" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'maxAcceptedHtlcs
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'maxAcceptedHtlcs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "channelFlags" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'channelFlags
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'channelFlags = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptRequest "commitmentType" Proto.Lnrpc.Ln0.CommitmentType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptRequest'commitmentType
           (\ x__ y__ -> x__ {_ChannelAcceptRequest'commitmentType = y__}))
        Prelude.id
instance Data.ProtoLens.Message ChannelAcceptRequest where
  messageName _ = Data.Text.pack "lnrpc.ChannelAcceptRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC4ChannelAcceptRequest\DC2\US\n\
      \\vnode_pubkey\CAN\SOH \SOH(\fR\n\
      \nodePubkey\DC2\GS\n\
      \\n\
      \chain_hash\CAN\STX \SOH(\fR\tchainHash\DC2&\n\
      \\SIpending_chan_id\CAN\ETX \SOH(\fR\rpendingChanId\DC2\US\n\
      \\vfunding_amt\CAN\EOT \SOH(\EOTR\n\
      \fundingAmt\DC2\EM\n\
      \\bpush_amt\CAN\ENQ \SOH(\EOTR\apushAmt\DC2\GS\n\
      \\n\
      \dust_limit\CAN\ACK \SOH(\EOTR\tdustLimit\DC2-\n\
      \\DC3max_value_in_flight\CAN\a \SOH(\EOTR\DLEmaxValueInFlight\DC2'\n\
      \\SIchannel_reserve\CAN\b \SOH(\EOTR\SOchannelReserve\DC2\EM\n\
      \\bmin_htlc\CAN\t \SOH(\EOTR\aminHtlc\DC2\FS\n\
      \\n\
      \fee_per_kw\CAN\n\
      \ \SOH(\EOTR\bfeePerKw\DC2\ESC\n\
      \\tcsv_delay\CAN\v \SOH(\rR\bcsvDelay\DC2,\n\
      \\DC2max_accepted_htlcs\CAN\f \SOH(\rR\DLEmaxAcceptedHtlcs\DC2#\n\
      \\rchannel_flags\CAN\r \SOH(\rR\fchannelFlags\DC2>\n\
      \\SIcommitment_type\CAN\SO \SOH(\SO2\NAK.lnrpc.CommitmentTypeR\SOcommitmentType"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        nodePubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "node_pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"nodePubkey")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        chainHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "chain_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"chainHash")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        pendingChanId__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pending_chan_id"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"pendingChanId")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        fundingAmt__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "funding_amt"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"fundingAmt")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        pushAmt__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "push_amt"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pushAmt")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        dustLimit__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "dust_limit"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"dustLimit")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        maxValueInFlight__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "max_value_in_flight"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"maxValueInFlight")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        channelReserve__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channel_reserve"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"channelReserve")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        minHtlc__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_htlc"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"minHtlc")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        feePerKw__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "fee_per_kw"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"feePerKw")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        csvDelay__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "csv_delay"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"csvDelay")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        maxAcceptedHtlcs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "max_accepted_htlcs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"maxAcceptedHtlcs")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        channelFlags__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channel_flags"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"channelFlags")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
        commitmentType__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "commitment_type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.CommitmentType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"commitmentType")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, nodePubkey__field_descriptor),
           (Data.ProtoLens.Tag 2, chainHash__field_descriptor),
           (Data.ProtoLens.Tag 3, pendingChanId__field_descriptor),
           (Data.ProtoLens.Tag 4, fundingAmt__field_descriptor),
           (Data.ProtoLens.Tag 5, pushAmt__field_descriptor),
           (Data.ProtoLens.Tag 6, dustLimit__field_descriptor),
           (Data.ProtoLens.Tag 7, maxValueInFlight__field_descriptor),
           (Data.ProtoLens.Tag 8, channelReserve__field_descriptor),
           (Data.ProtoLens.Tag 9, minHtlc__field_descriptor),
           (Data.ProtoLens.Tag 10, feePerKw__field_descriptor),
           (Data.ProtoLens.Tag 11, csvDelay__field_descriptor),
           (Data.ProtoLens.Tag 12, maxAcceptedHtlcs__field_descriptor),
           (Data.ProtoLens.Tag 13, channelFlags__field_descriptor),
           (Data.ProtoLens.Tag 14, commitmentType__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ChannelAcceptRequest'_unknownFields
        (\ x__ y__ -> x__ {_ChannelAcceptRequest'_unknownFields = y__})
  defMessage
    = ChannelAcceptRequest'_constructor
        {_ChannelAcceptRequest'nodePubkey = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'chainHash = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'pendingChanId = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'fundingAmt = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'pushAmt = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'dustLimit = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'maxValueInFlight = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'channelReserve = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'minHtlc = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'feePerKw = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'csvDelay = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'maxAcceptedHtlcs = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'channelFlags = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'commitmentType = Data.ProtoLens.fieldDefault,
         _ChannelAcceptRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ChannelAcceptRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser ChannelAcceptRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "node_pubkey"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"nodePubkey") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "chain_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"chainHash") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "pending_chan_id"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"pendingChanId") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "funding_amt"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"fundingAmt") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "push_amt"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pushAmt") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "dust_limit"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"dustLimit") y x)
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "max_value_in_flight"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"maxValueInFlight") y x)
                        64
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "channel_reserve"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"channelReserve") y x)
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "min_htlc"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"minHtlc") y x)
                        80
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "fee_per_kw"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"feePerKw") y x)
                        88
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "csv_delay"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"csvDelay") y x)
                        96
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "max_accepted_htlcs"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"maxAcceptedHtlcs") y x)
                        104
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "channel_flags"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"channelFlags") y x)
                        112
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "commitment_type"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"commitmentType") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ChannelAcceptRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"nodePubkey") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"chainHash") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view
                            (Data.ProtoLens.Field.field @"pendingChanId") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view (Data.ProtoLens.Field.field @"fundingAmt") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                      ((Data.Monoid.<>)
                         (let
                            _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pushAmt") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"dustLimit") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"maxValueInFlight") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"channelReserve") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 64)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"minHtlc") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                                     ((Data.Monoid.<>)
                                        (let
                                           _v
                                             = Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"feePerKw") _x
                                         in
                                           if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                               Data.Monoid.mempty
                                           else
                                               (Data.Monoid.<>)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt 80)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                                        ((Data.Monoid.<>)
                                           (let
                                              _v
                                                = Lens.Family2.view
                                                    (Data.ProtoLens.Field.field @"csvDelay") _x
                                            in
                                              if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                  Data.Monoid.mempty
                                              else
                                                  (Data.Monoid.<>)
                                                    (Data.ProtoLens.Encoding.Bytes.putVarInt 88)
                                                    ((Prelude..)
                                                       Data.ProtoLens.Encoding.Bytes.putVarInt
                                                       Prelude.fromIntegral _v))
                                           ((Data.Monoid.<>)
                                              (let
                                                 _v
                                                   = Lens.Family2.view
                                                       (Data.ProtoLens.Field.field
                                                          @"maxAcceptedHtlcs")
                                                       _x
                                               in
                                                 if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                     Data.Monoid.mempty
                                                 else
                                                     (Data.Monoid.<>)
                                                       (Data.ProtoLens.Encoding.Bytes.putVarInt 96)
                                                       ((Prelude..)
                                                          Data.ProtoLens.Encoding.Bytes.putVarInt
                                                          Prelude.fromIntegral _v))
                                              ((Data.Monoid.<>)
                                                 (let
                                                    _v
                                                      = Lens.Family2.view
                                                          (Data.ProtoLens.Field.field
                                                             @"channelFlags")
                                                          _x
                                                  in
                                                    if (Prelude.==)
                                                         _v Data.ProtoLens.fieldDefault then
                                                        Data.Monoid.mempty
                                                    else
                                                        (Data.Monoid.<>)
                                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             104)
                                                          ((Prelude..)
                                                             Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             Prelude.fromIntegral _v))
                                                 ((Data.Monoid.<>)
                                                    (let
                                                       _v
                                                         = Lens.Family2.view
                                                             (Data.ProtoLens.Field.field
                                                                @"commitmentType")
                                                             _x
                                                     in
                                                       if (Prelude.==)
                                                            _v Data.ProtoLens.fieldDefault then
                                                           Data.Monoid.mempty
                                                       else
                                                           (Data.Monoid.<>)
                                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                112)
                                                             ((Prelude..)
                                                                ((Prelude..)
                                                                   Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                   Prelude.fromIntegral)
                                                                Prelude.fromEnum _v))
                                                    (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                                       (Lens.Family2.view
                                                          Data.ProtoLens.unknownFields
                                                          _x)))))))))))))))
instance Control.DeepSeq.NFData ChannelAcceptRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ChannelAcceptRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ChannelAcceptRequest'nodePubkey x__)
                (Control.DeepSeq.deepseq
                   (_ChannelAcceptRequest'chainHash x__)
                   (Control.DeepSeq.deepseq
                      (_ChannelAcceptRequest'pendingChanId x__)
                      (Control.DeepSeq.deepseq
                         (_ChannelAcceptRequest'fundingAmt x__)
                         (Control.DeepSeq.deepseq
                            (_ChannelAcceptRequest'pushAmt x__)
                            (Control.DeepSeq.deepseq
                               (_ChannelAcceptRequest'dustLimit x__)
                               (Control.DeepSeq.deepseq
                                  (_ChannelAcceptRequest'maxValueInFlight x__)
                                  (Control.DeepSeq.deepseq
                                     (_ChannelAcceptRequest'channelReserve x__)
                                     (Control.DeepSeq.deepseq
                                        (_ChannelAcceptRequest'minHtlc x__)
                                        (Control.DeepSeq.deepseq
                                           (_ChannelAcceptRequest'feePerKw x__)
                                           (Control.DeepSeq.deepseq
                                              (_ChannelAcceptRequest'csvDelay x__)
                                              (Control.DeepSeq.deepseq
                                                 (_ChannelAcceptRequest'maxAcceptedHtlcs x__)
                                                 (Control.DeepSeq.deepseq
                                                    (_ChannelAcceptRequest'channelFlags x__)
                                                    (Control.DeepSeq.deepseq
                                                       (_ChannelAcceptRequest'commitmentType x__)
                                                       ()))))))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.accept' @:: Lens' ChannelAcceptResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.pendingChanId' @:: Lens' ChannelAcceptResponse Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.error' @:: Lens' ChannelAcceptResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.upfrontShutdown' @:: Lens' ChannelAcceptResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.csvDelay' @:: Lens' ChannelAcceptResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.reserveSat' @:: Lens' ChannelAcceptResponse Data.Word.Word64@
         * 'Proto.Lightning_Fields.inFlightMaxMsat' @:: Lens' ChannelAcceptResponse Data.Word.Word64@
         * 'Proto.Lightning_Fields.maxHtlcCount' @:: Lens' ChannelAcceptResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.minHtlcIn' @:: Lens' ChannelAcceptResponse Data.Word.Word64@
         * 'Proto.Lightning_Fields.minAcceptDepth' @:: Lens' ChannelAcceptResponse Data.Word.Word32@ -}
data ChannelAcceptResponse
  = ChannelAcceptResponse'_constructor {_ChannelAcceptResponse'accept :: !Prelude.Bool,
                                        _ChannelAcceptResponse'pendingChanId :: !Data.ByteString.ByteString,
                                        _ChannelAcceptResponse'error :: !Data.Text.Text,
                                        _ChannelAcceptResponse'upfrontShutdown :: !Data.Text.Text,
                                        _ChannelAcceptResponse'csvDelay :: !Data.Word.Word32,
                                        _ChannelAcceptResponse'reserveSat :: !Data.Word.Word64,
                                        _ChannelAcceptResponse'inFlightMaxMsat :: !Data.Word.Word64,
                                        _ChannelAcceptResponse'maxHtlcCount :: !Data.Word.Word32,
                                        _ChannelAcceptResponse'minHtlcIn :: !Data.Word.Word64,
                                        _ChannelAcceptResponse'minAcceptDepth :: !Data.Word.Word32,
                                        _ChannelAcceptResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ChannelAcceptResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ChannelAcceptResponse
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "accept" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'accept
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'accept = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "pendingChanId" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'pendingChanId
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'pendingChanId = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "error" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'error
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'error = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "upfrontShutdown" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'upfrontShutdown
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'upfrontShutdown = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "csvDelay" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'csvDelay
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'csvDelay = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "reserveSat" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'reserveSat
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'reserveSat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "inFlightMaxMsat" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'inFlightMaxMsat
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'inFlightMaxMsat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "maxHtlcCount" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'maxHtlcCount
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'maxHtlcCount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "minHtlcIn" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'minHtlcIn
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'minHtlcIn = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelAcceptResponse "minAcceptDepth" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelAcceptResponse'minAcceptDepth
           (\ x__ y__ -> x__ {_ChannelAcceptResponse'minAcceptDepth = y__}))
        Prelude.id
instance Data.ProtoLens.Message ChannelAcceptResponse where
  messageName _ = Data.Text.pack "lnrpc.ChannelAcceptResponse"
  packedMessageDescriptor _
    = "\n\
      \\NAKChannelAcceptResponse\DC2\SYN\n\
      \\ACKaccept\CAN\SOH \SOH(\bR\ACKaccept\DC2&\n\
      \\SIpending_chan_id\CAN\STX \SOH(\fR\rpendingChanId\DC2\DC4\n\
      \\ENQerror\CAN\ETX \SOH(\tR\ENQerror\DC2)\n\
      \\DLEupfront_shutdown\CAN\EOT \SOH(\tR\SIupfrontShutdown\DC2\ESC\n\
      \\tcsv_delay\CAN\ENQ \SOH(\rR\bcsvDelay\DC2\US\n\
      \\vreserve_sat\CAN\ACK \SOH(\EOTR\n\
      \reserveSat\DC2+\n\
      \\DC2in_flight_max_msat\CAN\a \SOH(\EOTR\SIinFlightMaxMsat\DC2$\n\
      \\SOmax_htlc_count\CAN\b \SOH(\rR\fmaxHtlcCount\DC2\RS\n\
      \\vmin_htlc_in\CAN\t \SOH(\EOTR\tminHtlcIn\DC2(\n\
      \\DLEmin_accept_depth\CAN\n\
      \ \SOH(\rR\SOminAcceptDepth"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        accept__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "accept"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"accept")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        pendingChanId__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pending_chan_id"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"pendingChanId")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        error__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "error"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"error")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        upfrontShutdown__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "upfront_shutdown"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"upfrontShutdown")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        csvDelay__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "csv_delay"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"csvDelay")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        reserveSat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "reserve_sat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"reserveSat")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        inFlightMaxMsat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "in_flight_max_msat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"inFlightMaxMsat")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        maxHtlcCount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "max_htlc_count"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"maxHtlcCount")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        minHtlcIn__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_htlc_in"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minHtlcIn")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
        minAcceptDepth__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_accept_depth"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minAcceptDepth")) ::
              Data.ProtoLens.FieldDescriptor ChannelAcceptResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, accept__field_descriptor),
           (Data.ProtoLens.Tag 2, pendingChanId__field_descriptor),
           (Data.ProtoLens.Tag 3, error__field_descriptor),
           (Data.ProtoLens.Tag 4, upfrontShutdown__field_descriptor),
           (Data.ProtoLens.Tag 5, csvDelay__field_descriptor),
           (Data.ProtoLens.Tag 6, reserveSat__field_descriptor),
           (Data.ProtoLens.Tag 7, inFlightMaxMsat__field_descriptor),
           (Data.ProtoLens.Tag 8, maxHtlcCount__field_descriptor),
           (Data.ProtoLens.Tag 9, minHtlcIn__field_descriptor),
           (Data.ProtoLens.Tag 10, minAcceptDepth__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ChannelAcceptResponse'_unknownFields
        (\ x__ y__ -> x__ {_ChannelAcceptResponse'_unknownFields = y__})
  defMessage
    = ChannelAcceptResponse'_constructor
        {_ChannelAcceptResponse'accept = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'pendingChanId = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'error = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'upfrontShutdown = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'csvDelay = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'reserveSat = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'inFlightMaxMsat = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'maxHtlcCount = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'minHtlcIn = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'minAcceptDepth = Data.ProtoLens.fieldDefault,
         _ChannelAcceptResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ChannelAcceptResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser ChannelAcceptResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "accept"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"accept") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "pending_chan_id"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"pendingChanId") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "error"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"error") y x)
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "upfront_shutdown"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"upfrontShutdown") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "csv_delay"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"csvDelay") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "reserve_sat"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"reserveSat") y x)
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "in_flight_max_msat"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"inFlightMaxMsat") y x)
                        64
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "max_htlc_count"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"maxHtlcCount") y x)
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "min_htlc_in"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minHtlcIn") y x)
                        80
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_accept_depth"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"minAcceptDepth") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ChannelAcceptResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"accept") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"pendingChanId") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"error") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((Prelude..)
                               (\ bs
                                  -> (Data.Monoid.<>)
                                       (Data.ProtoLens.Encoding.Bytes.putVarInt
                                          (Prelude.fromIntegral (Data.ByteString.length bs)))
                                       (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               Data.Text.Encoding.encodeUtf8 _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view
                               (Data.ProtoLens.Field.field @"upfrontShutdown") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                               ((Prelude..)
                                  (\ bs
                                     -> (Data.Monoid.<>)
                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                             (Prelude.fromIntegral (Data.ByteString.length bs)))
                                          (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                  Data.Text.Encoding.encodeUtf8 _v))
                      ((Data.Monoid.<>)
                         (let
                            _v = Lens.Family2.view (Data.ProtoLens.Field.field @"csvDelay") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view (Data.ProtoLens.Field.field @"reserveSat") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"inFlightMaxMsat") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"maxHtlcCount") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 64)
                                           ((Prelude..)
                                              Data.ProtoLens.Encoding.Bytes.putVarInt
                                              Prelude.fromIntegral _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"minHtlcIn") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                                     ((Data.Monoid.<>)
                                        (let
                                           _v
                                             = Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"minAcceptDepth") _x
                                         in
                                           if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                               Data.Monoid.mempty
                                           else
                                               (Data.Monoid.<>)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt 80)
                                                 ((Prelude..)
                                                    Data.ProtoLens.Encoding.Bytes.putVarInt
                                                    Prelude.fromIntegral _v))
                                        (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                           (Lens.Family2.view
                                              Data.ProtoLens.unknownFields _x)))))))))))
instance Control.DeepSeq.NFData ChannelAcceptResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ChannelAcceptResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ChannelAcceptResponse'accept x__)
                (Control.DeepSeq.deepseq
                   (_ChannelAcceptResponse'pendingChanId x__)
                   (Control.DeepSeq.deepseq
                      (_ChannelAcceptResponse'error x__)
                      (Control.DeepSeq.deepseq
                         (_ChannelAcceptResponse'upfrontShutdown x__)
                         (Control.DeepSeq.deepseq
                            (_ChannelAcceptResponse'csvDelay x__)
                            (Control.DeepSeq.deepseq
                               (_ChannelAcceptResponse'reserveSat x__)
                               (Control.DeepSeq.deepseq
                                  (_ChannelAcceptResponse'inFlightMaxMsat x__)
                                  (Control.DeepSeq.deepseq
                                     (_ChannelAcceptResponse'maxHtlcCount x__)
                                     (Control.DeepSeq.deepseq
                                        (_ChannelAcceptResponse'minHtlcIn x__)
                                        (Control.DeepSeq.deepseq
                                           (_ChannelAcceptResponse'minAcceptDepth x__) ()))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.closingTxid' @:: Lens' ChannelCloseUpdate Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.success' @:: Lens' ChannelCloseUpdate Prelude.Bool@ -}
data ChannelCloseUpdate
  = ChannelCloseUpdate'_constructor {_ChannelCloseUpdate'closingTxid :: !Data.ByteString.ByteString,
                                     _ChannelCloseUpdate'success :: !Prelude.Bool,
                                     _ChannelCloseUpdate'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ChannelCloseUpdate where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ChannelCloseUpdate
instance Data.ProtoLens.Field.HasField ChannelCloseUpdate "closingTxid" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelCloseUpdate'closingTxid
           (\ x__ y__ -> x__ {_ChannelCloseUpdate'closingTxid = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ChannelCloseUpdate "success" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelCloseUpdate'success
           (\ x__ y__ -> x__ {_ChannelCloseUpdate'success = y__}))
        Prelude.id
instance Data.ProtoLens.Message ChannelCloseUpdate where
  messageName _ = Data.Text.pack "lnrpc.ChannelCloseUpdate"
  packedMessageDescriptor _
    = "\n\
      \\DC2ChannelCloseUpdate\DC2!\n\
      \\fclosing_txid\CAN\SOH \SOH(\fR\vclosingTxid\DC2\CAN\n\
      \\asuccess\CAN\STX \SOH(\bR\asuccess"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        closingTxid__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "closing_txid"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"closingTxid")) ::
              Data.ProtoLens.FieldDescriptor ChannelCloseUpdate
        success__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "success"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"success")) ::
              Data.ProtoLens.FieldDescriptor ChannelCloseUpdate
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, closingTxid__field_descriptor),
           (Data.ProtoLens.Tag 2, success__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ChannelCloseUpdate'_unknownFields
        (\ x__ y__ -> x__ {_ChannelCloseUpdate'_unknownFields = y__})
  defMessage
    = ChannelCloseUpdate'_constructor
        {_ChannelCloseUpdate'closingTxid = Data.ProtoLens.fieldDefault,
         _ChannelCloseUpdate'success = Data.ProtoLens.fieldDefault,
         _ChannelCloseUpdate'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ChannelCloseUpdate
          -> Data.ProtoLens.Encoding.Bytes.Parser ChannelCloseUpdate
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "closing_txid"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"closingTxid") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "success"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"success") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ChannelCloseUpdate"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"closingTxid") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"success") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData ChannelCloseUpdate where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ChannelCloseUpdate'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ChannelCloseUpdate'closingTxid x__)
                (Control.DeepSeq.deepseq (_ChannelCloseUpdate'success x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.channelPoint' @:: Lens' ChannelOpenUpdate Proto.Lnrpc.Ln0.ChannelPoint@
         * 'Proto.Lightning_Fields.maybe'channelPoint' @:: Lens' ChannelOpenUpdate (Prelude.Maybe Proto.Lnrpc.Ln0.ChannelPoint)@ -}
data ChannelOpenUpdate
  = ChannelOpenUpdate'_constructor {_ChannelOpenUpdate'channelPoint :: !(Prelude.Maybe Proto.Lnrpc.Ln0.ChannelPoint),
                                    _ChannelOpenUpdate'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ChannelOpenUpdate where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ChannelOpenUpdate
instance Data.ProtoLens.Field.HasField ChannelOpenUpdate "channelPoint" Proto.Lnrpc.Ln0.ChannelPoint where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelOpenUpdate'channelPoint
           (\ x__ y__ -> x__ {_ChannelOpenUpdate'channelPoint = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField ChannelOpenUpdate "maybe'channelPoint" (Prelude.Maybe Proto.Lnrpc.Ln0.ChannelPoint) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ChannelOpenUpdate'channelPoint
           (\ x__ y__ -> x__ {_ChannelOpenUpdate'channelPoint = y__}))
        Prelude.id
instance Data.ProtoLens.Message ChannelOpenUpdate where
  messageName _ = Data.Text.pack "lnrpc.ChannelOpenUpdate"
  packedMessageDescriptor _
    = "\n\
      \\DC1ChannelOpenUpdate\DC28\n\
      \\rchannel_point\CAN\SOH \SOH(\v2\DC3.lnrpc.ChannelPointR\fchannelPoint"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        channelPoint__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channel_point"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.ChannelPoint)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'channelPoint")) ::
              Data.ProtoLens.FieldDescriptor ChannelOpenUpdate
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, channelPoint__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ChannelOpenUpdate'_unknownFields
        (\ x__ y__ -> x__ {_ChannelOpenUpdate'_unknownFields = y__})
  defMessage
    = ChannelOpenUpdate'_constructor
        {_ChannelOpenUpdate'channelPoint = Prelude.Nothing,
         _ChannelOpenUpdate'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ChannelOpenUpdate
          -> Data.ProtoLens.Encoding.Bytes.Parser ChannelOpenUpdate
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "channel_point"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"channelPoint") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ChannelOpenUpdate"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (case
                  Lens.Family2.view
                    (Data.ProtoLens.Field.field @"maybe'channelPoint") _x
              of
                Prelude.Nothing -> Data.Monoid.mempty
                (Prelude.Just _v)
                  -> (Data.Monoid.<>)
                       (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                       ((Prelude..)
                          (\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                          Data.ProtoLens.encodeMessage _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData ChannelOpenUpdate where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ChannelOpenUpdate'_unknownFields x__)
             (Control.DeepSeq.deepseq (_ChannelOpenUpdate'channelPoint x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.channelPoint' @:: Lens' CloseChannelRequest Proto.Lnrpc.Ln0.ChannelPoint@
         * 'Proto.Lightning_Fields.maybe'channelPoint' @:: Lens' CloseChannelRequest (Prelude.Maybe Proto.Lnrpc.Ln0.ChannelPoint)@
         * 'Proto.Lightning_Fields.force' @:: Lens' CloseChannelRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.targetConf' @:: Lens' CloseChannelRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.satPerByte' @:: Lens' CloseChannelRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.deliveryAddress' @:: Lens' CloseChannelRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.satPerVbyte' @:: Lens' CloseChannelRequest Data.Word.Word64@ -}
data CloseChannelRequest
  = CloseChannelRequest'_constructor {_CloseChannelRequest'channelPoint :: !(Prelude.Maybe Proto.Lnrpc.Ln0.ChannelPoint),
                                      _CloseChannelRequest'force :: !Prelude.Bool,
                                      _CloseChannelRequest'targetConf :: !Data.Int.Int32,
                                      _CloseChannelRequest'satPerByte :: !Data.Int.Int64,
                                      _CloseChannelRequest'deliveryAddress :: !Data.Text.Text,
                                      _CloseChannelRequest'satPerVbyte :: !Data.Word.Word64,
                                      _CloseChannelRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show CloseChannelRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out CloseChannelRequest
instance Data.ProtoLens.Field.HasField CloseChannelRequest "channelPoint" Proto.Lnrpc.Ln0.ChannelPoint where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'channelPoint
           (\ x__ y__ -> x__ {_CloseChannelRequest'channelPoint = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField CloseChannelRequest "maybe'channelPoint" (Prelude.Maybe Proto.Lnrpc.Ln0.ChannelPoint) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'channelPoint
           (\ x__ y__ -> x__ {_CloseChannelRequest'channelPoint = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CloseChannelRequest "force" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'force
           (\ x__ y__ -> x__ {_CloseChannelRequest'force = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CloseChannelRequest "targetConf" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'targetConf
           (\ x__ y__ -> x__ {_CloseChannelRequest'targetConf = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CloseChannelRequest "satPerByte" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'satPerByte
           (\ x__ y__ -> x__ {_CloseChannelRequest'satPerByte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CloseChannelRequest "deliveryAddress" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'deliveryAddress
           (\ x__ y__ -> x__ {_CloseChannelRequest'deliveryAddress = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CloseChannelRequest "satPerVbyte" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseChannelRequest'satPerVbyte
           (\ x__ y__ -> x__ {_CloseChannelRequest'satPerVbyte = y__}))
        Prelude.id
instance Data.ProtoLens.Message CloseChannelRequest where
  messageName _ = Data.Text.pack "lnrpc.CloseChannelRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC3CloseChannelRequest\DC28\n\
      \\rchannel_point\CAN\SOH \SOH(\v2\DC3.lnrpc.ChannelPointR\fchannelPoint\DC2\DC4\n\
      \\ENQforce\CAN\STX \SOH(\bR\ENQforce\DC2\US\n\
      \\vtarget_conf\CAN\ETX \SOH(\ENQR\n\
      \targetConf\DC2$\n\
      \\fsat_per_byte\CAN\EOT \SOH(\ETXR\n\
      \satPerByteB\STX\CAN\SOH\DC2)\n\
      \\DLEdelivery_address\CAN\ENQ \SOH(\tR\SIdeliveryAddress\DC2\"\n\
      \\rsat_per_vbyte\CAN\ACK \SOH(\EOTR\vsatPerVbyte"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        channelPoint__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channel_point"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.ChannelPoint)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'channelPoint")) ::
              Data.ProtoLens.FieldDescriptor CloseChannelRequest
        force__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "force"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"force")) ::
              Data.ProtoLens.FieldDescriptor CloseChannelRequest
        targetConf__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "target_conf"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"targetConf")) ::
              Data.ProtoLens.FieldDescriptor CloseChannelRequest
        satPerByte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_byte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerByte")) ::
              Data.ProtoLens.FieldDescriptor CloseChannelRequest
        deliveryAddress__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "delivery_address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"deliveryAddress")) ::
              Data.ProtoLens.FieldDescriptor CloseChannelRequest
        satPerVbyte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_vbyte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerVbyte")) ::
              Data.ProtoLens.FieldDescriptor CloseChannelRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, channelPoint__field_descriptor),
           (Data.ProtoLens.Tag 2, force__field_descriptor),
           (Data.ProtoLens.Tag 3, targetConf__field_descriptor),
           (Data.ProtoLens.Tag 4, satPerByte__field_descriptor),
           (Data.ProtoLens.Tag 5, deliveryAddress__field_descriptor),
           (Data.ProtoLens.Tag 6, satPerVbyte__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _CloseChannelRequest'_unknownFields
        (\ x__ y__ -> x__ {_CloseChannelRequest'_unknownFields = y__})
  defMessage
    = CloseChannelRequest'_constructor
        {_CloseChannelRequest'channelPoint = Prelude.Nothing,
         _CloseChannelRequest'force = Data.ProtoLens.fieldDefault,
         _CloseChannelRequest'targetConf = Data.ProtoLens.fieldDefault,
         _CloseChannelRequest'satPerByte = Data.ProtoLens.fieldDefault,
         _CloseChannelRequest'deliveryAddress = Data.ProtoLens.fieldDefault,
         _CloseChannelRequest'satPerVbyte = Data.ProtoLens.fieldDefault,
         _CloseChannelRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          CloseChannelRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser CloseChannelRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "channel_point"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"channelPoint") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "force"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"force") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "target_conf"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"targetConf") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_per_byte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerByte") y x)
                        42
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "delivery_address"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"deliveryAddress") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "sat_per_vbyte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerVbyte") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "CloseChannelRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (case
                  Lens.Family2.view
                    (Data.ProtoLens.Field.field @"maybe'channelPoint") _x
              of
                Prelude.Nothing -> Data.Monoid.mempty
                (Prelude.Just _v)
                  -> (Data.Monoid.<>)
                       (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                       ((Prelude..)
                          (\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                          Data.ProtoLens.encodeMessage _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"force") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"targetConf") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerByte") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view
                                  (Data.ProtoLens.Field.field @"deliveryAddress") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 42)
                                  ((Prelude..)
                                     (\ bs
                                        -> (Data.Monoid.<>)
                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                (Prelude.fromIntegral (Data.ByteString.length bs)))
                                             (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                     Data.Text.Encoding.encodeUtf8 _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerVbyte") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                            (Data.ProtoLens.Encoding.Wire.buildFieldSet
                               (Lens.Family2.view Data.ProtoLens.unknownFields _x)))))))
instance Control.DeepSeq.NFData CloseChannelRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_CloseChannelRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_CloseChannelRequest'channelPoint x__)
                (Control.DeepSeq.deepseq
                   (_CloseChannelRequest'force x__)
                   (Control.DeepSeq.deepseq
                      (_CloseChannelRequest'targetConf x__)
                      (Control.DeepSeq.deepseq
                         (_CloseChannelRequest'satPerByte x__)
                         (Control.DeepSeq.deepseq
                            (_CloseChannelRequest'deliveryAddress x__)
                            (Control.DeepSeq.deepseq
                               (_CloseChannelRequest'satPerVbyte x__) ()))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.maybe'update' @:: Lens' CloseStatusUpdate (Prelude.Maybe CloseStatusUpdate'Update)@
         * 'Proto.Lightning_Fields.maybe'closePending' @:: Lens' CloseStatusUpdate (Prelude.Maybe Proto.Lnrpc.Ln0.PendingUpdate)@
         * 'Proto.Lightning_Fields.closePending' @:: Lens' CloseStatusUpdate Proto.Lnrpc.Ln0.PendingUpdate@
         * 'Proto.Lightning_Fields.maybe'chanClose' @:: Lens' CloseStatusUpdate (Prelude.Maybe ChannelCloseUpdate)@
         * 'Proto.Lightning_Fields.chanClose' @:: Lens' CloseStatusUpdate ChannelCloseUpdate@ -}
data CloseStatusUpdate
  = CloseStatusUpdate'_constructor {_CloseStatusUpdate'update :: !(Prelude.Maybe CloseStatusUpdate'Update),
                                    _CloseStatusUpdate'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show CloseStatusUpdate where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out CloseStatusUpdate
data CloseStatusUpdate'Update
  = CloseStatusUpdate'ClosePending !Proto.Lnrpc.Ln0.PendingUpdate |
    CloseStatusUpdate'ChanClose !ChannelCloseUpdate
  deriving stock (Prelude.Show,
                  Prelude.Eq,
                  Prelude.Ord,
                  GHC.Generics.Generic)
instance Text.PrettyPrint.GenericPretty.Out CloseStatusUpdate'Update
instance Data.ProtoLens.Field.HasField CloseStatusUpdate "maybe'update" (Prelude.Maybe CloseStatusUpdate'Update) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseStatusUpdate'update
           (\ x__ y__ -> x__ {_CloseStatusUpdate'update = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CloseStatusUpdate "maybe'closePending" (Prelude.Maybe Proto.Lnrpc.Ln0.PendingUpdate) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseStatusUpdate'update
           (\ x__ y__ -> x__ {_CloseStatusUpdate'update = y__}))
        (Lens.Family2.Unchecked.lens
           (\ x__
              -> case x__ of
                   (Prelude.Just (CloseStatusUpdate'ClosePending x__val))
                     -> Prelude.Just x__val
                   _otherwise -> Prelude.Nothing)
           (\ _ y__ -> Prelude.fmap CloseStatusUpdate'ClosePending y__))
instance Data.ProtoLens.Field.HasField CloseStatusUpdate "closePending" Proto.Lnrpc.Ln0.PendingUpdate where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseStatusUpdate'update
           (\ x__ y__ -> x__ {_CloseStatusUpdate'update = y__}))
        ((Prelude..)
           (Lens.Family2.Unchecked.lens
              (\ x__
                 -> case x__ of
                      (Prelude.Just (CloseStatusUpdate'ClosePending x__val))
                        -> Prelude.Just x__val
                      _otherwise -> Prelude.Nothing)
              (\ _ y__ -> Prelude.fmap CloseStatusUpdate'ClosePending y__))
           (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage))
instance Data.ProtoLens.Field.HasField CloseStatusUpdate "maybe'chanClose" (Prelude.Maybe ChannelCloseUpdate) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseStatusUpdate'update
           (\ x__ y__ -> x__ {_CloseStatusUpdate'update = y__}))
        (Lens.Family2.Unchecked.lens
           (\ x__
              -> case x__ of
                   (Prelude.Just (CloseStatusUpdate'ChanClose x__val))
                     -> Prelude.Just x__val
                   _otherwise -> Prelude.Nothing)
           (\ _ y__ -> Prelude.fmap CloseStatusUpdate'ChanClose y__))
instance Data.ProtoLens.Field.HasField CloseStatusUpdate "chanClose" ChannelCloseUpdate where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CloseStatusUpdate'update
           (\ x__ y__ -> x__ {_CloseStatusUpdate'update = y__}))
        ((Prelude..)
           (Lens.Family2.Unchecked.lens
              (\ x__
                 -> case x__ of
                      (Prelude.Just (CloseStatusUpdate'ChanClose x__val))
                        -> Prelude.Just x__val
                      _otherwise -> Prelude.Nothing)
              (\ _ y__ -> Prelude.fmap CloseStatusUpdate'ChanClose y__))
           (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage))
instance Data.ProtoLens.Message CloseStatusUpdate where
  messageName _ = Data.Text.pack "lnrpc.CloseStatusUpdate"
  packedMessageDescriptor _
    = "\n\
      \\DC1CloseStatusUpdate\DC2;\n\
      \\rclose_pending\CAN\SOH \SOH(\v2\DC4.lnrpc.PendingUpdateH\NULR\fclosePending\DC2:\n\
      \\n\
      \chan_close\CAN\ETX \SOH(\v2\EM.lnrpc.ChannelCloseUpdateH\NULR\tchanCloseB\b\n\
      \\ACKupdate"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        closePending__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "close_pending"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.PendingUpdate)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'closePending")) ::
              Data.ProtoLens.FieldDescriptor CloseStatusUpdate
        chanClose__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "chan_close"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor ChannelCloseUpdate)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'chanClose")) ::
              Data.ProtoLens.FieldDescriptor CloseStatusUpdate
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, closePending__field_descriptor),
           (Data.ProtoLens.Tag 3, chanClose__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _CloseStatusUpdate'_unknownFields
        (\ x__ y__ -> x__ {_CloseStatusUpdate'_unknownFields = y__})
  defMessage
    = CloseStatusUpdate'_constructor
        {_CloseStatusUpdate'update = Prelude.Nothing,
         _CloseStatusUpdate'_unknownFields = []}
  parseMessage
    = let
        loop ::
          CloseStatusUpdate
          -> Data.ProtoLens.Encoding.Bytes.Parser CloseStatusUpdate
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "close_pending"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"closePending") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "chan_close"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"chanClose") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "CloseStatusUpdate"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (case
                  Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'update") _x
              of
                Prelude.Nothing -> Data.Monoid.mempty
                (Prelude.Just (CloseStatusUpdate'ClosePending v))
                  -> (Data.Monoid.<>)
                       (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                       ((Prelude..)
                          (\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                          Data.ProtoLens.encodeMessage v)
                (Prelude.Just (CloseStatusUpdate'ChanClose v))
                  -> (Data.Monoid.<>)
                       (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                       ((Prelude..)
                          (\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                          Data.ProtoLens.encodeMessage v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData CloseStatusUpdate where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_CloseStatusUpdate'_unknownFields x__)
             (Control.DeepSeq.deepseq (_CloseStatusUpdate'update x__) ())
instance Control.DeepSeq.NFData CloseStatusUpdate'Update where
  rnf (CloseStatusUpdate'ClosePending x__) = Control.DeepSeq.rnf x__
  rnf (CloseStatusUpdate'ChanClose x__) = Control.DeepSeq.rnf x__
_CloseStatusUpdate'ClosePending ::
  Data.ProtoLens.Prism.Prism' CloseStatusUpdate'Update Proto.Lnrpc.Ln0.PendingUpdate
_CloseStatusUpdate'ClosePending
  = Data.ProtoLens.Prism.prism'
      CloseStatusUpdate'ClosePending
      (\ p__
         -> case p__ of
              (CloseStatusUpdate'ClosePending p__val) -> Prelude.Just p__val
              _otherwise -> Prelude.Nothing)
_CloseStatusUpdate'ChanClose ::
  Data.ProtoLens.Prism.Prism' CloseStatusUpdate'Update ChannelCloseUpdate
_CloseStatusUpdate'ChanClose
  = Data.ProtoLens.Prism.prism'
      CloseStatusUpdate'ChanClose
      (\ p__
         -> case p__ of
              (CloseStatusUpdate'ChanClose p__val) -> Prelude.Just p__val
              _otherwise -> Prelude.Nothing)
{- | Fields :
     
         * 'Proto.Lightning_Fields.cooperative' @:: Lens' ClosedChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.localForce' @:: Lens' ClosedChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.remoteForce' @:: Lens' ClosedChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.breach' @:: Lens' ClosedChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.fundingCanceled' @:: Lens' ClosedChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.abandoned' @:: Lens' ClosedChannelsRequest Prelude.Bool@ -}
data ClosedChannelsRequest
  = ClosedChannelsRequest'_constructor {_ClosedChannelsRequest'cooperative :: !Prelude.Bool,
                                        _ClosedChannelsRequest'localForce :: !Prelude.Bool,
                                        _ClosedChannelsRequest'remoteForce :: !Prelude.Bool,
                                        _ClosedChannelsRequest'breach :: !Prelude.Bool,
                                        _ClosedChannelsRequest'fundingCanceled :: !Prelude.Bool,
                                        _ClosedChannelsRequest'abandoned :: !Prelude.Bool,
                                        _ClosedChannelsRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ClosedChannelsRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ClosedChannelsRequest
instance Data.ProtoLens.Field.HasField ClosedChannelsRequest "cooperative" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsRequest'cooperative
           (\ x__ y__ -> x__ {_ClosedChannelsRequest'cooperative = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ClosedChannelsRequest "localForce" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsRequest'localForce
           (\ x__ y__ -> x__ {_ClosedChannelsRequest'localForce = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ClosedChannelsRequest "remoteForce" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsRequest'remoteForce
           (\ x__ y__ -> x__ {_ClosedChannelsRequest'remoteForce = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ClosedChannelsRequest "breach" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsRequest'breach
           (\ x__ y__ -> x__ {_ClosedChannelsRequest'breach = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ClosedChannelsRequest "fundingCanceled" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsRequest'fundingCanceled
           (\ x__ y__ -> x__ {_ClosedChannelsRequest'fundingCanceled = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ClosedChannelsRequest "abandoned" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsRequest'abandoned
           (\ x__ y__ -> x__ {_ClosedChannelsRequest'abandoned = y__}))
        Prelude.id
instance Data.ProtoLens.Message ClosedChannelsRequest where
  messageName _ = Data.Text.pack "lnrpc.ClosedChannelsRequest"
  packedMessageDescriptor _
    = "\n\
      \\NAKClosedChannelsRequest\DC2 \n\
      \\vcooperative\CAN\SOH \SOH(\bR\vcooperative\DC2\US\n\
      \\vlocal_force\CAN\STX \SOH(\bR\n\
      \localForce\DC2!\n\
      \\fremote_force\CAN\ETX \SOH(\bR\vremoteForce\DC2\SYN\n\
      \\ACKbreach\CAN\EOT \SOH(\bR\ACKbreach\DC2)\n\
      \\DLEfunding_canceled\CAN\ENQ \SOH(\bR\SIfundingCanceled\DC2\FS\n\
      \\tabandoned\CAN\ACK \SOH(\bR\tabandoned"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        cooperative__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "cooperative"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"cooperative")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsRequest
        localForce__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "local_force"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"localForce")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsRequest
        remoteForce__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "remote_force"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"remoteForce")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsRequest
        breach__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "breach"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"breach")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsRequest
        fundingCanceled__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "funding_canceled"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"fundingCanceled")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsRequest
        abandoned__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "abandoned"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"abandoned")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, cooperative__field_descriptor),
           (Data.ProtoLens.Tag 2, localForce__field_descriptor),
           (Data.ProtoLens.Tag 3, remoteForce__field_descriptor),
           (Data.ProtoLens.Tag 4, breach__field_descriptor),
           (Data.ProtoLens.Tag 5, fundingCanceled__field_descriptor),
           (Data.ProtoLens.Tag 6, abandoned__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ClosedChannelsRequest'_unknownFields
        (\ x__ y__ -> x__ {_ClosedChannelsRequest'_unknownFields = y__})
  defMessage
    = ClosedChannelsRequest'_constructor
        {_ClosedChannelsRequest'cooperative = Data.ProtoLens.fieldDefault,
         _ClosedChannelsRequest'localForce = Data.ProtoLens.fieldDefault,
         _ClosedChannelsRequest'remoteForce = Data.ProtoLens.fieldDefault,
         _ClosedChannelsRequest'breach = Data.ProtoLens.fieldDefault,
         _ClosedChannelsRequest'fundingCanceled = Data.ProtoLens.fieldDefault,
         _ClosedChannelsRequest'abandoned = Data.ProtoLens.fieldDefault,
         _ClosedChannelsRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ClosedChannelsRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser ClosedChannelsRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "cooperative"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"cooperative") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "local_force"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"localForce") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "remote_force"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"remoteForce") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "breach"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"breach") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "funding_canceled"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"fundingCanceled") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "abandoned"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"abandoned") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ClosedChannelsRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"cooperative") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"localForce") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"remoteForce") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                               _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"breach") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (\ b -> if b then 1 else 0) _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view
                                  (Data.ProtoLens.Field.field @"fundingCanceled") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (\ b -> if b then 1 else 0) _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"abandoned") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (\ b -> if b then 1 else 0) _v))
                            (Data.ProtoLens.Encoding.Wire.buildFieldSet
                               (Lens.Family2.view Data.ProtoLens.unknownFields _x)))))))
instance Control.DeepSeq.NFData ClosedChannelsRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ClosedChannelsRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ClosedChannelsRequest'cooperative x__)
                (Control.DeepSeq.deepseq
                   (_ClosedChannelsRequest'localForce x__)
                   (Control.DeepSeq.deepseq
                      (_ClosedChannelsRequest'remoteForce x__)
                      (Control.DeepSeq.deepseq
                         (_ClosedChannelsRequest'breach x__)
                         (Control.DeepSeq.deepseq
                            (_ClosedChannelsRequest'fundingCanceled x__)
                            (Control.DeepSeq.deepseq
                               (_ClosedChannelsRequest'abandoned x__) ()))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.channels' @:: Lens' ClosedChannelsResponse [Proto.Lnrpc.Ln0.ChannelCloseSummary]@
         * 'Proto.Lightning_Fields.vec'channels' @:: Lens' ClosedChannelsResponse (Data.Vector.Vector Proto.Lnrpc.Ln0.ChannelCloseSummary)@ -}
data ClosedChannelsResponse
  = ClosedChannelsResponse'_constructor {_ClosedChannelsResponse'channels :: !(Data.Vector.Vector Proto.Lnrpc.Ln0.ChannelCloseSummary),
                                         _ClosedChannelsResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ClosedChannelsResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ClosedChannelsResponse
instance Data.ProtoLens.Field.HasField ClosedChannelsResponse "channels" [Proto.Lnrpc.Ln0.ChannelCloseSummary] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsResponse'channels
           (\ x__ y__ -> x__ {_ClosedChannelsResponse'channels = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField ClosedChannelsResponse "vec'channels" (Data.Vector.Vector Proto.Lnrpc.Ln0.ChannelCloseSummary) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ClosedChannelsResponse'channels
           (\ x__ y__ -> x__ {_ClosedChannelsResponse'channels = y__}))
        Prelude.id
instance Data.ProtoLens.Message ClosedChannelsResponse where
  messageName _ = Data.Text.pack "lnrpc.ClosedChannelsResponse"
  packedMessageDescriptor _
    = "\n\
      \\SYNClosedChannelsResponse\DC26\n\
      \\bchannels\CAN\SOH \ETX(\v2\SUB.lnrpc.ChannelCloseSummaryR\bchannels"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        channels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channels"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.ChannelCloseSummary)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked
                 (Data.ProtoLens.Field.field @"channels")) ::
              Data.ProtoLens.FieldDescriptor ClosedChannelsResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, channels__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ClosedChannelsResponse'_unknownFields
        (\ x__ y__ -> x__ {_ClosedChannelsResponse'_unknownFields = y__})
  defMessage
    = ClosedChannelsResponse'_constructor
        {_ClosedChannelsResponse'channels = Data.Vector.Generic.empty,
         _ClosedChannelsResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ClosedChannelsResponse
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Proto.Lnrpc.Ln0.ChannelCloseSummary
             -> Data.ProtoLens.Encoding.Bytes.Parser ClosedChannelsResponse
        loop x mutable'channels
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'channels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                           (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                              mutable'channels)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'channels") frozen'channels x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "channels"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'channels y)
                                loop x v
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'channels
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'channels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                    Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'channels)
          "ClosedChannelsResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view
                   (Data.ProtoLens.Field.field @"vec'channels") _x))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData ClosedChannelsResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ClosedChannelsResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_ClosedChannelsResponse'channels x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.blockSha' @:: Lens' ConfirmationUpdate Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.blockHeight' @:: Lens' ConfirmationUpdate Data.Int.Int32@
         * 'Proto.Lightning_Fields.numConfsLeft' @:: Lens' ConfirmationUpdate Data.Word.Word32@ -}
data ConfirmationUpdate
  = ConfirmationUpdate'_constructor {_ConfirmationUpdate'blockSha :: !Data.ByteString.ByteString,
                                     _ConfirmationUpdate'blockHeight :: !Data.Int.Int32,
                                     _ConfirmationUpdate'numConfsLeft :: !Data.Word.Word32,
                                     _ConfirmationUpdate'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ConfirmationUpdate where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ConfirmationUpdate
instance Data.ProtoLens.Field.HasField ConfirmationUpdate "blockSha" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConfirmationUpdate'blockSha
           (\ x__ y__ -> x__ {_ConfirmationUpdate'blockSha = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ConfirmationUpdate "blockHeight" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConfirmationUpdate'blockHeight
           (\ x__ y__ -> x__ {_ConfirmationUpdate'blockHeight = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ConfirmationUpdate "numConfsLeft" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConfirmationUpdate'numConfsLeft
           (\ x__ y__ -> x__ {_ConfirmationUpdate'numConfsLeft = y__}))
        Prelude.id
instance Data.ProtoLens.Message ConfirmationUpdate where
  messageName _ = Data.Text.pack "lnrpc.ConfirmationUpdate"
  packedMessageDescriptor _
    = "\n\
      \\DC2ConfirmationUpdate\DC2\ESC\n\
      \\tblock_sha\CAN\SOH \SOH(\fR\bblockSha\DC2!\n\
      \\fblock_height\CAN\STX \SOH(\ENQR\vblockHeight\DC2$\n\
      \\SOnum_confs_left\CAN\ETX \SOH(\rR\fnumConfsLeft"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        blockSha__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "block_sha"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"blockSha")) ::
              Data.ProtoLens.FieldDescriptor ConfirmationUpdate
        blockHeight__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "block_height"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"blockHeight")) ::
              Data.ProtoLens.FieldDescriptor ConfirmationUpdate
        numConfsLeft__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "num_confs_left"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"numConfsLeft")) ::
              Data.ProtoLens.FieldDescriptor ConfirmationUpdate
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, blockSha__field_descriptor),
           (Data.ProtoLens.Tag 2, blockHeight__field_descriptor),
           (Data.ProtoLens.Tag 3, numConfsLeft__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ConfirmationUpdate'_unknownFields
        (\ x__ y__ -> x__ {_ConfirmationUpdate'_unknownFields = y__})
  defMessage
    = ConfirmationUpdate'_constructor
        {_ConfirmationUpdate'blockSha = Data.ProtoLens.fieldDefault,
         _ConfirmationUpdate'blockHeight = Data.ProtoLens.fieldDefault,
         _ConfirmationUpdate'numConfsLeft = Data.ProtoLens.fieldDefault,
         _ConfirmationUpdate'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ConfirmationUpdate
          -> Data.ProtoLens.Encoding.Bytes.Parser ConfirmationUpdate
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "block_sha"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"blockSha") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "block_height"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"blockHeight") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "num_confs_left"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"numConfsLeft") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ConfirmationUpdate"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"blockSha") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"blockHeight") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"numConfsLeft") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData ConfirmationUpdate where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ConfirmationUpdate'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ConfirmationUpdate'blockSha x__)
                (Control.DeepSeq.deepseq
                   (_ConfirmationUpdate'blockHeight x__)
                   (Control.DeepSeq.deepseq
                      (_ConfirmationUpdate'numConfsLeft x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.addr' @:: Lens' ConnectPeerRequest LightningAddress@
         * 'Proto.Lightning_Fields.maybe'addr' @:: Lens' ConnectPeerRequest (Prelude.Maybe LightningAddress)@
         * 'Proto.Lightning_Fields.perm' @:: Lens' ConnectPeerRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.timeout' @:: Lens' ConnectPeerRequest Data.Word.Word64@ -}
data ConnectPeerRequest
  = ConnectPeerRequest'_constructor {_ConnectPeerRequest'addr :: !(Prelude.Maybe LightningAddress),
                                     _ConnectPeerRequest'perm :: !Prelude.Bool,
                                     _ConnectPeerRequest'timeout :: !Data.Word.Word64,
                                     _ConnectPeerRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ConnectPeerRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ConnectPeerRequest
instance Data.ProtoLens.Field.HasField ConnectPeerRequest "addr" LightningAddress where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConnectPeerRequest'addr
           (\ x__ y__ -> x__ {_ConnectPeerRequest'addr = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField ConnectPeerRequest "maybe'addr" (Prelude.Maybe LightningAddress) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConnectPeerRequest'addr
           (\ x__ y__ -> x__ {_ConnectPeerRequest'addr = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ConnectPeerRequest "perm" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConnectPeerRequest'perm
           (\ x__ y__ -> x__ {_ConnectPeerRequest'perm = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ConnectPeerRequest "timeout" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ConnectPeerRequest'timeout
           (\ x__ y__ -> x__ {_ConnectPeerRequest'timeout = y__}))
        Prelude.id
instance Data.ProtoLens.Message ConnectPeerRequest where
  messageName _ = Data.Text.pack "lnrpc.ConnectPeerRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC2ConnectPeerRequest\DC2+\n\
      \\EOTaddr\CAN\SOH \SOH(\v2\ETB.lnrpc.LightningAddressR\EOTaddr\DC2\DC2\n\
      \\EOTperm\CAN\STX \SOH(\bR\EOTperm\DC2\CAN\n\
      \\atimeout\CAN\ETX \SOH(\EOTR\atimeout"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        addr__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "addr"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor LightningAddress)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'addr")) ::
              Data.ProtoLens.FieldDescriptor ConnectPeerRequest
        perm__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "perm"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"perm")) ::
              Data.ProtoLens.FieldDescriptor ConnectPeerRequest
        timeout__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "timeout"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"timeout")) ::
              Data.ProtoLens.FieldDescriptor ConnectPeerRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, addr__field_descriptor),
           (Data.ProtoLens.Tag 2, perm__field_descriptor),
           (Data.ProtoLens.Tag 3, timeout__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ConnectPeerRequest'_unknownFields
        (\ x__ y__ -> x__ {_ConnectPeerRequest'_unknownFields = y__})
  defMessage
    = ConnectPeerRequest'_constructor
        {_ConnectPeerRequest'addr = Prelude.Nothing,
         _ConnectPeerRequest'perm = Data.ProtoLens.fieldDefault,
         _ConnectPeerRequest'timeout = Data.ProtoLens.fieldDefault,
         _ConnectPeerRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ConnectPeerRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser ConnectPeerRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "addr"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"addr") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "perm"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"perm") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "timeout"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"timeout") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ConnectPeerRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (case
                  Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'addr") _x
              of
                Prelude.Nothing -> Data.Monoid.mempty
                (Prelude.Just _v)
                  -> (Data.Monoid.<>)
                       (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                       ((Prelude..)
                          (\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                          Data.ProtoLens.encodeMessage _v))
             ((Data.Monoid.<>)
                (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"perm") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"timeout") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData ConnectPeerRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ConnectPeerRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ConnectPeerRequest'addr x__)
                (Control.DeepSeq.deepseq
                   (_ConnectPeerRequest'perm x__)
                   (Control.DeepSeq.deepseq (_ConnectPeerRequest'timeout x__) ())))
{- | Fields :
      -}
data ConnectPeerResponse
  = ConnectPeerResponse'_constructor {_ConnectPeerResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ConnectPeerResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ConnectPeerResponse
instance Data.ProtoLens.Message ConnectPeerResponse where
  messageName _ = Data.Text.pack "lnrpc.ConnectPeerResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC3ConnectPeerResponse"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ConnectPeerResponse'_unknownFields
        (\ x__ y__ -> x__ {_ConnectPeerResponse'_unknownFields = y__})
  defMessage
    = ConnectPeerResponse'_constructor
        {_ConnectPeerResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ConnectPeerResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser ConnectPeerResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ConnectPeerResponse"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData ConnectPeerResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ConnectPeerResponse'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.peer' @:: Lens' CustomMessage Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.type'' @:: Lens' CustomMessage Data.Word.Word32@
         * 'Proto.Lightning_Fields.data'' @:: Lens' CustomMessage Data.ByteString.ByteString@ -}
data CustomMessage
  = CustomMessage'_constructor {_CustomMessage'peer :: !Data.ByteString.ByteString,
                                _CustomMessage'type' :: !Data.Word.Word32,
                                _CustomMessage'data' :: !Data.ByteString.ByteString,
                                _CustomMessage'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show CustomMessage where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out CustomMessage
instance Data.ProtoLens.Field.HasField CustomMessage "peer" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CustomMessage'peer (\ x__ y__ -> x__ {_CustomMessage'peer = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CustomMessage "type'" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CustomMessage'type'
           (\ x__ y__ -> x__ {_CustomMessage'type' = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField CustomMessage "data'" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _CustomMessage'data'
           (\ x__ y__ -> x__ {_CustomMessage'data' = y__}))
        Prelude.id
instance Data.ProtoLens.Message CustomMessage where
  messageName _ = Data.Text.pack "lnrpc.CustomMessage"
  packedMessageDescriptor _
    = "\n\
      \\rCustomMessage\DC2\DC2\n\
      \\EOTpeer\CAN\SOH \SOH(\fR\EOTpeer\DC2\DC2\n\
      \\EOTtype\CAN\STX \SOH(\rR\EOTtype\DC2\DC2\n\
      \\EOTdata\CAN\ETX \SOH(\fR\EOTdata"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        peer__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "peer"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"peer")) ::
              Data.ProtoLens.FieldDescriptor CustomMessage
        type'__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"type'")) ::
              Data.ProtoLens.FieldDescriptor CustomMessage
        data'__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "data"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"data'")) ::
              Data.ProtoLens.FieldDescriptor CustomMessage
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, peer__field_descriptor),
           (Data.ProtoLens.Tag 2, type'__field_descriptor),
           (Data.ProtoLens.Tag 3, data'__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _CustomMessage'_unknownFields
        (\ x__ y__ -> x__ {_CustomMessage'_unknownFields = y__})
  defMessage
    = CustomMessage'_constructor
        {_CustomMessage'peer = Data.ProtoLens.fieldDefault,
         _CustomMessage'type' = Data.ProtoLens.fieldDefault,
         _CustomMessage'data' = Data.ProtoLens.fieldDefault,
         _CustomMessage'_unknownFields = []}
  parseMessage
    = let
        loop ::
          CustomMessage -> Data.ProtoLens.Encoding.Bytes.Parser CustomMessage
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "peer"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"peer") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "type"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"type'") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "data"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"data'") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "CustomMessage"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"peer") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"type'") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"data'") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData CustomMessage where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_CustomMessage'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_CustomMessage'peer x__)
                (Control.DeepSeq.deepseq
                   (_CustomMessage'type' x__)
                   (Control.DeepSeq.deepseq (_CustomMessage'data' x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.pubKey' @:: Lens' DisconnectPeerRequest Data.Text.Text@ -}
data DisconnectPeerRequest
  = DisconnectPeerRequest'_constructor {_DisconnectPeerRequest'pubKey :: !Data.Text.Text,
                                        _DisconnectPeerRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show DisconnectPeerRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out DisconnectPeerRequest
instance Data.ProtoLens.Field.HasField DisconnectPeerRequest "pubKey" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _DisconnectPeerRequest'pubKey
           (\ x__ y__ -> x__ {_DisconnectPeerRequest'pubKey = y__}))
        Prelude.id
instance Data.ProtoLens.Message DisconnectPeerRequest where
  messageName _ = Data.Text.pack "lnrpc.DisconnectPeerRequest"
  packedMessageDescriptor _
    = "\n\
      \\NAKDisconnectPeerRequest\DC2\ETB\n\
      \\apub_key\CAN\SOH \SOH(\tR\ACKpubKey"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        pubKey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pub_key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pubKey")) ::
              Data.ProtoLens.FieldDescriptor DisconnectPeerRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, pubKey__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _DisconnectPeerRequest'_unknownFields
        (\ x__ y__ -> x__ {_DisconnectPeerRequest'_unknownFields = y__})
  defMessage
    = DisconnectPeerRequest'_constructor
        {_DisconnectPeerRequest'pubKey = Data.ProtoLens.fieldDefault,
         _DisconnectPeerRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          DisconnectPeerRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser DisconnectPeerRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "pub_key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pubKey") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "DisconnectPeerRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pubKey") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData DisconnectPeerRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_DisconnectPeerRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq (_DisconnectPeerRequest'pubKey x__) ())
{- | Fields :
      -}
data DisconnectPeerResponse
  = DisconnectPeerResponse'_constructor {_DisconnectPeerResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show DisconnectPeerResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out DisconnectPeerResponse
instance Data.ProtoLens.Message DisconnectPeerResponse where
  messageName _ = Data.Text.pack "lnrpc.DisconnectPeerResponse"
  packedMessageDescriptor _
    = "\n\
      \\SYNDisconnectPeerResponse"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _DisconnectPeerResponse'_unknownFields
        (\ x__ y__ -> x__ {_DisconnectPeerResponse'_unknownFields = y__})
  defMessage
    = DisconnectPeerResponse'_constructor
        {_DisconnectPeerResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          DisconnectPeerResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser DisconnectPeerResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "DisconnectPeerResponse"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData DisconnectPeerResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_DisconnectPeerResponse'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.addrToAmount' @:: Lens' EstimateFeeRequest (Data.Map.Map Data.Text.Text Data.Int.Int64)@
         * 'Proto.Lightning_Fields.targetConf' @:: Lens' EstimateFeeRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.minConfs' @:: Lens' EstimateFeeRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.spendUnconfirmed' @:: Lens' EstimateFeeRequest Prelude.Bool@ -}
data EstimateFeeRequest
  = EstimateFeeRequest'_constructor {_EstimateFeeRequest'addrToAmount :: !(Data.Map.Map Data.Text.Text Data.Int.Int64),
                                     _EstimateFeeRequest'targetConf :: !Data.Int.Int32,
                                     _EstimateFeeRequest'minConfs :: !Data.Int.Int32,
                                     _EstimateFeeRequest'spendUnconfirmed :: !Prelude.Bool,
                                     _EstimateFeeRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show EstimateFeeRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out EstimateFeeRequest
instance Data.ProtoLens.Field.HasField EstimateFeeRequest "addrToAmount" (Data.Map.Map Data.Text.Text Data.Int.Int64) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeRequest'addrToAmount
           (\ x__ y__ -> x__ {_EstimateFeeRequest'addrToAmount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField EstimateFeeRequest "targetConf" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeRequest'targetConf
           (\ x__ y__ -> x__ {_EstimateFeeRequest'targetConf = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField EstimateFeeRequest "minConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeRequest'minConfs
           (\ x__ y__ -> x__ {_EstimateFeeRequest'minConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField EstimateFeeRequest "spendUnconfirmed" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeRequest'spendUnconfirmed
           (\ x__ y__ -> x__ {_EstimateFeeRequest'spendUnconfirmed = y__}))
        Prelude.id
instance Data.ProtoLens.Message EstimateFeeRequest where
  messageName _ = Data.Text.pack "lnrpc.EstimateFeeRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC2EstimateFeeRequest\DC2O\n\
      \\fAddrToAmount\CAN\SOH \ETX(\v2+.lnrpc.EstimateFeeRequest.AddrToAmountEntryR\fAddrToAmount\DC2\US\n\
      \\vtarget_conf\CAN\STX \SOH(\ENQR\n\
      \targetConf\DC2\ESC\n\
      \\tmin_confs\CAN\ETX \SOH(\ENQR\bminConfs\DC2+\n\
      \\DC1spend_unconfirmed\CAN\EOT \SOH(\bR\DLEspendUnconfirmed\SUB?\n\
      \\DC1AddrToAmountEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\tR\ETXkey\DC2\DC4\n\
      \\ENQvalue\CAN\STX \SOH(\ETXR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        addrToAmount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "AddrToAmount"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor EstimateFeeRequest'AddrToAmountEntry)
              (Data.ProtoLens.MapField
                 (Data.ProtoLens.Field.field @"key")
                 (Data.ProtoLens.Field.field @"value")
                 (Data.ProtoLens.Field.field @"addrToAmount")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeRequest
        targetConf__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "target_conf"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"targetConf")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeRequest
        minConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minConfs")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeRequest
        spendUnconfirmed__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "spend_unconfirmed"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"spendUnconfirmed")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, addrToAmount__field_descriptor),
           (Data.ProtoLens.Tag 2, targetConf__field_descriptor),
           (Data.ProtoLens.Tag 3, minConfs__field_descriptor),
           (Data.ProtoLens.Tag 4, spendUnconfirmed__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _EstimateFeeRequest'_unknownFields
        (\ x__ y__ -> x__ {_EstimateFeeRequest'_unknownFields = y__})
  defMessage
    = EstimateFeeRequest'_constructor
        {_EstimateFeeRequest'addrToAmount = Data.Map.empty,
         _EstimateFeeRequest'targetConf = Data.ProtoLens.fieldDefault,
         _EstimateFeeRequest'minConfs = Data.ProtoLens.fieldDefault,
         _EstimateFeeRequest'spendUnconfirmed = Data.ProtoLens.fieldDefault,
         _EstimateFeeRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          EstimateFeeRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser EstimateFeeRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !(entry :: EstimateFeeRequest'AddrToAmountEntry) <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                                                                      (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                                                          Data.ProtoLens.Encoding.Bytes.isolate
                                                                                            (Prelude.fromIntegral
                                                                                               len)
                                                                                            Data.ProtoLens.parseMessage)
                                                                                      "AddrToAmount"
                                (let
                                   key = Lens.Family2.view (Data.ProtoLens.Field.field @"key") entry
                                   value
                                     = Lens.Family2.view (Data.ProtoLens.Field.field @"value") entry
                                 in
                                   loop
                                     (Lens.Family2.over
                                        (Data.ProtoLens.Field.field @"addrToAmount")
                                        (\ !t -> Data.Map.insert key value t) x))
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "target_conf"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"targetConf") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minConfs") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "spend_unconfirmed"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"spendUnconfirmed") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "EstimateFeeRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.Monoid.mconcat
                (Prelude.map
                   (\ _v
                      -> (Data.Monoid.<>)
                           (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                           ((Prelude..)
                              (\ bs
                                 -> (Data.Monoid.<>)
                                      (Data.ProtoLens.Encoding.Bytes.putVarInt
                                         (Prelude.fromIntegral (Data.ByteString.length bs)))
                                      (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                              Data.ProtoLens.encodeMessage
                              (Lens.Family2.set
                                 (Data.ProtoLens.Field.field @"key") (Prelude.fst _v)
                                 (Lens.Family2.set
                                    (Data.ProtoLens.Field.field @"value") (Prelude.snd _v)
                                    (Data.ProtoLens.defMessage ::
                                       EstimateFeeRequest'AddrToAmountEntry)))))
                   (Data.Map.toList
                      (Lens.Family2.view
                         (Data.ProtoLens.Field.field @"addrToAmount") _x))))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"targetConf") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"minConfs") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view
                               (Data.ProtoLens.Field.field @"spendUnconfirmed") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (\ b -> if b then 1 else 0) _v))
                      (Data.ProtoLens.Encoding.Wire.buildFieldSet
                         (Lens.Family2.view Data.ProtoLens.unknownFields _x)))))
instance Control.DeepSeq.NFData EstimateFeeRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_EstimateFeeRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_EstimateFeeRequest'addrToAmount x__)
                (Control.DeepSeq.deepseq
                   (_EstimateFeeRequest'targetConf x__)
                   (Control.DeepSeq.deepseq
                      (_EstimateFeeRequest'minConfs x__)
                      (Control.DeepSeq.deepseq
                         (_EstimateFeeRequest'spendUnconfirmed x__) ()))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.key' @:: Lens' EstimateFeeRequest'AddrToAmountEntry Data.Text.Text@
         * 'Proto.Lightning_Fields.value' @:: Lens' EstimateFeeRequest'AddrToAmountEntry Data.Int.Int64@ -}
data EstimateFeeRequest'AddrToAmountEntry
  = EstimateFeeRequest'AddrToAmountEntry'_constructor {_EstimateFeeRequest'AddrToAmountEntry'key :: !Data.Text.Text,
                                                       _EstimateFeeRequest'AddrToAmountEntry'value :: !Data.Int.Int64,
                                                       _EstimateFeeRequest'AddrToAmountEntry'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show EstimateFeeRequest'AddrToAmountEntry where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out EstimateFeeRequest'AddrToAmountEntry
instance Data.ProtoLens.Field.HasField EstimateFeeRequest'AddrToAmountEntry "key" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeRequest'AddrToAmountEntry'key
           (\ x__ y__
              -> x__ {_EstimateFeeRequest'AddrToAmountEntry'key = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField EstimateFeeRequest'AddrToAmountEntry "value" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeRequest'AddrToAmountEntry'value
           (\ x__ y__
              -> x__ {_EstimateFeeRequest'AddrToAmountEntry'value = y__}))
        Prelude.id
instance Data.ProtoLens.Message EstimateFeeRequest'AddrToAmountEntry where
  messageName _
    = Data.Text.pack "lnrpc.EstimateFeeRequest.AddrToAmountEntry"
  packedMessageDescriptor _
    = "\n\
      \\DC1AddrToAmountEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\tR\ETXkey\DC2\DC4\n\
      \\ENQvalue\CAN\STX \SOH(\ETXR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        key__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"key")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeRequest'AddrToAmountEntry
        value__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "value"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"value")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeRequest'AddrToAmountEntry
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, key__field_descriptor),
           (Data.ProtoLens.Tag 2, value__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _EstimateFeeRequest'AddrToAmountEntry'_unknownFields
        (\ x__ y__
           -> x__
                {_EstimateFeeRequest'AddrToAmountEntry'_unknownFields = y__})
  defMessage
    = EstimateFeeRequest'AddrToAmountEntry'_constructor
        {_EstimateFeeRequest'AddrToAmountEntry'key = Data.ProtoLens.fieldDefault,
         _EstimateFeeRequest'AddrToAmountEntry'value = Data.ProtoLens.fieldDefault,
         _EstimateFeeRequest'AddrToAmountEntry'_unknownFields = []}
  parseMessage
    = let
        loop ::
          EstimateFeeRequest'AddrToAmountEntry
          -> Data.ProtoLens.Encoding.Bytes.Parser EstimateFeeRequest'AddrToAmountEntry
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"key") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "value"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"value") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "AddrToAmountEntry"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"key") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"value") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData EstimateFeeRequest'AddrToAmountEntry where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_EstimateFeeRequest'AddrToAmountEntry'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_EstimateFeeRequest'AddrToAmountEntry'key x__)
                (Control.DeepSeq.deepseq
                   (_EstimateFeeRequest'AddrToAmountEntry'value x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.feeSat' @:: Lens' EstimateFeeResponse Data.Int.Int64@
         * 'Proto.Lightning_Fields.feerateSatPerByte' @:: Lens' EstimateFeeResponse Data.Int.Int64@
         * 'Proto.Lightning_Fields.satPerVbyte' @:: Lens' EstimateFeeResponse Data.Word.Word64@ -}
data EstimateFeeResponse
  = EstimateFeeResponse'_constructor {_EstimateFeeResponse'feeSat :: !Data.Int.Int64,
                                      _EstimateFeeResponse'feerateSatPerByte :: !Data.Int.Int64,
                                      _EstimateFeeResponse'satPerVbyte :: !Data.Word.Word64,
                                      _EstimateFeeResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show EstimateFeeResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out EstimateFeeResponse
instance Data.ProtoLens.Field.HasField EstimateFeeResponse "feeSat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeResponse'feeSat
           (\ x__ y__ -> x__ {_EstimateFeeResponse'feeSat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField EstimateFeeResponse "feerateSatPerByte" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeResponse'feerateSatPerByte
           (\ x__ y__ -> x__ {_EstimateFeeResponse'feerateSatPerByte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField EstimateFeeResponse "satPerVbyte" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _EstimateFeeResponse'satPerVbyte
           (\ x__ y__ -> x__ {_EstimateFeeResponse'satPerVbyte = y__}))
        Prelude.id
instance Data.ProtoLens.Message EstimateFeeResponse where
  messageName _ = Data.Text.pack "lnrpc.EstimateFeeResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC3EstimateFeeResponse\DC2\ETB\n\
      \\afee_sat\CAN\SOH \SOH(\ETXR\ACKfeeSat\DC23\n\
      \\DC4feerate_sat_per_byte\CAN\STX \SOH(\ETXR\DC1feerateSatPerByteB\STX\CAN\SOH\DC2\"\n\
      \\rsat_per_vbyte\CAN\ETX \SOH(\EOTR\vsatPerVbyte"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        feeSat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "fee_sat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"feeSat")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeResponse
        feerateSatPerByte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "feerate_sat_per_byte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"feerateSatPerByte")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeResponse
        satPerVbyte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_vbyte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerVbyte")) ::
              Data.ProtoLens.FieldDescriptor EstimateFeeResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, feeSat__field_descriptor),
           (Data.ProtoLens.Tag 2, feerateSatPerByte__field_descriptor),
           (Data.ProtoLens.Tag 3, satPerVbyte__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _EstimateFeeResponse'_unknownFields
        (\ x__ y__ -> x__ {_EstimateFeeResponse'_unknownFields = y__})
  defMessage
    = EstimateFeeResponse'_constructor
        {_EstimateFeeResponse'feeSat = Data.ProtoLens.fieldDefault,
         _EstimateFeeResponse'feerateSatPerByte = Data.ProtoLens.fieldDefault,
         _EstimateFeeResponse'satPerVbyte = Data.ProtoLens.fieldDefault,
         _EstimateFeeResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          EstimateFeeResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser EstimateFeeResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "fee_sat"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"feeSat") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "feerate_sat_per_byte"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"feerateSatPerByte") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "sat_per_vbyte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerVbyte") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "EstimateFeeResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"feeSat") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"feerateSatPerByte") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerVbyte") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData EstimateFeeResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_EstimateFeeResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_EstimateFeeResponse'feeSat x__)
                (Control.DeepSeq.deepseq
                   (_EstimateFeeResponse'feerateSatPerByte x__)
                   (Control.DeepSeq.deepseq
                      (_EstimateFeeResponse'satPerVbyte x__) ())))
{- | Fields :
      -}
data GetInfoRequest
  = GetInfoRequest'_constructor {_GetInfoRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show GetInfoRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out GetInfoRequest
instance Data.ProtoLens.Message GetInfoRequest where
  messageName _ = Data.Text.pack "lnrpc.GetInfoRequest"
  packedMessageDescriptor _
    = "\n\
      \\SOGetInfoRequest"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _GetInfoRequest'_unknownFields
        (\ x__ y__ -> x__ {_GetInfoRequest'_unknownFields = y__})
  defMessage
    = GetInfoRequest'_constructor {_GetInfoRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          GetInfoRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser GetInfoRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "GetInfoRequest"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData GetInfoRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq (_GetInfoRequest'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.version' @:: Lens' GetInfoResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.commitHash' @:: Lens' GetInfoResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.identityPubkey' @:: Lens' GetInfoResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.alias' @:: Lens' GetInfoResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.color' @:: Lens' GetInfoResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.numPendingChannels' @:: Lens' GetInfoResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.numActiveChannels' @:: Lens' GetInfoResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.numInactiveChannels' @:: Lens' GetInfoResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.numPeers' @:: Lens' GetInfoResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.blockHeight' @:: Lens' GetInfoResponse Data.Word.Word32@
         * 'Proto.Lightning_Fields.blockHash' @:: Lens' GetInfoResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.bestHeaderTimestamp' @:: Lens' GetInfoResponse Data.Int.Int64@
         * 'Proto.Lightning_Fields.syncedToChain' @:: Lens' GetInfoResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.syncedToGraph' @:: Lens' GetInfoResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.testnet' @:: Lens' GetInfoResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.chains' @:: Lens' GetInfoResponse [Chain]@
         * 'Proto.Lightning_Fields.vec'chains' @:: Lens' GetInfoResponse (Data.Vector.Vector Chain)@
         * 'Proto.Lightning_Fields.uris' @:: Lens' GetInfoResponse [Data.Text.Text]@
         * 'Proto.Lightning_Fields.vec'uris' @:: Lens' GetInfoResponse (Data.Vector.Vector Data.Text.Text)@
         * 'Proto.Lightning_Fields.features' @:: Lens' GetInfoResponse (Data.Map.Map Data.Word.Word32 Proto.Lnrpc.Ln0.Feature)@ -}
data GetInfoResponse
  = GetInfoResponse'_constructor {_GetInfoResponse'version :: !Data.Text.Text,
                                  _GetInfoResponse'commitHash :: !Data.Text.Text,
                                  _GetInfoResponse'identityPubkey :: !Data.Text.Text,
                                  _GetInfoResponse'alias :: !Data.Text.Text,
                                  _GetInfoResponse'color :: !Data.Text.Text,
                                  _GetInfoResponse'numPendingChannels :: !Data.Word.Word32,
                                  _GetInfoResponse'numActiveChannels :: !Data.Word.Word32,
                                  _GetInfoResponse'numInactiveChannels :: !Data.Word.Word32,
                                  _GetInfoResponse'numPeers :: !Data.Word.Word32,
                                  _GetInfoResponse'blockHeight :: !Data.Word.Word32,
                                  _GetInfoResponse'blockHash :: !Data.Text.Text,
                                  _GetInfoResponse'bestHeaderTimestamp :: !Data.Int.Int64,
                                  _GetInfoResponse'syncedToChain :: !Prelude.Bool,
                                  _GetInfoResponse'syncedToGraph :: !Prelude.Bool,
                                  _GetInfoResponse'testnet :: !Prelude.Bool,
                                  _GetInfoResponse'chains :: !(Data.Vector.Vector Chain),
                                  _GetInfoResponse'uris :: !(Data.Vector.Vector Data.Text.Text),
                                  _GetInfoResponse'features :: !(Data.Map.Map Data.Word.Word32 Proto.Lnrpc.Ln0.Feature),
                                  _GetInfoResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show GetInfoResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out GetInfoResponse
instance Data.ProtoLens.Field.HasField GetInfoResponse "version" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'version
           (\ x__ y__ -> x__ {_GetInfoResponse'version = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "commitHash" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'commitHash
           (\ x__ y__ -> x__ {_GetInfoResponse'commitHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "identityPubkey" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'identityPubkey
           (\ x__ y__ -> x__ {_GetInfoResponse'identityPubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "alias" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'alias
           (\ x__ y__ -> x__ {_GetInfoResponse'alias = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "color" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'color
           (\ x__ y__ -> x__ {_GetInfoResponse'color = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "numPendingChannels" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'numPendingChannels
           (\ x__ y__ -> x__ {_GetInfoResponse'numPendingChannels = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "numActiveChannels" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'numActiveChannels
           (\ x__ y__ -> x__ {_GetInfoResponse'numActiveChannels = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "numInactiveChannels" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'numInactiveChannels
           (\ x__ y__ -> x__ {_GetInfoResponse'numInactiveChannels = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "numPeers" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'numPeers
           (\ x__ y__ -> x__ {_GetInfoResponse'numPeers = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "blockHeight" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'blockHeight
           (\ x__ y__ -> x__ {_GetInfoResponse'blockHeight = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "blockHash" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'blockHash
           (\ x__ y__ -> x__ {_GetInfoResponse'blockHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "bestHeaderTimestamp" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'bestHeaderTimestamp
           (\ x__ y__ -> x__ {_GetInfoResponse'bestHeaderTimestamp = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "syncedToChain" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'syncedToChain
           (\ x__ y__ -> x__ {_GetInfoResponse'syncedToChain = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "syncedToGraph" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'syncedToGraph
           (\ x__ y__ -> x__ {_GetInfoResponse'syncedToGraph = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "testnet" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'testnet
           (\ x__ y__ -> x__ {_GetInfoResponse'testnet = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "chains" [Chain] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'chains
           (\ x__ y__ -> x__ {_GetInfoResponse'chains = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField GetInfoResponse "vec'chains" (Data.Vector.Vector Chain) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'chains
           (\ x__ y__ -> x__ {_GetInfoResponse'chains = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "uris" [Data.Text.Text] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'uris
           (\ x__ y__ -> x__ {_GetInfoResponse'uris = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField GetInfoResponse "vec'uris" (Data.Vector.Vector Data.Text.Text) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'uris
           (\ x__ y__ -> x__ {_GetInfoResponse'uris = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse "features" (Data.Map.Map Data.Word.Word32 Proto.Lnrpc.Ln0.Feature) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'features
           (\ x__ y__ -> x__ {_GetInfoResponse'features = y__}))
        Prelude.id
instance Data.ProtoLens.Message GetInfoResponse where
  messageName _ = Data.Text.pack "lnrpc.GetInfoResponse"
  packedMessageDescriptor _
    = "\n\
      \\SIGetInfoResponse\DC2\CAN\n\
      \\aversion\CAN\SO \SOH(\tR\aversion\DC2\US\n\
      \\vcommit_hash\CAN\DC4 \SOH(\tR\n\
      \commitHash\DC2'\n\
      \\SIidentity_pubkey\CAN\SOH \SOH(\tR\SOidentityPubkey\DC2\DC4\n\
      \\ENQalias\CAN\STX \SOH(\tR\ENQalias\DC2\DC4\n\
      \\ENQcolor\CAN\DC1 \SOH(\tR\ENQcolor\DC20\n\
      \\DC4num_pending_channels\CAN\ETX \SOH(\rR\DC2numPendingChannels\DC2.\n\
      \\DC3num_active_channels\CAN\EOT \SOH(\rR\DC1numActiveChannels\DC22\n\
      \\NAKnum_inactive_channels\CAN\SI \SOH(\rR\DC3numInactiveChannels\DC2\ESC\n\
      \\tnum_peers\CAN\ENQ \SOH(\rR\bnumPeers\DC2!\n\
      \\fblock_height\CAN\ACK \SOH(\rR\vblockHeight\DC2\GS\n\
      \\n\
      \block_hash\CAN\b \SOH(\tR\tblockHash\DC22\n\
      \\NAKbest_header_timestamp\CAN\r \SOH(\ETXR\DC3bestHeaderTimestamp\DC2&\n\
      \\SIsynced_to_chain\CAN\t \SOH(\bR\rsyncedToChain\DC2&\n\
      \\SIsynced_to_graph\CAN\DC2 \SOH(\bR\rsyncedToGraph\DC2\FS\n\
      \\atestnet\CAN\n\
      \ \SOH(\bR\atestnetB\STX\CAN\SOH\DC2$\n\
      \\ACKchains\CAN\DLE \ETX(\v2\f.lnrpc.ChainR\ACKchains\DC2\DC2\n\
      \\EOTuris\CAN\f \ETX(\tR\EOTuris\DC2@\n\
      \\bfeatures\CAN\DC3 \ETX(\v2$.lnrpc.GetInfoResponse.FeaturesEntryR\bfeatures\SUBK\n\
      \\rFeaturesEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\rR\ETXkey\DC2$\n\
      \\ENQvalue\CAN\STX \SOH(\v2\SO.lnrpc.FeatureR\ENQvalue:\STX8\SOHJ\EOT\b\v\DLE\f"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        version__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "version"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"version")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        commitHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "commit_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"commitHash")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        identityPubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "identity_pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"identityPubkey")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        alias__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "alias"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"alias")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        color__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "color"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"color")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        numPendingChannels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "num_pending_channels"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"numPendingChannels")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        numActiveChannels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "num_active_channels"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"numActiveChannels")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        numInactiveChannels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "num_inactive_channels"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"numInactiveChannels")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        numPeers__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "num_peers"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"numPeers")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        blockHeight__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "block_height"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"blockHeight")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        blockHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "block_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"blockHash")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        bestHeaderTimestamp__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "best_header_timestamp"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"bestHeaderTimestamp")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        syncedToChain__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "synced_to_chain"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"syncedToChain")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        syncedToGraph__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "synced_to_graph"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"syncedToGraph")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        testnet__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "testnet"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"testnet")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        chains__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "chains"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Chain)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked (Data.ProtoLens.Field.field @"chains")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        uris__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "uris"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked (Data.ProtoLens.Field.field @"uris")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
        features__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "features"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor GetInfoResponse'FeaturesEntry)
              (Data.ProtoLens.MapField
                 (Data.ProtoLens.Field.field @"key")
                 (Data.ProtoLens.Field.field @"value")
                 (Data.ProtoLens.Field.field @"features")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 14, version__field_descriptor),
           (Data.ProtoLens.Tag 20, commitHash__field_descriptor),
           (Data.ProtoLens.Tag 1, identityPubkey__field_descriptor),
           (Data.ProtoLens.Tag 2, alias__field_descriptor),
           (Data.ProtoLens.Tag 17, color__field_descriptor),
           (Data.ProtoLens.Tag 3, numPendingChannels__field_descriptor),
           (Data.ProtoLens.Tag 4, numActiveChannels__field_descriptor),
           (Data.ProtoLens.Tag 15, numInactiveChannels__field_descriptor),
           (Data.ProtoLens.Tag 5, numPeers__field_descriptor),
           (Data.ProtoLens.Tag 6, blockHeight__field_descriptor),
           (Data.ProtoLens.Tag 8, blockHash__field_descriptor),
           (Data.ProtoLens.Tag 13, bestHeaderTimestamp__field_descriptor),
           (Data.ProtoLens.Tag 9, syncedToChain__field_descriptor),
           (Data.ProtoLens.Tag 18, syncedToGraph__field_descriptor),
           (Data.ProtoLens.Tag 10, testnet__field_descriptor),
           (Data.ProtoLens.Tag 16, chains__field_descriptor),
           (Data.ProtoLens.Tag 12, uris__field_descriptor),
           (Data.ProtoLens.Tag 19, features__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _GetInfoResponse'_unknownFields
        (\ x__ y__ -> x__ {_GetInfoResponse'_unknownFields = y__})
  defMessage
    = GetInfoResponse'_constructor
        {_GetInfoResponse'version = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'commitHash = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'identityPubkey = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'alias = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'color = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'numPendingChannels = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'numActiveChannels = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'numInactiveChannels = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'numPeers = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'blockHeight = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'blockHash = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'bestHeaderTimestamp = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'syncedToChain = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'syncedToGraph = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'testnet = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'chains = Data.Vector.Generic.empty,
         _GetInfoResponse'uris = Data.Vector.Generic.empty,
         _GetInfoResponse'features = Data.Map.empty,
         _GetInfoResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          GetInfoResponse
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Chain
             -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Data.Text.Text
                -> Data.ProtoLens.Encoding.Bytes.Parser GetInfoResponse
        loop x mutable'chains mutable'uris
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'chains <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                         (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                            mutable'chains)
                      frozen'uris <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.unsafeFreeze mutable'uris)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'chains") frozen'chains
                              (Lens.Family2.set
                                 (Data.ProtoLens.Field.field @"vec'uris") frozen'uris x)))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        114
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "version"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"version") y x)
                                  mutable'chains mutable'uris
                        162
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "commit_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"commitHash") y x)
                                  mutable'chains mutable'uris
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "identity_pubkey"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"identityPubkey") y x)
                                  mutable'chains mutable'uris
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "alias"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"alias") y x)
                                  mutable'chains mutable'uris
                        138
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "color"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"color") y x)
                                  mutable'chains mutable'uris
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "num_pending_channels"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"numPendingChannels") y x)
                                  mutable'chains mutable'uris
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "num_active_channels"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"numActiveChannels") y x)
                                  mutable'chains mutable'uris
                        120
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "num_inactive_channels"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"numInactiveChannels") y x)
                                  mutable'chains mutable'uris
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "num_peers"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"numPeers") y x)
                                  mutable'chains mutable'uris
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "block_height"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"blockHeight") y x)
                                  mutable'chains mutable'uris
                        66
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "block_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"blockHash") y x)
                                  mutable'chains mutable'uris
                        104
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "best_header_timestamp"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"bestHeaderTimestamp") y x)
                                  mutable'chains mutable'uris
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "synced_to_chain"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"syncedToChain") y x)
                                  mutable'chains mutable'uris
                        144
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "synced_to_graph"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"syncedToGraph") y x)
                                  mutable'chains mutable'uris
                        80
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "testnet"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"testnet") y x)
                                  mutable'chains mutable'uris
                        130
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "chains"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'chains y)
                                loop x v mutable'uris
                        98
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                        Data.ProtoLens.Encoding.Bytes.getBytes
                                                          (Prelude.fromIntegral len)
                                            Data.ProtoLens.Encoding.Bytes.runEither
                                              (case Data.Text.Encoding.decodeUtf8' value of
                                                 (Prelude.Left err)
                                                   -> Prelude.Left (Prelude.show err)
                                                 (Prelude.Right r) -> Prelude.Right r))
                                        "uris"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'uris y)
                                loop x mutable'chains v
                        154
                          -> do !(entry :: GetInfoResponse'FeaturesEntry) <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                                                               (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                                                   Data.ProtoLens.Encoding.Bytes.isolate
                                                                                     (Prelude.fromIntegral
                                                                                        len)
                                                                                     Data.ProtoLens.parseMessage)
                                                                               "features"
                                (let
                                   key = Lens.Family2.view (Data.ProtoLens.Field.field @"key") entry
                                   value
                                     = Lens.Family2.view (Data.ProtoLens.Field.field @"value") entry
                                 in
                                   loop
                                     (Lens.Family2.over
                                        (Data.ProtoLens.Field.field @"features")
                                        (\ !t -> Data.Map.insert key value t) x)
                                     mutable'chains mutable'uris)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'chains mutable'uris
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'chains <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                  Data.ProtoLens.Encoding.Growing.new
              mutable'uris <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'chains mutable'uris)
          "GetInfoResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"version") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 114)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"commitHash") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 162)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view
                            (Data.ProtoLens.Field.field @"identityPubkey") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                            ((Prelude..)
                               (\ bs
                                  -> (Data.Monoid.<>)
                                       (Data.ProtoLens.Encoding.Bytes.putVarInt
                                          (Prelude.fromIntegral (Data.ByteString.length bs)))
                                       (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               Data.Text.Encoding.encodeUtf8 _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"alias") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                               ((Prelude..)
                                  (\ bs
                                     -> (Data.Monoid.<>)
                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                             (Prelude.fromIntegral (Data.ByteString.length bs)))
                                          (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                  Data.Text.Encoding.encodeUtf8 _v))
                      ((Data.Monoid.<>)
                         (let
                            _v = Lens.Family2.view (Data.ProtoLens.Field.field @"color") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 138)
                                  ((Prelude..)
                                     (\ bs
                                        -> (Data.Monoid.<>)
                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                (Prelude.fromIntegral (Data.ByteString.length bs)))
                                             (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                     Data.Text.Encoding.encodeUtf8 _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view
                                     (Data.ProtoLens.Field.field @"numPendingChannels") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"numActiveChannels") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                                        ((Prelude..)
                                           Data.ProtoLens.Encoding.Bytes.putVarInt
                                           Prelude.fromIntegral _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"numInactiveChannels") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 120)
                                           ((Prelude..)
                                              Data.ProtoLens.Encoding.Bytes.putVarInt
                                              Prelude.fromIntegral _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"numPeers") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                              ((Prelude..)
                                                 Data.ProtoLens.Encoding.Bytes.putVarInt
                                                 Prelude.fromIntegral _v))
                                     ((Data.Monoid.<>)
                                        (let
                                           _v
                                             = Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"blockHeight") _x
                                         in
                                           if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                               Data.Monoid.mempty
                                           else
                                               (Data.Monoid.<>)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                                 ((Prelude..)
                                                    Data.ProtoLens.Encoding.Bytes.putVarInt
                                                    Prelude.fromIntegral _v))
                                        ((Data.Monoid.<>)
                                           (let
                                              _v
                                                = Lens.Family2.view
                                                    (Data.ProtoLens.Field.field @"blockHash") _x
                                            in
                                              if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                  Data.Monoid.mempty
                                              else
                                                  (Data.Monoid.<>)
                                                    (Data.ProtoLens.Encoding.Bytes.putVarInt 66)
                                                    ((Prelude..)
                                                       (\ bs
                                                          -> (Data.Monoid.<>)
                                                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                  (Prelude.fromIntegral
                                                                     (Data.ByteString.length bs)))
                                                               (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                  bs))
                                                       Data.Text.Encoding.encodeUtf8 _v))
                                           ((Data.Monoid.<>)
                                              (let
                                                 _v
                                                   = Lens.Family2.view
                                                       (Data.ProtoLens.Field.field
                                                          @"bestHeaderTimestamp")
                                                       _x
                                               in
                                                 if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                     Data.Monoid.mempty
                                                 else
                                                     (Data.Monoid.<>)
                                                       (Data.ProtoLens.Encoding.Bytes.putVarInt 104)
                                                       ((Prelude..)
                                                          Data.ProtoLens.Encoding.Bytes.putVarInt
                                                          Prelude.fromIntegral _v))
                                              ((Data.Monoid.<>)
                                                 (let
                                                    _v
                                                      = Lens.Family2.view
                                                          (Data.ProtoLens.Field.field
                                                             @"syncedToChain")
                                                          _x
                                                  in
                                                    if (Prelude.==)
                                                         _v Data.ProtoLens.fieldDefault then
                                                        Data.Monoid.mempty
                                                    else
                                                        (Data.Monoid.<>)
                                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             72)
                                                          ((Prelude..)
                                                             Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             (\ b -> if b then 1 else 0) _v))
                                                 ((Data.Monoid.<>)
                                                    (let
                                                       _v
                                                         = Lens.Family2.view
                                                             (Data.ProtoLens.Field.field
                                                                @"syncedToGraph")
                                                             _x
                                                     in
                                                       if (Prelude.==)
                                                            _v Data.ProtoLens.fieldDefault then
                                                           Data.Monoid.mempty
                                                       else
                                                           (Data.Monoid.<>)
                                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                144)
                                                             ((Prelude..)
                                                                Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                (\ b -> if b then 1 else 0) _v))
                                                    ((Data.Monoid.<>)
                                                       (let
                                                          _v
                                                            = Lens.Family2.view
                                                                (Data.ProtoLens.Field.field
                                                                   @"testnet")
                                                                _x
                                                        in
                                                          if (Prelude.==)
                                                               _v Data.ProtoLens.fieldDefault then
                                                              Data.Monoid.mempty
                                                          else
                                                              (Data.Monoid.<>)
                                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                   80)
                                                                ((Prelude..)
                                                                   Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                   (\ b -> if b then 1 else 0) _v))
                                                       ((Data.Monoid.<>)
                                                          (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                                                             (\ _v
                                                                -> (Data.Monoid.<>)
                                                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                        130)
                                                                     ((Prelude..)
                                                                        (\ bs
                                                                           -> (Data.Monoid.<>)
                                                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                                   (Prelude.fromIntegral
                                                                                      (Data.ByteString.length
                                                                                         bs)))
                                                                                (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                                   bs))
                                                                        Data.ProtoLens.encodeMessage
                                                                        _v))
                                                             (Lens.Family2.view
                                                                (Data.ProtoLens.Field.field
                                                                   @"vec'chains")
                                                                _x))
                                                          ((Data.Monoid.<>)
                                                             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                                                                (\ _v
                                                                   -> (Data.Monoid.<>)
                                                                        (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                           98)
                                                                        ((Prelude..)
                                                                           (\ bs
                                                                              -> (Data.Monoid.<>)
                                                                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                                      (Prelude.fromIntegral
                                                                                         (Data.ByteString.length
                                                                                            bs)))
                                                                                   (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                                      bs))
                                                                           Data.Text.Encoding.encodeUtf8
                                                                           _v))
                                                                (Lens.Family2.view
                                                                   (Data.ProtoLens.Field.field
                                                                      @"vec'uris")
                                                                   _x))
                                                             ((Data.Monoid.<>)
                                                                (Data.Monoid.mconcat
                                                                   (Prelude.map
                                                                      (\ _v
                                                                         -> (Data.Monoid.<>)
                                                                              (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                                 154)
                                                                              ((Prelude..)
                                                                                 (\ bs
                                                                                    -> (Data.Monoid.<>)
                                                                                         (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                                            (Prelude.fromIntegral
                                                                                               (Data.ByteString.length
                                                                                                  bs)))
                                                                                         (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                                            bs))
                                                                                 Data.ProtoLens.encodeMessage
                                                                                 (Lens.Family2.set
                                                                                    (Data.ProtoLens.Field.field
                                                                                       @"key")
                                                                                    (Prelude.fst _v)
                                                                                    (Lens.Family2.set
                                                                                       (Data.ProtoLens.Field.field
                                                                                          @"value")
                                                                                       (Prelude.snd
                                                                                          _v)
                                                                                       (Data.ProtoLens.defMessage ::
                                                                                          GetInfoResponse'FeaturesEntry)))))
                                                                      (Data.Map.toList
                                                                         (Lens.Family2.view
                                                                            (Data.ProtoLens.Field.field
                                                                               @"features")
                                                                            _x))))
                                                                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                                                   (Lens.Family2.view
                                                                      Data.ProtoLens.unknownFields
                                                                      _x)))))))))))))))))))
instance Control.DeepSeq.NFData GetInfoResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_GetInfoResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_GetInfoResponse'version x__)
                (Control.DeepSeq.deepseq
                   (_GetInfoResponse'commitHash x__)
                   (Control.DeepSeq.deepseq
                      (_GetInfoResponse'identityPubkey x__)
                      (Control.DeepSeq.deepseq
                         (_GetInfoResponse'alias x__)
                         (Control.DeepSeq.deepseq
                            (_GetInfoResponse'color x__)
                            (Control.DeepSeq.deepseq
                               (_GetInfoResponse'numPendingChannels x__)
                               (Control.DeepSeq.deepseq
                                  (_GetInfoResponse'numActiveChannels x__)
                                  (Control.DeepSeq.deepseq
                                     (_GetInfoResponse'numInactiveChannels x__)
                                     (Control.DeepSeq.deepseq
                                        (_GetInfoResponse'numPeers x__)
                                        (Control.DeepSeq.deepseq
                                           (_GetInfoResponse'blockHeight x__)
                                           (Control.DeepSeq.deepseq
                                              (_GetInfoResponse'blockHash x__)
                                              (Control.DeepSeq.deepseq
                                                 (_GetInfoResponse'bestHeaderTimestamp x__)
                                                 (Control.DeepSeq.deepseq
                                                    (_GetInfoResponse'syncedToChain x__)
                                                    (Control.DeepSeq.deepseq
                                                       (_GetInfoResponse'syncedToGraph x__)
                                                       (Control.DeepSeq.deepseq
                                                          (_GetInfoResponse'testnet x__)
                                                          (Control.DeepSeq.deepseq
                                                             (_GetInfoResponse'chains x__)
                                                             (Control.DeepSeq.deepseq
                                                                (_GetInfoResponse'uris x__)
                                                                (Control.DeepSeq.deepseq
                                                                   (_GetInfoResponse'features x__)
                                                                   ()))))))))))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.key' @:: Lens' GetInfoResponse'FeaturesEntry Data.Word.Word32@
         * 'Proto.Lightning_Fields.value' @:: Lens' GetInfoResponse'FeaturesEntry Proto.Lnrpc.Ln0.Feature@
         * 'Proto.Lightning_Fields.maybe'value' @:: Lens' GetInfoResponse'FeaturesEntry (Prelude.Maybe Proto.Lnrpc.Ln0.Feature)@ -}
data GetInfoResponse'FeaturesEntry
  = GetInfoResponse'FeaturesEntry'_constructor {_GetInfoResponse'FeaturesEntry'key :: !Data.Word.Word32,
                                                _GetInfoResponse'FeaturesEntry'value :: !(Prelude.Maybe Proto.Lnrpc.Ln0.Feature),
                                                _GetInfoResponse'FeaturesEntry'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show GetInfoResponse'FeaturesEntry where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out GetInfoResponse'FeaturesEntry
instance Data.ProtoLens.Field.HasField GetInfoResponse'FeaturesEntry "key" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'FeaturesEntry'key
           (\ x__ y__ -> x__ {_GetInfoResponse'FeaturesEntry'key = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetInfoResponse'FeaturesEntry "value" Proto.Lnrpc.Ln0.Feature where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'FeaturesEntry'value
           (\ x__ y__ -> x__ {_GetInfoResponse'FeaturesEntry'value = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField GetInfoResponse'FeaturesEntry "maybe'value" (Prelude.Maybe Proto.Lnrpc.Ln0.Feature) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetInfoResponse'FeaturesEntry'value
           (\ x__ y__ -> x__ {_GetInfoResponse'FeaturesEntry'value = y__}))
        Prelude.id
instance Data.ProtoLens.Message GetInfoResponse'FeaturesEntry where
  messageName _
    = Data.Text.pack "lnrpc.GetInfoResponse.FeaturesEntry"
  packedMessageDescriptor _
    = "\n\
      \\rFeaturesEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\rR\ETXkey\DC2$\n\
      \\ENQvalue\CAN\STX \SOH(\v2\SO.lnrpc.FeatureR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        key__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"key")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse'FeaturesEntry
        value__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "value"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.Feature)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'value")) ::
              Data.ProtoLens.FieldDescriptor GetInfoResponse'FeaturesEntry
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, key__field_descriptor),
           (Data.ProtoLens.Tag 2, value__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _GetInfoResponse'FeaturesEntry'_unknownFields
        (\ x__ y__
           -> x__ {_GetInfoResponse'FeaturesEntry'_unknownFields = y__})
  defMessage
    = GetInfoResponse'FeaturesEntry'_constructor
        {_GetInfoResponse'FeaturesEntry'key = Data.ProtoLens.fieldDefault,
         _GetInfoResponse'FeaturesEntry'value = Prelude.Nothing,
         _GetInfoResponse'FeaturesEntry'_unknownFields = []}
  parseMessage
    = let
        loop ::
          GetInfoResponse'FeaturesEntry
          -> Data.ProtoLens.Encoding.Bytes.Parser GetInfoResponse'FeaturesEntry
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"key") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "value"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"value") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "FeaturesEntry"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"key") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
             ((Data.Monoid.<>)
                (case
                     Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'value") _x
                 of
                   Prelude.Nothing -> Data.Monoid.mempty
                   (Prelude.Just _v)
                     -> (Data.Monoid.<>)
                          (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                          ((Prelude..)
                             (\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                             Data.ProtoLens.encodeMessage _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData GetInfoResponse'FeaturesEntry where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_GetInfoResponse'FeaturesEntry'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_GetInfoResponse'FeaturesEntry'key x__)
                (Control.DeepSeq.deepseq
                   (_GetInfoResponse'FeaturesEntry'value x__) ()))
{- | Fields :
      -}
data GetRecoveryInfoRequest
  = GetRecoveryInfoRequest'_constructor {_GetRecoveryInfoRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show GetRecoveryInfoRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out GetRecoveryInfoRequest
instance Data.ProtoLens.Message GetRecoveryInfoRequest where
  messageName _ = Data.Text.pack "lnrpc.GetRecoveryInfoRequest"
  packedMessageDescriptor _
    = "\n\
      \\SYNGetRecoveryInfoRequest"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _GetRecoveryInfoRequest'_unknownFields
        (\ x__ y__ -> x__ {_GetRecoveryInfoRequest'_unknownFields = y__})
  defMessage
    = GetRecoveryInfoRequest'_constructor
        {_GetRecoveryInfoRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          GetRecoveryInfoRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser GetRecoveryInfoRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "GetRecoveryInfoRequest"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData GetRecoveryInfoRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_GetRecoveryInfoRequest'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.recoveryMode' @:: Lens' GetRecoveryInfoResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.recoveryFinished' @:: Lens' GetRecoveryInfoResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.progress' @:: Lens' GetRecoveryInfoResponse Prelude.Double@ -}
data GetRecoveryInfoResponse
  = GetRecoveryInfoResponse'_constructor {_GetRecoveryInfoResponse'recoveryMode :: !Prelude.Bool,
                                          _GetRecoveryInfoResponse'recoveryFinished :: !Prelude.Bool,
                                          _GetRecoveryInfoResponse'progress :: !Prelude.Double,
                                          _GetRecoveryInfoResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show GetRecoveryInfoResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out GetRecoveryInfoResponse
instance Data.ProtoLens.Field.HasField GetRecoveryInfoResponse "recoveryMode" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetRecoveryInfoResponse'recoveryMode
           (\ x__ y__ -> x__ {_GetRecoveryInfoResponse'recoveryMode = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetRecoveryInfoResponse "recoveryFinished" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetRecoveryInfoResponse'recoveryFinished
           (\ x__ y__
              -> x__ {_GetRecoveryInfoResponse'recoveryFinished = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetRecoveryInfoResponse "progress" Prelude.Double where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetRecoveryInfoResponse'progress
           (\ x__ y__ -> x__ {_GetRecoveryInfoResponse'progress = y__}))
        Prelude.id
instance Data.ProtoLens.Message GetRecoveryInfoResponse where
  messageName _ = Data.Text.pack "lnrpc.GetRecoveryInfoResponse"
  packedMessageDescriptor _
    = "\n\
      \\ETBGetRecoveryInfoResponse\DC2#\n\
      \\rrecovery_mode\CAN\SOH \SOH(\bR\frecoveryMode\DC2+\n\
      \\DC1recovery_finished\CAN\STX \SOH(\bR\DLErecoveryFinished\DC2\SUB\n\
      \\bprogress\CAN\ETX \SOH(\SOHR\bprogress"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        recoveryMode__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "recovery_mode"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"recoveryMode")) ::
              Data.ProtoLens.FieldDescriptor GetRecoveryInfoResponse
        recoveryFinished__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "recovery_finished"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"recoveryFinished")) ::
              Data.ProtoLens.FieldDescriptor GetRecoveryInfoResponse
        progress__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "progress"
              (Data.ProtoLens.ScalarField Data.ProtoLens.DoubleField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Double)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"progress")) ::
              Data.ProtoLens.FieldDescriptor GetRecoveryInfoResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, recoveryMode__field_descriptor),
           (Data.ProtoLens.Tag 2, recoveryFinished__field_descriptor),
           (Data.ProtoLens.Tag 3, progress__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _GetRecoveryInfoResponse'_unknownFields
        (\ x__ y__ -> x__ {_GetRecoveryInfoResponse'_unknownFields = y__})
  defMessage
    = GetRecoveryInfoResponse'_constructor
        {_GetRecoveryInfoResponse'recoveryMode = Data.ProtoLens.fieldDefault,
         _GetRecoveryInfoResponse'recoveryFinished = Data.ProtoLens.fieldDefault,
         _GetRecoveryInfoResponse'progress = Data.ProtoLens.fieldDefault,
         _GetRecoveryInfoResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          GetRecoveryInfoResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser GetRecoveryInfoResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "recovery_mode"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"recoveryMode") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "recovery_finished"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"recoveryFinished") y x)
                        25
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Data.ProtoLens.Encoding.Bytes.wordToDouble
                                          Data.ProtoLens.Encoding.Bytes.getFixed64)
                                       "progress"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"progress") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "GetRecoveryInfoResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"recoveryMode") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"recoveryFinished") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"progress") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 25)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putFixed64
                               Data.ProtoLens.Encoding.Bytes.doubleToWord _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData GetRecoveryInfoResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_GetRecoveryInfoResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_GetRecoveryInfoResponse'recoveryMode x__)
                (Control.DeepSeq.deepseq
                   (_GetRecoveryInfoResponse'recoveryFinished x__)
                   (Control.DeepSeq.deepseq
                      (_GetRecoveryInfoResponse'progress x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.startHeight' @:: Lens' GetTransactionsRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.endHeight' @:: Lens' GetTransactionsRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.account' @:: Lens' GetTransactionsRequest Data.Text.Text@ -}
data GetTransactionsRequest
  = GetTransactionsRequest'_constructor {_GetTransactionsRequest'startHeight :: !Data.Int.Int32,
                                         _GetTransactionsRequest'endHeight :: !Data.Int.Int32,
                                         _GetTransactionsRequest'account :: !Data.Text.Text,
                                         _GetTransactionsRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show GetTransactionsRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out GetTransactionsRequest
instance Data.ProtoLens.Field.HasField GetTransactionsRequest "startHeight" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetTransactionsRequest'startHeight
           (\ x__ y__ -> x__ {_GetTransactionsRequest'startHeight = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetTransactionsRequest "endHeight" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetTransactionsRequest'endHeight
           (\ x__ y__ -> x__ {_GetTransactionsRequest'endHeight = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField GetTransactionsRequest "account" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _GetTransactionsRequest'account
           (\ x__ y__ -> x__ {_GetTransactionsRequest'account = y__}))
        Prelude.id
instance Data.ProtoLens.Message GetTransactionsRequest where
  messageName _ = Data.Text.pack "lnrpc.GetTransactionsRequest"
  packedMessageDescriptor _
    = "\n\
      \\SYNGetTransactionsRequest\DC2!\n\
      \\fstart_height\CAN\SOH \SOH(\ENQR\vstartHeight\DC2\GS\n\
      \\n\
      \end_height\CAN\STX \SOH(\ENQR\tendHeight\DC2\CAN\n\
      \\aaccount\CAN\ETX \SOH(\tR\aaccount"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        startHeight__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "start_height"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"startHeight")) ::
              Data.ProtoLens.FieldDescriptor GetTransactionsRequest
        endHeight__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "end_height"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"endHeight")) ::
              Data.ProtoLens.FieldDescriptor GetTransactionsRequest
        account__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "account"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"account")) ::
              Data.ProtoLens.FieldDescriptor GetTransactionsRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, startHeight__field_descriptor),
           (Data.ProtoLens.Tag 2, endHeight__field_descriptor),
           (Data.ProtoLens.Tag 3, account__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _GetTransactionsRequest'_unknownFields
        (\ x__ y__ -> x__ {_GetTransactionsRequest'_unknownFields = y__})
  defMessage
    = GetTransactionsRequest'_constructor
        {_GetTransactionsRequest'startHeight = Data.ProtoLens.fieldDefault,
         _GetTransactionsRequest'endHeight = Data.ProtoLens.fieldDefault,
         _GetTransactionsRequest'account = Data.ProtoLens.fieldDefault,
         _GetTransactionsRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          GetTransactionsRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser GetTransactionsRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "start_height"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"startHeight") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "end_height"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"endHeight") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "account"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"account") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "GetTransactionsRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"startHeight") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"endHeight") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"account") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((Prelude..)
                               (\ bs
                                  -> (Data.Monoid.<>)
                                       (Data.ProtoLens.Encoding.Bytes.putVarInt
                                          (Prelude.fromIntegral (Data.ByteString.length bs)))
                                       (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               Data.Text.Encoding.encodeUtf8 _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData GetTransactionsRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_GetTransactionsRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_GetTransactionsRequest'startHeight x__)
                (Control.DeepSeq.deepseq
                   (_GetTransactionsRequest'endHeight x__)
                   (Control.DeepSeq.deepseq
                      (_GetTransactionsRequest'account x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.pubkey' @:: Lens' LightningAddress Data.Text.Text@
         * 'Proto.Lightning_Fields.host' @:: Lens' LightningAddress Data.Text.Text@ -}
data LightningAddress
  = LightningAddress'_constructor {_LightningAddress'pubkey :: !Data.Text.Text,
                                   _LightningAddress'host :: !Data.Text.Text,
                                   _LightningAddress'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show LightningAddress where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out LightningAddress
instance Data.ProtoLens.Field.HasField LightningAddress "pubkey" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _LightningAddress'pubkey
           (\ x__ y__ -> x__ {_LightningAddress'pubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField LightningAddress "host" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _LightningAddress'host
           (\ x__ y__ -> x__ {_LightningAddress'host = y__}))
        Prelude.id
instance Data.ProtoLens.Message LightningAddress where
  messageName _ = Data.Text.pack "lnrpc.LightningAddress"
  packedMessageDescriptor _
    = "\n\
      \\DLELightningAddress\DC2\SYN\n\
      \\ACKpubkey\CAN\SOH \SOH(\tR\ACKpubkey\DC2\DC2\n\
      \\EOThost\CAN\STX \SOH(\tR\EOThost"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        pubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pubkey")) ::
              Data.ProtoLens.FieldDescriptor LightningAddress
        host__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "host"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"host")) ::
              Data.ProtoLens.FieldDescriptor LightningAddress
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, pubkey__field_descriptor),
           (Data.ProtoLens.Tag 2, host__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _LightningAddress'_unknownFields
        (\ x__ y__ -> x__ {_LightningAddress'_unknownFields = y__})
  defMessage
    = LightningAddress'_constructor
        {_LightningAddress'pubkey = Data.ProtoLens.fieldDefault,
         _LightningAddress'host = Data.ProtoLens.fieldDefault,
         _LightningAddress'_unknownFields = []}
  parseMessage
    = let
        loop ::
          LightningAddress
          -> Data.ProtoLens.Encoding.Bytes.Parser LightningAddress
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "pubkey"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pubkey") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "host"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"host") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "LightningAddress"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pubkey") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"host") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData LightningAddress where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_LightningAddress'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_LightningAddress'pubkey x__)
                (Control.DeepSeq.deepseq (_LightningAddress'host x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.activeOnly' @:: Lens' ListChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.inactiveOnly' @:: Lens' ListChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.publicOnly' @:: Lens' ListChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.privateOnly' @:: Lens' ListChannelsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.peer' @:: Lens' ListChannelsRequest Data.ByteString.ByteString@ -}
data ListChannelsRequest
  = ListChannelsRequest'_constructor {_ListChannelsRequest'activeOnly :: !Prelude.Bool,
                                      _ListChannelsRequest'inactiveOnly :: !Prelude.Bool,
                                      _ListChannelsRequest'publicOnly :: !Prelude.Bool,
                                      _ListChannelsRequest'privateOnly :: !Prelude.Bool,
                                      _ListChannelsRequest'peer :: !Data.ByteString.ByteString,
                                      _ListChannelsRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ListChannelsRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ListChannelsRequest
instance Data.ProtoLens.Field.HasField ListChannelsRequest "activeOnly" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsRequest'activeOnly
           (\ x__ y__ -> x__ {_ListChannelsRequest'activeOnly = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ListChannelsRequest "inactiveOnly" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsRequest'inactiveOnly
           (\ x__ y__ -> x__ {_ListChannelsRequest'inactiveOnly = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ListChannelsRequest "publicOnly" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsRequest'publicOnly
           (\ x__ y__ -> x__ {_ListChannelsRequest'publicOnly = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ListChannelsRequest "privateOnly" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsRequest'privateOnly
           (\ x__ y__ -> x__ {_ListChannelsRequest'privateOnly = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ListChannelsRequest "peer" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsRequest'peer
           (\ x__ y__ -> x__ {_ListChannelsRequest'peer = y__}))
        Prelude.id
instance Data.ProtoLens.Message ListChannelsRequest where
  messageName _ = Data.Text.pack "lnrpc.ListChannelsRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC3ListChannelsRequest\DC2\US\n\
      \\vactive_only\CAN\SOH \SOH(\bR\n\
      \activeOnly\DC2#\n\
      \\rinactive_only\CAN\STX \SOH(\bR\finactiveOnly\DC2\US\n\
      \\vpublic_only\CAN\ETX \SOH(\bR\n\
      \publicOnly\DC2!\n\
      \\fprivate_only\CAN\EOT \SOH(\bR\vprivateOnly\DC2\DC2\n\
      \\EOTpeer\CAN\ENQ \SOH(\fR\EOTpeer"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        activeOnly__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "active_only"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"activeOnly")) ::
              Data.ProtoLens.FieldDescriptor ListChannelsRequest
        inactiveOnly__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "inactive_only"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"inactiveOnly")) ::
              Data.ProtoLens.FieldDescriptor ListChannelsRequest
        publicOnly__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "public_only"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"publicOnly")) ::
              Data.ProtoLens.FieldDescriptor ListChannelsRequest
        privateOnly__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "private_only"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"privateOnly")) ::
              Data.ProtoLens.FieldDescriptor ListChannelsRequest
        peer__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "peer"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"peer")) ::
              Data.ProtoLens.FieldDescriptor ListChannelsRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, activeOnly__field_descriptor),
           (Data.ProtoLens.Tag 2, inactiveOnly__field_descriptor),
           (Data.ProtoLens.Tag 3, publicOnly__field_descriptor),
           (Data.ProtoLens.Tag 4, privateOnly__field_descriptor),
           (Data.ProtoLens.Tag 5, peer__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ListChannelsRequest'_unknownFields
        (\ x__ y__ -> x__ {_ListChannelsRequest'_unknownFields = y__})
  defMessage
    = ListChannelsRequest'_constructor
        {_ListChannelsRequest'activeOnly = Data.ProtoLens.fieldDefault,
         _ListChannelsRequest'inactiveOnly = Data.ProtoLens.fieldDefault,
         _ListChannelsRequest'publicOnly = Data.ProtoLens.fieldDefault,
         _ListChannelsRequest'privateOnly = Data.ProtoLens.fieldDefault,
         _ListChannelsRequest'peer = Data.ProtoLens.fieldDefault,
         _ListChannelsRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ListChannelsRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser ListChannelsRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "active_only"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"activeOnly") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "inactive_only"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"inactiveOnly") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "public_only"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"publicOnly") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "private_only"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"privateOnly") y x)
                        42
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "peer"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"peer") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ListChannelsRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"activeOnly") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"inactiveOnly") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"publicOnly") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                               _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view (Data.ProtoLens.Field.field @"privateOnly") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (\ b -> if b then 1 else 0) _v))
                      ((Data.Monoid.<>)
                         (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"peer") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 42)
                                  ((\ bs
                                      -> (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt
                                              (Prelude.fromIntegral (Data.ByteString.length bs)))
                                           (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                     _v))
                         (Data.ProtoLens.Encoding.Wire.buildFieldSet
                            (Lens.Family2.view Data.ProtoLens.unknownFields _x))))))
instance Control.DeepSeq.NFData ListChannelsRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ListChannelsRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ListChannelsRequest'activeOnly x__)
                (Control.DeepSeq.deepseq
                   (_ListChannelsRequest'inactiveOnly x__)
                   (Control.DeepSeq.deepseq
                      (_ListChannelsRequest'publicOnly x__)
                      (Control.DeepSeq.deepseq
                         (_ListChannelsRequest'privateOnly x__)
                         (Control.DeepSeq.deepseq (_ListChannelsRequest'peer x__) ())))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.channels' @:: Lens' ListChannelsResponse [Proto.Lnrpc.Ln0.Channel]@
         * 'Proto.Lightning_Fields.vec'channels' @:: Lens' ListChannelsResponse (Data.Vector.Vector Proto.Lnrpc.Ln0.Channel)@ -}
data ListChannelsResponse
  = ListChannelsResponse'_constructor {_ListChannelsResponse'channels :: !(Data.Vector.Vector Proto.Lnrpc.Ln0.Channel),
                                       _ListChannelsResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ListChannelsResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ListChannelsResponse
instance Data.ProtoLens.Field.HasField ListChannelsResponse "channels" [Proto.Lnrpc.Ln0.Channel] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsResponse'channels
           (\ x__ y__ -> x__ {_ListChannelsResponse'channels = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField ListChannelsResponse "vec'channels" (Data.Vector.Vector Proto.Lnrpc.Ln0.Channel) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListChannelsResponse'channels
           (\ x__ y__ -> x__ {_ListChannelsResponse'channels = y__}))
        Prelude.id
instance Data.ProtoLens.Message ListChannelsResponse where
  messageName _ = Data.Text.pack "lnrpc.ListChannelsResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC4ListChannelsResponse\DC2*\n\
      \\bchannels\CAN\v \ETX(\v2\SO.lnrpc.ChannelR\bchannels"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        channels__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "channels"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.Channel)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked
                 (Data.ProtoLens.Field.field @"channels")) ::
              Data.ProtoLens.FieldDescriptor ListChannelsResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 11, channels__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ListChannelsResponse'_unknownFields
        (\ x__ y__ -> x__ {_ListChannelsResponse'_unknownFields = y__})
  defMessage
    = ListChannelsResponse'_constructor
        {_ListChannelsResponse'channels = Data.Vector.Generic.empty,
         _ListChannelsResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ListChannelsResponse
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Proto.Lnrpc.Ln0.Channel
             -> Data.ProtoLens.Encoding.Bytes.Parser ListChannelsResponse
        loop x mutable'channels
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'channels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                           (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                              mutable'channels)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'channels") frozen'channels x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        90
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "channels"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'channels y)
                                loop x v
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'channels
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'channels <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                    Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'channels)
          "ListChannelsResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 90)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view
                   (Data.ProtoLens.Field.field @"vec'channels") _x))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData ListChannelsResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ListChannelsResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_ListChannelsResponse'channels x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.latestError' @:: Lens' ListPeersRequest Prelude.Bool@ -}
data ListPeersRequest
  = ListPeersRequest'_constructor {_ListPeersRequest'latestError :: !Prelude.Bool,
                                   _ListPeersRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ListPeersRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ListPeersRequest
instance Data.ProtoLens.Field.HasField ListPeersRequest "latestError" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListPeersRequest'latestError
           (\ x__ y__ -> x__ {_ListPeersRequest'latestError = y__}))
        Prelude.id
instance Data.ProtoLens.Message ListPeersRequest where
  messageName _ = Data.Text.pack "lnrpc.ListPeersRequest"
  packedMessageDescriptor _
    = "\n\
      \\DLEListPeersRequest\DC2!\n\
      \\flatest_error\CAN\SOH \SOH(\bR\vlatestError"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        latestError__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "latest_error"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"latestError")) ::
              Data.ProtoLens.FieldDescriptor ListPeersRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, latestError__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ListPeersRequest'_unknownFields
        (\ x__ y__ -> x__ {_ListPeersRequest'_unknownFields = y__})
  defMessage
    = ListPeersRequest'_constructor
        {_ListPeersRequest'latestError = Data.ProtoLens.fieldDefault,
         _ListPeersRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ListPeersRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser ListPeersRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "latest_error"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"latestError") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ListPeersRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"latestError") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                         _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData ListPeersRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ListPeersRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq (_ListPeersRequest'latestError x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.peers' @:: Lens' ListPeersResponse [Peer]@
         * 'Proto.Lightning_Fields.vec'peers' @:: Lens' ListPeersResponse (Data.Vector.Vector Peer)@ -}
data ListPeersResponse
  = ListPeersResponse'_constructor {_ListPeersResponse'peers :: !(Data.Vector.Vector Peer),
                                    _ListPeersResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ListPeersResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ListPeersResponse
instance Data.ProtoLens.Field.HasField ListPeersResponse "peers" [Peer] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListPeersResponse'peers
           (\ x__ y__ -> x__ {_ListPeersResponse'peers = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField ListPeersResponse "vec'peers" (Data.Vector.Vector Peer) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListPeersResponse'peers
           (\ x__ y__ -> x__ {_ListPeersResponse'peers = y__}))
        Prelude.id
instance Data.ProtoLens.Message ListPeersResponse where
  messageName _ = Data.Text.pack "lnrpc.ListPeersResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC1ListPeersResponse\DC2!\n\
      \\ENQpeers\CAN\SOH \ETX(\v2\v.lnrpc.PeerR\ENQpeers"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        peers__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "peers"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Peer)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked (Data.ProtoLens.Field.field @"peers")) ::
              Data.ProtoLens.FieldDescriptor ListPeersResponse
      in
        Data.Map.fromList [(Data.ProtoLens.Tag 1, peers__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ListPeersResponse'_unknownFields
        (\ x__ y__ -> x__ {_ListPeersResponse'_unknownFields = y__})
  defMessage
    = ListPeersResponse'_constructor
        {_ListPeersResponse'peers = Data.Vector.Generic.empty,
         _ListPeersResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ListPeersResponse
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Peer
             -> Data.ProtoLens.Encoding.Bytes.Parser ListPeersResponse
        loop x mutable'peers
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'peers <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                        (Data.ProtoLens.Encoding.Growing.unsafeFreeze mutable'peers)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'peers") frozen'peers x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "peers"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'peers y)
                                loop x v
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'peers
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'peers <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                 Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'peers)
          "ListPeersResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view (Data.ProtoLens.Field.field @"vec'peers") _x))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData ListPeersResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ListPeersResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_ListPeersResponse'peers x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.minConfs' @:: Lens' ListUnspentRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.maxConfs' @:: Lens' ListUnspentRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.account' @:: Lens' ListUnspentRequest Data.Text.Text@ -}
data ListUnspentRequest
  = ListUnspentRequest'_constructor {_ListUnspentRequest'minConfs :: !Data.Int.Int32,
                                     _ListUnspentRequest'maxConfs :: !Data.Int.Int32,
                                     _ListUnspentRequest'account :: !Data.Text.Text,
                                     _ListUnspentRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ListUnspentRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ListUnspentRequest
instance Data.ProtoLens.Field.HasField ListUnspentRequest "minConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListUnspentRequest'minConfs
           (\ x__ y__ -> x__ {_ListUnspentRequest'minConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ListUnspentRequest "maxConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListUnspentRequest'maxConfs
           (\ x__ y__ -> x__ {_ListUnspentRequest'maxConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ListUnspentRequest "account" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListUnspentRequest'account
           (\ x__ y__ -> x__ {_ListUnspentRequest'account = y__}))
        Prelude.id
instance Data.ProtoLens.Message ListUnspentRequest where
  messageName _ = Data.Text.pack "lnrpc.ListUnspentRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC2ListUnspentRequest\DC2\ESC\n\
      \\tmin_confs\CAN\SOH \SOH(\ENQR\bminConfs\DC2\ESC\n\
      \\tmax_confs\CAN\STX \SOH(\ENQR\bmaxConfs\DC2\CAN\n\
      \\aaccount\CAN\ETX \SOH(\tR\aaccount"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        minConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minConfs")) ::
              Data.ProtoLens.FieldDescriptor ListUnspentRequest
        maxConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "max_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"maxConfs")) ::
              Data.ProtoLens.FieldDescriptor ListUnspentRequest
        account__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "account"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"account")) ::
              Data.ProtoLens.FieldDescriptor ListUnspentRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, minConfs__field_descriptor),
           (Data.ProtoLens.Tag 2, maxConfs__field_descriptor),
           (Data.ProtoLens.Tag 3, account__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ListUnspentRequest'_unknownFields
        (\ x__ y__ -> x__ {_ListUnspentRequest'_unknownFields = y__})
  defMessage
    = ListUnspentRequest'_constructor
        {_ListUnspentRequest'minConfs = Data.ProtoLens.fieldDefault,
         _ListUnspentRequest'maxConfs = Data.ProtoLens.fieldDefault,
         _ListUnspentRequest'account = Data.ProtoLens.fieldDefault,
         _ListUnspentRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ListUnspentRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser ListUnspentRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minConfs") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "max_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"maxConfs") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "account"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"account") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ListUnspentRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"minConfs") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"maxConfs") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"account") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((Prelude..)
                               (\ bs
                                  -> (Data.Monoid.<>)
                                       (Data.ProtoLens.Encoding.Bytes.putVarInt
                                          (Prelude.fromIntegral (Data.ByteString.length bs)))
                                       (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               Data.Text.Encoding.encodeUtf8 _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData ListUnspentRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ListUnspentRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ListUnspentRequest'minConfs x__)
                (Control.DeepSeq.deepseq
                   (_ListUnspentRequest'maxConfs x__)
                   (Control.DeepSeq.deepseq (_ListUnspentRequest'account x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.utxos' @:: Lens' ListUnspentResponse [Utxo]@
         * 'Proto.Lightning_Fields.vec'utxos' @:: Lens' ListUnspentResponse (Data.Vector.Vector Utxo)@ -}
data ListUnspentResponse
  = ListUnspentResponse'_constructor {_ListUnspentResponse'utxos :: !(Data.Vector.Vector Utxo),
                                      _ListUnspentResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ListUnspentResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ListUnspentResponse
instance Data.ProtoLens.Field.HasField ListUnspentResponse "utxos" [Utxo] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListUnspentResponse'utxos
           (\ x__ y__ -> x__ {_ListUnspentResponse'utxos = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField ListUnspentResponse "vec'utxos" (Data.Vector.Vector Utxo) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ListUnspentResponse'utxos
           (\ x__ y__ -> x__ {_ListUnspentResponse'utxos = y__}))
        Prelude.id
instance Data.ProtoLens.Message ListUnspentResponse where
  messageName _ = Data.Text.pack "lnrpc.ListUnspentResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC3ListUnspentResponse\DC2!\n\
      \\ENQutxos\CAN\SOH \ETX(\v2\v.lnrpc.UtxoR\ENQutxos"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        utxos__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "utxos"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Utxo)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked (Data.ProtoLens.Field.field @"utxos")) ::
              Data.ProtoLens.FieldDescriptor ListUnspentResponse
      in
        Data.Map.fromList [(Data.ProtoLens.Tag 1, utxos__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ListUnspentResponse'_unknownFields
        (\ x__ y__ -> x__ {_ListUnspentResponse'_unknownFields = y__})
  defMessage
    = ListUnspentResponse'_constructor
        {_ListUnspentResponse'utxos = Data.Vector.Generic.empty,
         _ListUnspentResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ListUnspentResponse
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Utxo
             -> Data.ProtoLens.Encoding.Bytes.Parser ListUnspentResponse
        loop x mutable'utxos
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'utxos <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                        (Data.ProtoLens.Encoding.Growing.unsafeFreeze mutable'utxos)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'utxos") frozen'utxos x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "utxos"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'utxos y)
                                loop x v
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'utxos
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'utxos <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                 Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'utxos)
          "ListUnspentResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view (Data.ProtoLens.Field.field @"vec'utxos") _x))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData ListUnspentResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ListUnspentResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_ListUnspentResponse'utxos x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.type'' @:: Lens' NewAddressRequest AddressType@
         * 'Proto.Lightning_Fields.account' @:: Lens' NewAddressRequest Data.Text.Text@ -}
data NewAddressRequest
  = NewAddressRequest'_constructor {_NewAddressRequest'type' :: !AddressType,
                                    _NewAddressRequest'account :: !Data.Text.Text,
                                    _NewAddressRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show NewAddressRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out NewAddressRequest
instance Data.ProtoLens.Field.HasField NewAddressRequest "type'" AddressType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _NewAddressRequest'type'
           (\ x__ y__ -> x__ {_NewAddressRequest'type' = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField NewAddressRequest "account" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _NewAddressRequest'account
           (\ x__ y__ -> x__ {_NewAddressRequest'account = y__}))
        Prelude.id
instance Data.ProtoLens.Message NewAddressRequest where
  messageName _ = Data.Text.pack "lnrpc.NewAddressRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC1NewAddressRequest\DC2&\n\
      \\EOTtype\CAN\SOH \SOH(\SO2\DC2.lnrpc.AddressTypeR\EOTtype\DC2\CAN\n\
      \\aaccount\CAN\STX \SOH(\tR\aaccount"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        type'__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor AddressType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"type'")) ::
              Data.ProtoLens.FieldDescriptor NewAddressRequest
        account__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "account"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"account")) ::
              Data.ProtoLens.FieldDescriptor NewAddressRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, type'__field_descriptor),
           (Data.ProtoLens.Tag 2, account__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _NewAddressRequest'_unknownFields
        (\ x__ y__ -> x__ {_NewAddressRequest'_unknownFields = y__})
  defMessage
    = NewAddressRequest'_constructor
        {_NewAddressRequest'type' = Data.ProtoLens.fieldDefault,
         _NewAddressRequest'account = Data.ProtoLens.fieldDefault,
         _NewAddressRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          NewAddressRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser NewAddressRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "type"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"type'") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "account"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"account") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "NewAddressRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"type'") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral)
                         Prelude.fromEnum _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"account") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData NewAddressRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_NewAddressRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_NewAddressRequest'type' x__)
                (Control.DeepSeq.deepseq (_NewAddressRequest'account x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.address' @:: Lens' NewAddressResponse Data.Text.Text@ -}
data NewAddressResponse
  = NewAddressResponse'_constructor {_NewAddressResponse'address :: !Data.Text.Text,
                                     _NewAddressResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show NewAddressResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out NewAddressResponse
instance Data.ProtoLens.Field.HasField NewAddressResponse "address" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _NewAddressResponse'address
           (\ x__ y__ -> x__ {_NewAddressResponse'address = y__}))
        Prelude.id
instance Data.ProtoLens.Message NewAddressResponse where
  messageName _ = Data.Text.pack "lnrpc.NewAddressResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC2NewAddressResponse\DC2\CAN\n\
      \\aaddress\CAN\SOH \SOH(\tR\aaddress"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        address__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"address")) ::
              Data.ProtoLens.FieldDescriptor NewAddressResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, address__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _NewAddressResponse'_unknownFields
        (\ x__ y__ -> x__ {_NewAddressResponse'_unknownFields = y__})
  defMessage
    = NewAddressResponse'_constructor
        {_NewAddressResponse'address = Data.ProtoLens.fieldDefault,
         _NewAddressResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          NewAddressResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser NewAddressResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "address"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"address") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "NewAddressResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"address") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData NewAddressResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_NewAddressResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_NewAddressResponse'address x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.satPerVbyte' @:: Lens' OpenChannelRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.nodePubkey' @:: Lens' OpenChannelRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.nodePubkeyString' @:: Lens' OpenChannelRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.localFundingAmount' @:: Lens' OpenChannelRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.pushSat' @:: Lens' OpenChannelRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.targetConf' @:: Lens' OpenChannelRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.satPerByte' @:: Lens' OpenChannelRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.private' @:: Lens' OpenChannelRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.minHtlcMsat' @:: Lens' OpenChannelRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.remoteCsvDelay' @:: Lens' OpenChannelRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.minConfs' @:: Lens' OpenChannelRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.spendUnconfirmed' @:: Lens' OpenChannelRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.closeAddress' @:: Lens' OpenChannelRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.fundingShim' @:: Lens' OpenChannelRequest Proto.Lnrpc.Ln0.FundingShim@
         * 'Proto.Lightning_Fields.maybe'fundingShim' @:: Lens' OpenChannelRequest (Prelude.Maybe Proto.Lnrpc.Ln0.FundingShim)@
         * 'Proto.Lightning_Fields.remoteMaxValueInFlightMsat' @:: Lens' OpenChannelRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.remoteMaxHtlcs' @:: Lens' OpenChannelRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.maxLocalCsv' @:: Lens' OpenChannelRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.commitmentType' @:: Lens' OpenChannelRequest Proto.Lnrpc.Ln0.CommitmentType@ -}
data OpenChannelRequest
  = OpenChannelRequest'_constructor {_OpenChannelRequest'satPerVbyte :: !Data.Word.Word64,
                                     _OpenChannelRequest'nodePubkey :: !Data.ByteString.ByteString,
                                     _OpenChannelRequest'nodePubkeyString :: !Data.Text.Text,
                                     _OpenChannelRequest'localFundingAmount :: !Data.Int.Int64,
                                     _OpenChannelRequest'pushSat :: !Data.Int.Int64,
                                     _OpenChannelRequest'targetConf :: !Data.Int.Int32,
                                     _OpenChannelRequest'satPerByte :: !Data.Int.Int64,
                                     _OpenChannelRequest'private :: !Prelude.Bool,
                                     _OpenChannelRequest'minHtlcMsat :: !Data.Int.Int64,
                                     _OpenChannelRequest'remoteCsvDelay :: !Data.Word.Word32,
                                     _OpenChannelRequest'minConfs :: !Data.Int.Int32,
                                     _OpenChannelRequest'spendUnconfirmed :: !Prelude.Bool,
                                     _OpenChannelRequest'closeAddress :: !Data.Text.Text,
                                     _OpenChannelRequest'fundingShim :: !(Prelude.Maybe Proto.Lnrpc.Ln0.FundingShim),
                                     _OpenChannelRequest'remoteMaxValueInFlightMsat :: !Data.Word.Word64,
                                     _OpenChannelRequest'remoteMaxHtlcs :: !Data.Word.Word32,
                                     _OpenChannelRequest'maxLocalCsv :: !Data.Word.Word32,
                                     _OpenChannelRequest'commitmentType :: !Proto.Lnrpc.Ln0.CommitmentType,
                                     _OpenChannelRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show OpenChannelRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out OpenChannelRequest
instance Data.ProtoLens.Field.HasField OpenChannelRequest "satPerVbyte" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'satPerVbyte
           (\ x__ y__ -> x__ {_OpenChannelRequest'satPerVbyte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "nodePubkey" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'nodePubkey
           (\ x__ y__ -> x__ {_OpenChannelRequest'nodePubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "nodePubkeyString" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'nodePubkeyString
           (\ x__ y__ -> x__ {_OpenChannelRequest'nodePubkeyString = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "localFundingAmount" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'localFundingAmount
           (\ x__ y__ -> x__ {_OpenChannelRequest'localFundingAmount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "pushSat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'pushSat
           (\ x__ y__ -> x__ {_OpenChannelRequest'pushSat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "targetConf" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'targetConf
           (\ x__ y__ -> x__ {_OpenChannelRequest'targetConf = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "satPerByte" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'satPerByte
           (\ x__ y__ -> x__ {_OpenChannelRequest'satPerByte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "private" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'private
           (\ x__ y__ -> x__ {_OpenChannelRequest'private = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "minHtlcMsat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'minHtlcMsat
           (\ x__ y__ -> x__ {_OpenChannelRequest'minHtlcMsat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "remoteCsvDelay" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'remoteCsvDelay
           (\ x__ y__ -> x__ {_OpenChannelRequest'remoteCsvDelay = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "minConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'minConfs
           (\ x__ y__ -> x__ {_OpenChannelRequest'minConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "spendUnconfirmed" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'spendUnconfirmed
           (\ x__ y__ -> x__ {_OpenChannelRequest'spendUnconfirmed = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "closeAddress" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'closeAddress
           (\ x__ y__ -> x__ {_OpenChannelRequest'closeAddress = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "fundingShim" Proto.Lnrpc.Ln0.FundingShim where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'fundingShim
           (\ x__ y__ -> x__ {_OpenChannelRequest'fundingShim = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField OpenChannelRequest "maybe'fundingShim" (Prelude.Maybe Proto.Lnrpc.Ln0.FundingShim) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'fundingShim
           (\ x__ y__ -> x__ {_OpenChannelRequest'fundingShim = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "remoteMaxValueInFlightMsat" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'remoteMaxValueInFlightMsat
           (\ x__ y__
              -> x__ {_OpenChannelRequest'remoteMaxValueInFlightMsat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "remoteMaxHtlcs" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'remoteMaxHtlcs
           (\ x__ y__ -> x__ {_OpenChannelRequest'remoteMaxHtlcs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "maxLocalCsv" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'maxLocalCsv
           (\ x__ y__ -> x__ {_OpenChannelRequest'maxLocalCsv = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenChannelRequest "commitmentType" Proto.Lnrpc.Ln0.CommitmentType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenChannelRequest'commitmentType
           (\ x__ y__ -> x__ {_OpenChannelRequest'commitmentType = y__}))
        Prelude.id
instance Data.ProtoLens.Message OpenChannelRequest where
  messageName _ = Data.Text.pack "lnrpc.OpenChannelRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC2OpenChannelRequest\DC2\"\n\
      \\rsat_per_vbyte\CAN\SOH \SOH(\EOTR\vsatPerVbyte\DC2\US\n\
      \\vnode_pubkey\CAN\STX \SOH(\fR\n\
      \nodePubkey\DC20\n\
      \\DC2node_pubkey_string\CAN\ETX \SOH(\tR\DLEnodePubkeyStringB\STX\CAN\SOH\DC20\n\
      \\DC4local_funding_amount\CAN\EOT \SOH(\ETXR\DC2localFundingAmount\DC2\EM\n\
      \\bpush_sat\CAN\ENQ \SOH(\ETXR\apushSat\DC2\US\n\
      \\vtarget_conf\CAN\ACK \SOH(\ENQR\n\
      \targetConf\DC2$\n\
      \\fsat_per_byte\CAN\a \SOH(\ETXR\n\
      \satPerByteB\STX\CAN\SOH\DC2\CAN\n\
      \\aprivate\CAN\b \SOH(\bR\aprivate\DC2\"\n\
      \\rmin_htlc_msat\CAN\t \SOH(\ETXR\vminHtlcMsat\DC2(\n\
      \\DLEremote_csv_delay\CAN\n\
      \ \SOH(\rR\SOremoteCsvDelay\DC2\ESC\n\
      \\tmin_confs\CAN\v \SOH(\ENQR\bminConfs\DC2+\n\
      \\DC1spend_unconfirmed\CAN\f \SOH(\bR\DLEspendUnconfirmed\DC2#\n\
      \\rclose_address\CAN\r \SOH(\tR\fcloseAddress\DC25\n\
      \\ffunding_shim\CAN\SO \SOH(\v2\DC2.lnrpc.FundingShimR\vfundingShim\DC2C\n\
      \\USremote_max_value_in_flight_msat\CAN\SI \SOH(\EOTR\SUBremoteMaxValueInFlightMsat\DC2(\n\
      \\DLEremote_max_htlcs\CAN\DLE \SOH(\rR\SOremoteMaxHtlcs\DC2\"\n\
      \\rmax_local_csv\CAN\DC1 \SOH(\rR\vmaxLocalCsv\DC2>\n\
      \\SIcommitment_type\CAN\DC2 \SOH(\SO2\NAK.lnrpc.CommitmentTypeR\SOcommitmentType"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        satPerVbyte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_vbyte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerVbyte")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        nodePubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "node_pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"nodePubkey")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        nodePubkeyString__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "node_pubkey_string"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"nodePubkeyString")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        localFundingAmount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "local_funding_amount"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"localFundingAmount")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        pushSat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "push_sat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pushSat")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        targetConf__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "target_conf"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"targetConf")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        satPerByte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_byte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerByte")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        private__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "private"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"private")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        minHtlcMsat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_htlc_msat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minHtlcMsat")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        remoteCsvDelay__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "remote_csv_delay"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"remoteCsvDelay")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        minConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minConfs")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        spendUnconfirmed__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "spend_unconfirmed"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"spendUnconfirmed")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        closeAddress__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "close_address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"closeAddress")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        fundingShim__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "funding_shim"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.FundingShim)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'fundingShim")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        remoteMaxValueInFlightMsat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "remote_max_value_in_flight_msat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"remoteMaxValueInFlightMsat")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        remoteMaxHtlcs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "remote_max_htlcs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"remoteMaxHtlcs")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        maxLocalCsv__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "max_local_csv"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"maxLocalCsv")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
        commitmentType__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "commitment_type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.CommitmentType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"commitmentType")) ::
              Data.ProtoLens.FieldDescriptor OpenChannelRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, satPerVbyte__field_descriptor),
           (Data.ProtoLens.Tag 2, nodePubkey__field_descriptor),
           (Data.ProtoLens.Tag 3, nodePubkeyString__field_descriptor),
           (Data.ProtoLens.Tag 4, localFundingAmount__field_descriptor),
           (Data.ProtoLens.Tag 5, pushSat__field_descriptor),
           (Data.ProtoLens.Tag 6, targetConf__field_descriptor),
           (Data.ProtoLens.Tag 7, satPerByte__field_descriptor),
           (Data.ProtoLens.Tag 8, private__field_descriptor),
           (Data.ProtoLens.Tag 9, minHtlcMsat__field_descriptor),
           (Data.ProtoLens.Tag 10, remoteCsvDelay__field_descriptor),
           (Data.ProtoLens.Tag 11, minConfs__field_descriptor),
           (Data.ProtoLens.Tag 12, spendUnconfirmed__field_descriptor),
           (Data.ProtoLens.Tag 13, closeAddress__field_descriptor),
           (Data.ProtoLens.Tag 14, fundingShim__field_descriptor),
           (Data.ProtoLens.Tag 15, 
            remoteMaxValueInFlightMsat__field_descriptor),
           (Data.ProtoLens.Tag 16, remoteMaxHtlcs__field_descriptor),
           (Data.ProtoLens.Tag 17, maxLocalCsv__field_descriptor),
           (Data.ProtoLens.Tag 18, commitmentType__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _OpenChannelRequest'_unknownFields
        (\ x__ y__ -> x__ {_OpenChannelRequest'_unknownFields = y__})
  defMessage
    = OpenChannelRequest'_constructor
        {_OpenChannelRequest'satPerVbyte = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'nodePubkey = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'nodePubkeyString = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'localFundingAmount = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'pushSat = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'targetConf = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'satPerByte = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'private = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'minHtlcMsat = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'remoteCsvDelay = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'minConfs = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'spendUnconfirmed = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'closeAddress = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'fundingShim = Prelude.Nothing,
         _OpenChannelRequest'remoteMaxValueInFlightMsat = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'remoteMaxHtlcs = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'maxLocalCsv = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'commitmentType = Data.ProtoLens.fieldDefault,
         _OpenChannelRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          OpenChannelRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser OpenChannelRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "sat_per_vbyte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerVbyte") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "node_pubkey"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"nodePubkey") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "node_pubkey_string"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"nodePubkeyString") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "local_funding_amount"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"localFundingAmount") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "push_sat"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pushSat") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "target_conf"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"targetConf") y x)
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_per_byte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerByte") y x)
                        64
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "private"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"private") y x)
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_htlc_msat"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minHtlcMsat") y x)
                        80
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "remote_csv_delay"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"remoteCsvDelay") y x)
                        88
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minConfs") y x)
                        96
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "spend_unconfirmed"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"spendUnconfirmed") y x)
                        106
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "close_address"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"closeAddress") y x)
                        114
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "funding_shim"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"fundingShim") y x)
                        120
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt
                                       "remote_max_value_in_flight_msat"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"remoteMaxValueInFlightMsat") y x)
                        128
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "remote_max_htlcs"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"remoteMaxHtlcs") y x)
                        136
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "max_local_csv"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"maxLocalCsv") y x)
                        144
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "commitment_type"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"commitmentType") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "OpenChannelRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerVbyte") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"nodePubkey") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view
                            (Data.ProtoLens.Field.field @"nodePubkeyString") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((Prelude..)
                               (\ bs
                                  -> (Data.Monoid.<>)
                                       (Data.ProtoLens.Encoding.Bytes.putVarInt
                                          (Prelude.fromIntegral (Data.ByteString.length bs)))
                                       (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               Data.Text.Encoding.encodeUtf8 _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view
                               (Data.ProtoLens.Field.field @"localFundingAmount") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                      ((Data.Monoid.<>)
                         (let
                            _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pushSat") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view (Data.ProtoLens.Field.field @"targetConf") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"satPerByte") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                        ((Prelude..)
                                           Data.ProtoLens.Encoding.Bytes.putVarInt
                                           Prelude.fromIntegral _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"private") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 64)
                                           ((Prelude..)
                                              Data.ProtoLens.Encoding.Bytes.putVarInt
                                              (\ b -> if b then 1 else 0) _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"minHtlcMsat") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                              ((Prelude..)
                                                 Data.ProtoLens.Encoding.Bytes.putVarInt
                                                 Prelude.fromIntegral _v))
                                     ((Data.Monoid.<>)
                                        (let
                                           _v
                                             = Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"remoteCsvDelay") _x
                                         in
                                           if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                               Data.Monoid.mempty
                                           else
                                               (Data.Monoid.<>)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt 80)
                                                 ((Prelude..)
                                                    Data.ProtoLens.Encoding.Bytes.putVarInt
                                                    Prelude.fromIntegral _v))
                                        ((Data.Monoid.<>)
                                           (let
                                              _v
                                                = Lens.Family2.view
                                                    (Data.ProtoLens.Field.field @"minConfs") _x
                                            in
                                              if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                  Data.Monoid.mempty
                                              else
                                                  (Data.Monoid.<>)
                                                    (Data.ProtoLens.Encoding.Bytes.putVarInt 88)
                                                    ((Prelude..)
                                                       Data.ProtoLens.Encoding.Bytes.putVarInt
                                                       Prelude.fromIntegral _v))
                                           ((Data.Monoid.<>)
                                              (let
                                                 _v
                                                   = Lens.Family2.view
                                                       (Data.ProtoLens.Field.field
                                                          @"spendUnconfirmed")
                                                       _x
                                               in
                                                 if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                     Data.Monoid.mempty
                                                 else
                                                     (Data.Monoid.<>)
                                                       (Data.ProtoLens.Encoding.Bytes.putVarInt 96)
                                                       ((Prelude..)
                                                          Data.ProtoLens.Encoding.Bytes.putVarInt
                                                          (\ b -> if b then 1 else 0) _v))
                                              ((Data.Monoid.<>)
                                                 (let
                                                    _v
                                                      = Lens.Family2.view
                                                          (Data.ProtoLens.Field.field
                                                             @"closeAddress")
                                                          _x
                                                  in
                                                    if (Prelude.==)
                                                         _v Data.ProtoLens.fieldDefault then
                                                        Data.Monoid.mempty
                                                    else
                                                        (Data.Monoid.<>)
                                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             106)
                                                          ((Prelude..)
                                                             (\ bs
                                                                -> (Data.Monoid.<>)
                                                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                        (Prelude.fromIntegral
                                                                           (Data.ByteString.length
                                                                              bs)))
                                                                     (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                        bs))
                                                             Data.Text.Encoding.encodeUtf8 _v))
                                                 ((Data.Monoid.<>)
                                                    (case
                                                         Lens.Family2.view
                                                           (Data.ProtoLens.Field.field
                                                              @"maybe'fundingShim")
                                                           _x
                                                     of
                                                       Prelude.Nothing -> Data.Monoid.mempty
                                                       (Prelude.Just _v)
                                                         -> (Data.Monoid.<>)
                                                              (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                 114)
                                                              ((Prelude..)
                                                                 (\ bs
                                                                    -> (Data.Monoid.<>)
                                                                         (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                            (Prelude.fromIntegral
                                                                               (Data.ByteString.length
                                                                                  bs)))
                                                                         (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                            bs))
                                                                 Data.ProtoLens.encodeMessage _v))
                                                    ((Data.Monoid.<>)
                                                       (let
                                                          _v
                                                            = Lens.Family2.view
                                                                (Data.ProtoLens.Field.field
                                                                   @"remoteMaxValueInFlightMsat")
                                                                _x
                                                        in
                                                          if (Prelude.==)
                                                               _v Data.ProtoLens.fieldDefault then
                                                              Data.Monoid.mempty
                                                          else
                                                              (Data.Monoid.<>)
                                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                   120)
                                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                   _v))
                                                       ((Data.Monoid.<>)
                                                          (let
                                                             _v
                                                               = Lens.Family2.view
                                                                   (Data.ProtoLens.Field.field
                                                                      @"remoteMaxHtlcs")
                                                                   _x
                                                           in
                                                             if (Prelude.==)
                                                                  _v
                                                                  Data.ProtoLens.fieldDefault then
                                                                 Data.Monoid.mempty
                                                             else
                                                                 (Data.Monoid.<>)
                                                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                      128)
                                                                   ((Prelude..)
                                                                      Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                      Prelude.fromIntegral _v))
                                                          ((Data.Monoid.<>)
                                                             (let
                                                                _v
                                                                  = Lens.Family2.view
                                                                      (Data.ProtoLens.Field.field
                                                                         @"maxLocalCsv")
                                                                      _x
                                                              in
                                                                if (Prelude.==)
                                                                     _v
                                                                     Data.ProtoLens.fieldDefault then
                                                                    Data.Monoid.mempty
                                                                else
                                                                    (Data.Monoid.<>)
                                                                      (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                         136)
                                                                      ((Prelude..)
                                                                         Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                         Prelude.fromIntegral _v))
                                                             ((Data.Monoid.<>)
                                                                (let
                                                                   _v
                                                                     = Lens.Family2.view
                                                                         (Data.ProtoLens.Field.field
                                                                            @"commitmentType")
                                                                         _x
                                                                 in
                                                                   if (Prelude.==)
                                                                        _v
                                                                        Data.ProtoLens.fieldDefault then
                                                                       Data.Monoid.mempty
                                                                   else
                                                                       (Data.Monoid.<>)
                                                                         (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                            144)
                                                                         ((Prelude..)
                                                                            ((Prelude..)
                                                                               Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                               Prelude.fromIntegral)
                                                                            Prelude.fromEnum _v))
                                                                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                                                   (Lens.Family2.view
                                                                      Data.ProtoLens.unknownFields
                                                                      _x)))))))))))))))))))
instance Control.DeepSeq.NFData OpenChannelRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_OpenChannelRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_OpenChannelRequest'satPerVbyte x__)
                (Control.DeepSeq.deepseq
                   (_OpenChannelRequest'nodePubkey x__)
                   (Control.DeepSeq.deepseq
                      (_OpenChannelRequest'nodePubkeyString x__)
                      (Control.DeepSeq.deepseq
                         (_OpenChannelRequest'localFundingAmount x__)
                         (Control.DeepSeq.deepseq
                            (_OpenChannelRequest'pushSat x__)
                            (Control.DeepSeq.deepseq
                               (_OpenChannelRequest'targetConf x__)
                               (Control.DeepSeq.deepseq
                                  (_OpenChannelRequest'satPerByte x__)
                                  (Control.DeepSeq.deepseq
                                     (_OpenChannelRequest'private x__)
                                     (Control.DeepSeq.deepseq
                                        (_OpenChannelRequest'minHtlcMsat x__)
                                        (Control.DeepSeq.deepseq
                                           (_OpenChannelRequest'remoteCsvDelay x__)
                                           (Control.DeepSeq.deepseq
                                              (_OpenChannelRequest'minConfs x__)
                                              (Control.DeepSeq.deepseq
                                                 (_OpenChannelRequest'spendUnconfirmed x__)
                                                 (Control.DeepSeq.deepseq
                                                    (_OpenChannelRequest'closeAddress x__)
                                                    (Control.DeepSeq.deepseq
                                                       (_OpenChannelRequest'fundingShim x__)
                                                       (Control.DeepSeq.deepseq
                                                          (_OpenChannelRequest'remoteMaxValueInFlightMsat
                                                             x__)
                                                          (Control.DeepSeq.deepseq
                                                             (_OpenChannelRequest'remoteMaxHtlcs
                                                                x__)
                                                             (Control.DeepSeq.deepseq
                                                                (_OpenChannelRequest'maxLocalCsv
                                                                   x__)
                                                                (Control.DeepSeq.deepseq
                                                                   (_OpenChannelRequest'commitmentType
                                                                      x__)
                                                                   ()))))))))))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.pendingChanId' @:: Lens' OpenStatusUpdate Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.maybe'update' @:: Lens' OpenStatusUpdate (Prelude.Maybe OpenStatusUpdate'Update)@
         * 'Proto.Lightning_Fields.maybe'chanPending' @:: Lens' OpenStatusUpdate (Prelude.Maybe Proto.Lnrpc.Ln0.PendingUpdate)@
         * 'Proto.Lightning_Fields.chanPending' @:: Lens' OpenStatusUpdate Proto.Lnrpc.Ln0.PendingUpdate@
         * 'Proto.Lightning_Fields.maybe'chanOpen' @:: Lens' OpenStatusUpdate (Prelude.Maybe ChannelOpenUpdate)@
         * 'Proto.Lightning_Fields.chanOpen' @:: Lens' OpenStatusUpdate ChannelOpenUpdate@
         * 'Proto.Lightning_Fields.maybe'psbtFund' @:: Lens' OpenStatusUpdate (Prelude.Maybe ReadyForPsbtFunding)@
         * 'Proto.Lightning_Fields.psbtFund' @:: Lens' OpenStatusUpdate ReadyForPsbtFunding@ -}
data OpenStatusUpdate
  = OpenStatusUpdate'_constructor {_OpenStatusUpdate'pendingChanId :: !Data.ByteString.ByteString,
                                   _OpenStatusUpdate'update :: !(Prelude.Maybe OpenStatusUpdate'Update),
                                   _OpenStatusUpdate'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show OpenStatusUpdate where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out OpenStatusUpdate
data OpenStatusUpdate'Update
  = OpenStatusUpdate'ChanPending !Proto.Lnrpc.Ln0.PendingUpdate |
    OpenStatusUpdate'ChanOpen !ChannelOpenUpdate |
    OpenStatusUpdate'PsbtFund !ReadyForPsbtFunding
  deriving stock (Prelude.Show,
                  Prelude.Eq,
                  Prelude.Ord,
                  GHC.Generics.Generic)
instance Text.PrettyPrint.GenericPretty.Out OpenStatusUpdate'Update
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "pendingChanId" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'pendingChanId
           (\ x__ y__ -> x__ {_OpenStatusUpdate'pendingChanId = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "maybe'update" (Prelude.Maybe OpenStatusUpdate'Update) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "maybe'chanPending" (Prelude.Maybe Proto.Lnrpc.Ln0.PendingUpdate) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        (Lens.Family2.Unchecked.lens
           (\ x__
              -> case x__ of
                   (Prelude.Just (OpenStatusUpdate'ChanPending x__val))
                     -> Prelude.Just x__val
                   _otherwise -> Prelude.Nothing)
           (\ _ y__ -> Prelude.fmap OpenStatusUpdate'ChanPending y__))
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "chanPending" Proto.Lnrpc.Ln0.PendingUpdate where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        ((Prelude..)
           (Lens.Family2.Unchecked.lens
              (\ x__
                 -> case x__ of
                      (Prelude.Just (OpenStatusUpdate'ChanPending x__val))
                        -> Prelude.Just x__val
                      _otherwise -> Prelude.Nothing)
              (\ _ y__ -> Prelude.fmap OpenStatusUpdate'ChanPending y__))
           (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage))
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "maybe'chanOpen" (Prelude.Maybe ChannelOpenUpdate) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        (Lens.Family2.Unchecked.lens
           (\ x__
              -> case x__ of
                   (Prelude.Just (OpenStatusUpdate'ChanOpen x__val))
                     -> Prelude.Just x__val
                   _otherwise -> Prelude.Nothing)
           (\ _ y__ -> Prelude.fmap OpenStatusUpdate'ChanOpen y__))
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "chanOpen" ChannelOpenUpdate where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        ((Prelude..)
           (Lens.Family2.Unchecked.lens
              (\ x__
                 -> case x__ of
                      (Prelude.Just (OpenStatusUpdate'ChanOpen x__val))
                        -> Prelude.Just x__val
                      _otherwise -> Prelude.Nothing)
              (\ _ y__ -> Prelude.fmap OpenStatusUpdate'ChanOpen y__))
           (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage))
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "maybe'psbtFund" (Prelude.Maybe ReadyForPsbtFunding) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        (Lens.Family2.Unchecked.lens
           (\ x__
              -> case x__ of
                   (Prelude.Just (OpenStatusUpdate'PsbtFund x__val))
                     -> Prelude.Just x__val
                   _otherwise -> Prelude.Nothing)
           (\ _ y__ -> Prelude.fmap OpenStatusUpdate'PsbtFund y__))
instance Data.ProtoLens.Field.HasField OpenStatusUpdate "psbtFund" ReadyForPsbtFunding where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _OpenStatusUpdate'update
           (\ x__ y__ -> x__ {_OpenStatusUpdate'update = y__}))
        ((Prelude..)
           (Lens.Family2.Unchecked.lens
              (\ x__
                 -> case x__ of
                      (Prelude.Just (OpenStatusUpdate'PsbtFund x__val))
                        -> Prelude.Just x__val
                      _otherwise -> Prelude.Nothing)
              (\ _ y__ -> Prelude.fmap OpenStatusUpdate'PsbtFund y__))
           (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage))
instance Data.ProtoLens.Message OpenStatusUpdate where
  messageName _ = Data.Text.pack "lnrpc.OpenStatusUpdate"
  packedMessageDescriptor _
    = "\n\
      \\DLEOpenStatusUpdate\DC29\n\
      \\fchan_pending\CAN\SOH \SOH(\v2\DC4.lnrpc.PendingUpdateH\NULR\vchanPending\DC27\n\
      \\tchan_open\CAN\ETX \SOH(\v2\CAN.lnrpc.ChannelOpenUpdateH\NULR\bchanOpen\DC29\n\
      \\tpsbt_fund\CAN\ENQ \SOH(\v2\SUB.lnrpc.ReadyForPsbtFundingH\NULR\bpsbtFund\DC2&\n\
      \\SIpending_chan_id\CAN\EOT \SOH(\fR\rpendingChanIdB\b\n\
      \\ACKupdate"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        pendingChanId__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pending_chan_id"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"pendingChanId")) ::
              Data.ProtoLens.FieldDescriptor OpenStatusUpdate
        chanPending__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "chan_pending"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.PendingUpdate)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'chanPending")) ::
              Data.ProtoLens.FieldDescriptor OpenStatusUpdate
        chanOpen__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "chan_open"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor ChannelOpenUpdate)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'chanOpen")) ::
              Data.ProtoLens.FieldDescriptor OpenStatusUpdate
        psbtFund__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "psbt_fund"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor ReadyForPsbtFunding)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'psbtFund")) ::
              Data.ProtoLens.FieldDescriptor OpenStatusUpdate
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 4, pendingChanId__field_descriptor),
           (Data.ProtoLens.Tag 1, chanPending__field_descriptor),
           (Data.ProtoLens.Tag 3, chanOpen__field_descriptor),
           (Data.ProtoLens.Tag 5, psbtFund__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _OpenStatusUpdate'_unknownFields
        (\ x__ y__ -> x__ {_OpenStatusUpdate'_unknownFields = y__})
  defMessage
    = OpenStatusUpdate'_constructor
        {_OpenStatusUpdate'pendingChanId = Data.ProtoLens.fieldDefault,
         _OpenStatusUpdate'update = Prelude.Nothing,
         _OpenStatusUpdate'_unknownFields = []}
  parseMessage
    = let
        loop ::
          OpenStatusUpdate
          -> Data.ProtoLens.Encoding.Bytes.Parser OpenStatusUpdate
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "pending_chan_id"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"pendingChanId") y x)
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "chan_pending"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"chanPending") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "chan_open"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"chanOpen") y x)
                        42
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "psbt_fund"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"psbtFund") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "OpenStatusUpdate"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view
                      (Data.ProtoLens.Field.field @"pendingChanId") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (case
                     Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'update") _x
                 of
                   Prelude.Nothing -> Data.Monoid.mempty
                   (Prelude.Just (OpenStatusUpdate'ChanPending v))
                     -> (Data.Monoid.<>)
                          (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                          ((Prelude..)
                             (\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                             Data.ProtoLens.encodeMessage v)
                   (Prelude.Just (OpenStatusUpdate'ChanOpen v))
                     -> (Data.Monoid.<>)
                          (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                          ((Prelude..)
                             (\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                             Data.ProtoLens.encodeMessage v)
                   (Prelude.Just (OpenStatusUpdate'PsbtFund v))
                     -> (Data.Monoid.<>)
                          (Data.ProtoLens.Encoding.Bytes.putVarInt 42)
                          ((Prelude..)
                             (\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                             Data.ProtoLens.encodeMessage v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData OpenStatusUpdate where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_OpenStatusUpdate'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_OpenStatusUpdate'pendingChanId x__)
                (Control.DeepSeq.deepseq (_OpenStatusUpdate'update x__) ()))
instance Control.DeepSeq.NFData OpenStatusUpdate'Update where
  rnf (OpenStatusUpdate'ChanPending x__) = Control.DeepSeq.rnf x__
  rnf (OpenStatusUpdate'ChanOpen x__) = Control.DeepSeq.rnf x__
  rnf (OpenStatusUpdate'PsbtFund x__) = Control.DeepSeq.rnf x__
_OpenStatusUpdate'ChanPending ::
  Data.ProtoLens.Prism.Prism' OpenStatusUpdate'Update Proto.Lnrpc.Ln0.PendingUpdate
_OpenStatusUpdate'ChanPending
  = Data.ProtoLens.Prism.prism'
      OpenStatusUpdate'ChanPending
      (\ p__
         -> case p__ of
              (OpenStatusUpdate'ChanPending p__val) -> Prelude.Just p__val
              _otherwise -> Prelude.Nothing)
_OpenStatusUpdate'ChanOpen ::
  Data.ProtoLens.Prism.Prism' OpenStatusUpdate'Update ChannelOpenUpdate
_OpenStatusUpdate'ChanOpen
  = Data.ProtoLens.Prism.prism'
      OpenStatusUpdate'ChanOpen
      (\ p__
         -> case p__ of
              (OpenStatusUpdate'ChanOpen p__val) -> Prelude.Just p__val
              _otherwise -> Prelude.Nothing)
_OpenStatusUpdate'PsbtFund ::
  Data.ProtoLens.Prism.Prism' OpenStatusUpdate'Update ReadyForPsbtFunding
_OpenStatusUpdate'PsbtFund
  = Data.ProtoLens.Prism.prism'
      OpenStatusUpdate'PsbtFund
      (\ p__
         -> case p__ of
              (OpenStatusUpdate'PsbtFund p__val) -> Prelude.Just p__val
              _otherwise -> Prelude.Nothing)
{- | Fields :
     
         * 'Proto.Lightning_Fields.pubKey' @:: Lens' Peer Data.Text.Text@
         * 'Proto.Lightning_Fields.address' @:: Lens' Peer Data.Text.Text@
         * 'Proto.Lightning_Fields.bytesSent' @:: Lens' Peer Data.Word.Word64@
         * 'Proto.Lightning_Fields.bytesRecv' @:: Lens' Peer Data.Word.Word64@
         * 'Proto.Lightning_Fields.satSent' @:: Lens' Peer Data.Int.Int64@
         * 'Proto.Lightning_Fields.satRecv' @:: Lens' Peer Data.Int.Int64@
         * 'Proto.Lightning_Fields.inbound' @:: Lens' Peer Prelude.Bool@
         * 'Proto.Lightning_Fields.pingTime' @:: Lens' Peer Data.Int.Int64@
         * 'Proto.Lightning_Fields.syncType' @:: Lens' Peer Peer'SyncType@
         * 'Proto.Lightning_Fields.features' @:: Lens' Peer (Data.Map.Map Data.Word.Word32 Proto.Lnrpc.Ln0.Feature)@
         * 'Proto.Lightning_Fields.errors' @:: Lens' Peer [TimestampedError]@
         * 'Proto.Lightning_Fields.vec'errors' @:: Lens' Peer (Data.Vector.Vector TimestampedError)@
         * 'Proto.Lightning_Fields.flapCount' @:: Lens' Peer Data.Int.Int32@
         * 'Proto.Lightning_Fields.lastFlapNs' @:: Lens' Peer Data.Int.Int64@
         * 'Proto.Lightning_Fields.lastPingPayload' @:: Lens' Peer Data.ByteString.ByteString@ -}
data Peer
  = Peer'_constructor {_Peer'pubKey :: !Data.Text.Text,
                       _Peer'address :: !Data.Text.Text,
                       _Peer'bytesSent :: !Data.Word.Word64,
                       _Peer'bytesRecv :: !Data.Word.Word64,
                       _Peer'satSent :: !Data.Int.Int64,
                       _Peer'satRecv :: !Data.Int.Int64,
                       _Peer'inbound :: !Prelude.Bool,
                       _Peer'pingTime :: !Data.Int.Int64,
                       _Peer'syncType :: !Peer'SyncType,
                       _Peer'features :: !(Data.Map.Map Data.Word.Word32 Proto.Lnrpc.Ln0.Feature),
                       _Peer'errors :: !(Data.Vector.Vector TimestampedError),
                       _Peer'flapCount :: !Data.Int.Int32,
                       _Peer'lastFlapNs :: !Data.Int.Int64,
                       _Peer'lastPingPayload :: !Data.ByteString.ByteString,
                       _Peer'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show Peer where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out Peer
instance Data.ProtoLens.Field.HasField Peer "pubKey" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'pubKey (\ x__ y__ -> x__ {_Peer'pubKey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "address" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'address (\ x__ y__ -> x__ {_Peer'address = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "bytesSent" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'bytesSent (\ x__ y__ -> x__ {_Peer'bytesSent = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "bytesRecv" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'bytesRecv (\ x__ y__ -> x__ {_Peer'bytesRecv = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "satSent" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'satSent (\ x__ y__ -> x__ {_Peer'satSent = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "satRecv" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'satRecv (\ x__ y__ -> x__ {_Peer'satRecv = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "inbound" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'inbound (\ x__ y__ -> x__ {_Peer'inbound = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "pingTime" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'pingTime (\ x__ y__ -> x__ {_Peer'pingTime = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "syncType" Peer'SyncType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'syncType (\ x__ y__ -> x__ {_Peer'syncType = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "features" (Data.Map.Map Data.Word.Word32 Proto.Lnrpc.Ln0.Feature) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'features (\ x__ y__ -> x__ {_Peer'features = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "errors" [TimestampedError] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'errors (\ x__ y__ -> x__ {_Peer'errors = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField Peer "vec'errors" (Data.Vector.Vector TimestampedError) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'errors (\ x__ y__ -> x__ {_Peer'errors = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "flapCount" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'flapCount (\ x__ y__ -> x__ {_Peer'flapCount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "lastFlapNs" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'lastFlapNs (\ x__ y__ -> x__ {_Peer'lastFlapNs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer "lastPingPayload" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'lastPingPayload
           (\ x__ y__ -> x__ {_Peer'lastPingPayload = y__}))
        Prelude.id
instance Data.ProtoLens.Message Peer where
  messageName _ = Data.Text.pack "lnrpc.Peer"
  packedMessageDescriptor _
    = "\n\
      \\EOTPeer\DC2\ETB\n\
      \\apub_key\CAN\SOH \SOH(\tR\ACKpubKey\DC2\CAN\n\
      \\aaddress\CAN\ETX \SOH(\tR\aaddress\DC2\GS\n\
      \\n\
      \bytes_sent\CAN\EOT \SOH(\EOTR\tbytesSent\DC2\GS\n\
      \\n\
      \bytes_recv\CAN\ENQ \SOH(\EOTR\tbytesRecv\DC2\EM\n\
      \\bsat_sent\CAN\ACK \SOH(\ETXR\asatSent\DC2\EM\n\
      \\bsat_recv\CAN\a \SOH(\ETXR\asatRecv\DC2\CAN\n\
      \\ainbound\CAN\b \SOH(\bR\ainbound\DC2\ESC\n\
      \\tping_time\CAN\t \SOH(\ETXR\bpingTime\DC21\n\
      \\tsync_type\CAN\n\
      \ \SOH(\SO2\DC4.lnrpc.Peer.SyncTypeR\bsyncType\DC25\n\
      \\bfeatures\CAN\v \ETX(\v2\EM.lnrpc.Peer.FeaturesEntryR\bfeatures\DC2/\n\
      \\ACKerrors\CAN\f \ETX(\v2\ETB.lnrpc.TimestampedErrorR\ACKerrors\DC2\GS\n\
      \\n\
      \flap_count\CAN\r \SOH(\ENQR\tflapCount\DC2 \n\
      \\flast_flap_ns\CAN\SO \SOH(\ETXR\n\
      \lastFlapNs\DC2*\n\
      \\DC1last_ping_payload\CAN\SI \SOH(\fR\SIlastPingPayload\SUBK\n\
      \\rFeaturesEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\rR\ETXkey\DC2$\n\
      \\ENQvalue\CAN\STX \SOH(\v2\SO.lnrpc.FeatureR\ENQvalue:\STX8\SOH\"P\n\
      \\bSyncType\DC2\DLE\n\
      \\fUNKNOWN_SYNC\DLE\NUL\DC2\SI\n\
      \\vACTIVE_SYNC\DLE\SOH\DC2\DLE\n\
      \\fPASSIVE_SYNC\DLE\STX\DC2\SI\n\
      \\vPINNED_SYNC\DLE\ETX"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        pubKey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pub_key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pubKey")) ::
              Data.ProtoLens.FieldDescriptor Peer
        address__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"address")) ::
              Data.ProtoLens.FieldDescriptor Peer
        bytesSent__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "bytes_sent"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"bytesSent")) ::
              Data.ProtoLens.FieldDescriptor Peer
        bytesRecv__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "bytes_recv"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"bytesRecv")) ::
              Data.ProtoLens.FieldDescriptor Peer
        satSent__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_sent"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"satSent")) ::
              Data.ProtoLens.FieldDescriptor Peer
        satRecv__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_recv"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"satRecv")) ::
              Data.ProtoLens.FieldDescriptor Peer
        inbound__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "inbound"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"inbound")) ::
              Data.ProtoLens.FieldDescriptor Peer
        pingTime__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "ping_time"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"pingTime")) ::
              Data.ProtoLens.FieldDescriptor Peer
        syncType__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sync_type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor Peer'SyncType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"syncType")) ::
              Data.ProtoLens.FieldDescriptor Peer
        features__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "features"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Peer'FeaturesEntry)
              (Data.ProtoLens.MapField
                 (Data.ProtoLens.Field.field @"key")
                 (Data.ProtoLens.Field.field @"value")
                 (Data.ProtoLens.Field.field @"features")) ::
              Data.ProtoLens.FieldDescriptor Peer
        errors__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "errors"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor TimestampedError)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked (Data.ProtoLens.Field.field @"errors")) ::
              Data.ProtoLens.FieldDescriptor Peer
        flapCount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "flap_count"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"flapCount")) ::
              Data.ProtoLens.FieldDescriptor Peer
        lastFlapNs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "last_flap_ns"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"lastFlapNs")) ::
              Data.ProtoLens.FieldDescriptor Peer
        lastPingPayload__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "last_ping_payload"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"lastPingPayload")) ::
              Data.ProtoLens.FieldDescriptor Peer
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, pubKey__field_descriptor),
           (Data.ProtoLens.Tag 3, address__field_descriptor),
           (Data.ProtoLens.Tag 4, bytesSent__field_descriptor),
           (Data.ProtoLens.Tag 5, bytesRecv__field_descriptor),
           (Data.ProtoLens.Tag 6, satSent__field_descriptor),
           (Data.ProtoLens.Tag 7, satRecv__field_descriptor),
           (Data.ProtoLens.Tag 8, inbound__field_descriptor),
           (Data.ProtoLens.Tag 9, pingTime__field_descriptor),
           (Data.ProtoLens.Tag 10, syncType__field_descriptor),
           (Data.ProtoLens.Tag 11, features__field_descriptor),
           (Data.ProtoLens.Tag 12, errors__field_descriptor),
           (Data.ProtoLens.Tag 13, flapCount__field_descriptor),
           (Data.ProtoLens.Tag 14, lastFlapNs__field_descriptor),
           (Data.ProtoLens.Tag 15, lastPingPayload__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _Peer'_unknownFields
        (\ x__ y__ -> x__ {_Peer'_unknownFields = y__})
  defMessage
    = Peer'_constructor
        {_Peer'pubKey = Data.ProtoLens.fieldDefault,
         _Peer'address = Data.ProtoLens.fieldDefault,
         _Peer'bytesSent = Data.ProtoLens.fieldDefault,
         _Peer'bytesRecv = Data.ProtoLens.fieldDefault,
         _Peer'satSent = Data.ProtoLens.fieldDefault,
         _Peer'satRecv = Data.ProtoLens.fieldDefault,
         _Peer'inbound = Data.ProtoLens.fieldDefault,
         _Peer'pingTime = Data.ProtoLens.fieldDefault,
         _Peer'syncType = Data.ProtoLens.fieldDefault,
         _Peer'features = Data.Map.empty,
         _Peer'errors = Data.Vector.Generic.empty,
         _Peer'flapCount = Data.ProtoLens.fieldDefault,
         _Peer'lastFlapNs = Data.ProtoLens.fieldDefault,
         _Peer'lastPingPayload = Data.ProtoLens.fieldDefault,
         _Peer'_unknownFields = []}
  parseMessage
    = let
        loop ::
          Peer
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld TimestampedError
             -> Data.ProtoLens.Encoding.Bytes.Parser Peer
        loop x mutable'errors
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'errors <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                         (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                            mutable'errors)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'errors") frozen'errors x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "pub_key"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"pubKey") y x)
                                  mutable'errors
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "address"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"address") y x)
                                  mutable'errors
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "bytes_sent"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"bytesSent") y x)
                                  mutable'errors
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "bytes_recv"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"bytesRecv") y x)
                                  mutable'errors
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_sent"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satSent") y x)
                                  mutable'errors
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_recv"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satRecv") y x)
                                  mutable'errors
                        64
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "inbound"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"inbound") y x)
                                  mutable'errors
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "ping_time"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"pingTime") y x)
                                  mutable'errors
                        80
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "sync_type"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"syncType") y x)
                                  mutable'errors
                        90
                          -> do !(entry :: Peer'FeaturesEntry) <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                                                    (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                                        Data.ProtoLens.Encoding.Bytes.isolate
                                                                          (Prelude.fromIntegral len)
                                                                          Data.ProtoLens.parseMessage)
                                                                    "features"
                                (let
                                   key = Lens.Family2.view (Data.ProtoLens.Field.field @"key") entry
                                   value
                                     = Lens.Family2.view (Data.ProtoLens.Field.field @"value") entry
                                 in
                                   loop
                                     (Lens.Family2.over
                                        (Data.ProtoLens.Field.field @"features")
                                        (\ !t -> Data.Map.insert key value t) x)
                                     mutable'errors)
                        98
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "errors"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append mutable'errors y)
                                loop x v
                        104
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "flap_count"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"flapCount") y x)
                                  mutable'errors
                        112
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "last_flap_ns"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"lastFlapNs") y x)
                                  mutable'errors
                        122
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "last_ping_payload"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"lastPingPayload") y x)
                                  mutable'errors
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'errors
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'errors <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                  Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'errors)
          "Peer"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pubKey") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"address") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"bytesSent") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"bytesRecv") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                      ((Data.Monoid.<>)
                         (let
                            _v = Lens.Family2.view (Data.ProtoLens.Field.field @"satSent") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"satRecv") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v = Lens.Family2.view (Data.ProtoLens.Field.field @"inbound") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 64)
                                        ((Prelude..)
                                           Data.ProtoLens.Encoding.Bytes.putVarInt
                                           (\ b -> if b then 1 else 0) _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"pingTime") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                           ((Prelude..)
                                              Data.ProtoLens.Encoding.Bytes.putVarInt
                                              Prelude.fromIntegral _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"syncType") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 80)
                                              ((Prelude..)
                                                 ((Prelude..)
                                                    Data.ProtoLens.Encoding.Bytes.putVarInt
                                                    Prelude.fromIntegral)
                                                 Prelude.fromEnum _v))
                                     ((Data.Monoid.<>)
                                        (Data.Monoid.mconcat
                                           (Prelude.map
                                              (\ _v
                                                 -> (Data.Monoid.<>)
                                                      (Data.ProtoLens.Encoding.Bytes.putVarInt 90)
                                                      ((Prelude..)
                                                         (\ bs
                                                            -> (Data.Monoid.<>)
                                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                    (Prelude.fromIntegral
                                                                       (Data.ByteString.length bs)))
                                                                 (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                    bs))
                                                         Data.ProtoLens.encodeMessage
                                                         (Lens.Family2.set
                                                            (Data.ProtoLens.Field.field @"key")
                                                            (Prelude.fst _v)
                                                            (Lens.Family2.set
                                                               (Data.ProtoLens.Field.field @"value")
                                                               (Prelude.snd _v)
                                                               (Data.ProtoLens.defMessage ::
                                                                  Peer'FeaturesEntry)))))
                                              (Data.Map.toList
                                                 (Lens.Family2.view
                                                    (Data.ProtoLens.Field.field @"features") _x))))
                                        ((Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                                              (\ _v
                                                 -> (Data.Monoid.<>)
                                                      (Data.ProtoLens.Encoding.Bytes.putVarInt 98)
                                                      ((Prelude..)
                                                         (\ bs
                                                            -> (Data.Monoid.<>)
                                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                    (Prelude.fromIntegral
                                                                       (Data.ByteString.length bs)))
                                                                 (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                    bs))
                                                         Data.ProtoLens.encodeMessage _v))
                                              (Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"vec'errors") _x))
                                           ((Data.Monoid.<>)
                                              (let
                                                 _v
                                                   = Lens.Family2.view
                                                       (Data.ProtoLens.Field.field @"flapCount") _x
                                               in
                                                 if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                     Data.Monoid.mempty
                                                 else
                                                     (Data.Monoid.<>)
                                                       (Data.ProtoLens.Encoding.Bytes.putVarInt 104)
                                                       ((Prelude..)
                                                          Data.ProtoLens.Encoding.Bytes.putVarInt
                                                          Prelude.fromIntegral _v))
                                              ((Data.Monoid.<>)
                                                 (let
                                                    _v
                                                      = Lens.Family2.view
                                                          (Data.ProtoLens.Field.field @"lastFlapNs")
                                                          _x
                                                  in
                                                    if (Prelude.==)
                                                         _v Data.ProtoLens.fieldDefault then
                                                        Data.Monoid.mempty
                                                    else
                                                        (Data.Monoid.<>)
                                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             112)
                                                          ((Prelude..)
                                                             Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             Prelude.fromIntegral _v))
                                                 ((Data.Monoid.<>)
                                                    (let
                                                       _v
                                                         = Lens.Family2.view
                                                             (Data.ProtoLens.Field.field
                                                                @"lastPingPayload")
                                                             _x
                                                     in
                                                       if (Prelude.==)
                                                            _v Data.ProtoLens.fieldDefault then
                                                           Data.Monoid.mempty
                                                       else
                                                           (Data.Monoid.<>)
                                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                122)
                                                             ((\ bs
                                                                 -> (Data.Monoid.<>)
                                                                      (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                         (Prelude.fromIntegral
                                                                            (Data.ByteString.length
                                                                               bs)))
                                                                      (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                         bs))
                                                                _v))
                                                    (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                                       (Lens.Family2.view
                                                          Data.ProtoLens.unknownFields
                                                          _x)))))))))))))))
instance Control.DeepSeq.NFData Peer where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_Peer'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_Peer'pubKey x__)
                (Control.DeepSeq.deepseq
                   (_Peer'address x__)
                   (Control.DeepSeq.deepseq
                      (_Peer'bytesSent x__)
                      (Control.DeepSeq.deepseq
                         (_Peer'bytesRecv x__)
                         (Control.DeepSeq.deepseq
                            (_Peer'satSent x__)
                            (Control.DeepSeq.deepseq
                               (_Peer'satRecv x__)
                               (Control.DeepSeq.deepseq
                                  (_Peer'inbound x__)
                                  (Control.DeepSeq.deepseq
                                     (_Peer'pingTime x__)
                                     (Control.DeepSeq.deepseq
                                        (_Peer'syncType x__)
                                        (Control.DeepSeq.deepseq
                                           (_Peer'features x__)
                                           (Control.DeepSeq.deepseq
                                              (_Peer'errors x__)
                                              (Control.DeepSeq.deepseq
                                                 (_Peer'flapCount x__)
                                                 (Control.DeepSeq.deepseq
                                                    (_Peer'lastFlapNs x__)
                                                    (Control.DeepSeq.deepseq
                                                       (_Peer'lastPingPayload x__) ()))))))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.key' @:: Lens' Peer'FeaturesEntry Data.Word.Word32@
         * 'Proto.Lightning_Fields.value' @:: Lens' Peer'FeaturesEntry Proto.Lnrpc.Ln0.Feature@
         * 'Proto.Lightning_Fields.maybe'value' @:: Lens' Peer'FeaturesEntry (Prelude.Maybe Proto.Lnrpc.Ln0.Feature)@ -}
data Peer'FeaturesEntry
  = Peer'FeaturesEntry'_constructor {_Peer'FeaturesEntry'key :: !Data.Word.Word32,
                                     _Peer'FeaturesEntry'value :: !(Prelude.Maybe Proto.Lnrpc.Ln0.Feature),
                                     _Peer'FeaturesEntry'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show Peer'FeaturesEntry where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out Peer'FeaturesEntry
instance Data.ProtoLens.Field.HasField Peer'FeaturesEntry "key" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'FeaturesEntry'key
           (\ x__ y__ -> x__ {_Peer'FeaturesEntry'key = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Peer'FeaturesEntry "value" Proto.Lnrpc.Ln0.Feature where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'FeaturesEntry'value
           (\ x__ y__ -> x__ {_Peer'FeaturesEntry'value = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField Peer'FeaturesEntry "maybe'value" (Prelude.Maybe Proto.Lnrpc.Ln0.Feature) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Peer'FeaturesEntry'value
           (\ x__ y__ -> x__ {_Peer'FeaturesEntry'value = y__}))
        Prelude.id
instance Data.ProtoLens.Message Peer'FeaturesEntry where
  messageName _ = Data.Text.pack "lnrpc.Peer.FeaturesEntry"
  packedMessageDescriptor _
    = "\n\
      \\rFeaturesEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\rR\ETXkey\DC2$\n\
      \\ENQvalue\CAN\STX \SOH(\v2\SO.lnrpc.FeatureR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        key__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"key")) ::
              Data.ProtoLens.FieldDescriptor Peer'FeaturesEntry
        value__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "value"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.Feature)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'value")) ::
              Data.ProtoLens.FieldDescriptor Peer'FeaturesEntry
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, key__field_descriptor),
           (Data.ProtoLens.Tag 2, value__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _Peer'FeaturesEntry'_unknownFields
        (\ x__ y__ -> x__ {_Peer'FeaturesEntry'_unknownFields = y__})
  defMessage
    = Peer'FeaturesEntry'_constructor
        {_Peer'FeaturesEntry'key = Data.ProtoLens.fieldDefault,
         _Peer'FeaturesEntry'value = Prelude.Nothing,
         _Peer'FeaturesEntry'_unknownFields = []}
  parseMessage
    = let
        loop ::
          Peer'FeaturesEntry
          -> Data.ProtoLens.Encoding.Bytes.Parser Peer'FeaturesEntry
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"key") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "value"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"value") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "FeaturesEntry"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"key") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
             ((Data.Monoid.<>)
                (case
                     Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'value") _x
                 of
                   Prelude.Nothing -> Data.Monoid.mempty
                   (Prelude.Just _v)
                     -> (Data.Monoid.<>)
                          (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                          ((Prelude..)
                             (\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                             Data.ProtoLens.encodeMessage _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData Peer'FeaturesEntry where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_Peer'FeaturesEntry'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_Peer'FeaturesEntry'key x__)
                (Control.DeepSeq.deepseq (_Peer'FeaturesEntry'value x__) ()))
newtype Peer'SyncType'UnrecognizedValue
  = Peer'SyncType'UnrecognizedValue Data.Int.Int32
  deriving stock (Prelude.Eq,
                  Prelude.Ord,
                  Prelude.Show,
                  GHC.Generics.Generic)
instance Text.PrettyPrint.GenericPretty.Out Peer'SyncType'UnrecognizedValue
data Peer'SyncType
  = Peer'UNKNOWN_SYNC |
    Peer'ACTIVE_SYNC |
    Peer'PASSIVE_SYNC |
    Peer'PINNED_SYNC |
    Peer'SyncType'Unrecognized !Peer'SyncType'UnrecognizedValue
  deriving stock (Prelude.Show,
                  Prelude.Eq,
                  Prelude.Ord,
                  GHC.Generics.Generic)
instance Data.ProtoLens.MessageEnum Peer'SyncType where
  maybeToEnum 0 = Prelude.Just Peer'UNKNOWN_SYNC
  maybeToEnum 1 = Prelude.Just Peer'ACTIVE_SYNC
  maybeToEnum 2 = Prelude.Just Peer'PASSIVE_SYNC
  maybeToEnum 3 = Prelude.Just Peer'PINNED_SYNC
  maybeToEnum k
    = Prelude.Just
        (Peer'SyncType'Unrecognized
           (Peer'SyncType'UnrecognizedValue (Prelude.fromIntegral k)))
  showEnum Peer'UNKNOWN_SYNC = "UNKNOWN_SYNC"
  showEnum Peer'ACTIVE_SYNC = "ACTIVE_SYNC"
  showEnum Peer'PASSIVE_SYNC = "PASSIVE_SYNC"
  showEnum Peer'PINNED_SYNC = "PINNED_SYNC"
  showEnum
    (Peer'SyncType'Unrecognized (Peer'SyncType'UnrecognizedValue k))
    = Prelude.show k
  readEnum k
    | (Prelude.==) k "UNKNOWN_SYNC" = Prelude.Just Peer'UNKNOWN_SYNC
    | (Prelude.==) k "ACTIVE_SYNC" = Prelude.Just Peer'ACTIVE_SYNC
    | (Prelude.==) k "PASSIVE_SYNC" = Prelude.Just Peer'PASSIVE_SYNC
    | (Prelude.==) k "PINNED_SYNC" = Prelude.Just Peer'PINNED_SYNC
    | Prelude.otherwise
    = (Prelude.>>=) (Text.Read.readMaybe k) Data.ProtoLens.maybeToEnum
instance Prelude.Bounded Peer'SyncType where
  minBound = Peer'UNKNOWN_SYNC
  maxBound = Peer'PINNED_SYNC
instance Prelude.Enum Peer'SyncType where
  toEnum k__
    = Prelude.maybe
        (Prelude.error
           ((Prelude.++)
              "toEnum: unknown value for enum SyncType: " (Prelude.show k__)))
        Prelude.id (Data.ProtoLens.maybeToEnum k__)
  fromEnum Peer'UNKNOWN_SYNC = 0
  fromEnum Peer'ACTIVE_SYNC = 1
  fromEnum Peer'PASSIVE_SYNC = 2
  fromEnum Peer'PINNED_SYNC = 3
  fromEnum
    (Peer'SyncType'Unrecognized (Peer'SyncType'UnrecognizedValue k))
    = Prelude.fromIntegral k
  succ Peer'PINNED_SYNC
    = Prelude.error
        "Peer'SyncType.succ: bad argument Peer'PINNED_SYNC. This value would be out of bounds."
  succ Peer'UNKNOWN_SYNC = Peer'ACTIVE_SYNC
  succ Peer'ACTIVE_SYNC = Peer'PASSIVE_SYNC
  succ Peer'PASSIVE_SYNC = Peer'PINNED_SYNC
  succ (Peer'SyncType'Unrecognized _)
    = Prelude.error
        "Peer'SyncType.succ: bad argument: unrecognized value"
  pred Peer'UNKNOWN_SYNC
    = Prelude.error
        "Peer'SyncType.pred: bad argument Peer'UNKNOWN_SYNC. This value would be out of bounds."
  pred Peer'ACTIVE_SYNC = Peer'UNKNOWN_SYNC
  pred Peer'PASSIVE_SYNC = Peer'ACTIVE_SYNC
  pred Peer'PINNED_SYNC = Peer'PASSIVE_SYNC
  pred (Peer'SyncType'Unrecognized _)
    = Prelude.error
        "Peer'SyncType.pred: bad argument: unrecognized value"
  enumFrom = Data.ProtoLens.Message.Enum.messageEnumFrom
  enumFromTo = Data.ProtoLens.Message.Enum.messageEnumFromTo
  enumFromThen = Data.ProtoLens.Message.Enum.messageEnumFromThen
  enumFromThenTo = Data.ProtoLens.Message.Enum.messageEnumFromThenTo
instance Data.ProtoLens.FieldDefault Peer'SyncType where
  fieldDefault = Peer'UNKNOWN_SYNC
instance Control.DeepSeq.NFData Peer'SyncType where
  rnf x__ = Prelude.seq x__ ()
instance Text.PrettyPrint.GenericPretty.Out Peer'SyncType
{- | Fields :
     
         * 'Proto.Lightning_Fields.pubKey' @:: Lens' PeerEvent Data.Text.Text@
         * 'Proto.Lightning_Fields.type'' @:: Lens' PeerEvent PeerEvent'EventType@ -}
data PeerEvent
  = PeerEvent'_constructor {_PeerEvent'pubKey :: !Data.Text.Text,
                            _PeerEvent'type' :: !PeerEvent'EventType,
                            _PeerEvent'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show PeerEvent where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out PeerEvent
instance Data.ProtoLens.Field.HasField PeerEvent "pubKey" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _PeerEvent'pubKey (\ x__ y__ -> x__ {_PeerEvent'pubKey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField PeerEvent "type'" PeerEvent'EventType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _PeerEvent'type' (\ x__ y__ -> x__ {_PeerEvent'type' = y__}))
        Prelude.id
instance Data.ProtoLens.Message PeerEvent where
  messageName _ = Data.Text.pack "lnrpc.PeerEvent"
  packedMessageDescriptor _
    = "\n\
      \\tPeerEvent\DC2\ETB\n\
      \\apub_key\CAN\SOH \SOH(\tR\ACKpubKey\DC2.\n\
      \\EOTtype\CAN\STX \SOH(\SO2\SUB.lnrpc.PeerEvent.EventTypeR\EOTtype\".\n\
      \\tEventType\DC2\SI\n\
      \\vPEER_ONLINE\DLE\NUL\DC2\DLE\n\
      \\fPEER_OFFLINE\DLE\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        pubKey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pub_key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pubKey")) ::
              Data.ProtoLens.FieldDescriptor PeerEvent
        type'__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor PeerEvent'EventType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"type'")) ::
              Data.ProtoLens.FieldDescriptor PeerEvent
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, pubKey__field_descriptor),
           (Data.ProtoLens.Tag 2, type'__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _PeerEvent'_unknownFields
        (\ x__ y__ -> x__ {_PeerEvent'_unknownFields = y__})
  defMessage
    = PeerEvent'_constructor
        {_PeerEvent'pubKey = Data.ProtoLens.fieldDefault,
         _PeerEvent'type' = Data.ProtoLens.fieldDefault,
         _PeerEvent'_unknownFields = []}
  parseMessage
    = let
        loop :: PeerEvent -> Data.ProtoLens.Encoding.Bytes.Parser PeerEvent
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "pub_key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pubKey") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "type"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"type'") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "PeerEvent"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pubKey") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"type'") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral)
                            Prelude.fromEnum _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData PeerEvent where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_PeerEvent'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_PeerEvent'pubKey x__)
                (Control.DeepSeq.deepseq (_PeerEvent'type' x__) ()))
newtype PeerEvent'EventType'UnrecognizedValue
  = PeerEvent'EventType'UnrecognizedValue Data.Int.Int32
  deriving stock (Prelude.Eq,
                  Prelude.Ord,
                  Prelude.Show,
                  GHC.Generics.Generic)
instance Text.PrettyPrint.GenericPretty.Out PeerEvent'EventType'UnrecognizedValue
data PeerEvent'EventType
  = PeerEvent'PEER_ONLINE |
    PeerEvent'PEER_OFFLINE |
    PeerEvent'EventType'Unrecognized !PeerEvent'EventType'UnrecognizedValue
  deriving stock (Prelude.Show,
                  Prelude.Eq,
                  Prelude.Ord,
                  GHC.Generics.Generic)
instance Data.ProtoLens.MessageEnum PeerEvent'EventType where
  maybeToEnum 0 = Prelude.Just PeerEvent'PEER_ONLINE
  maybeToEnum 1 = Prelude.Just PeerEvent'PEER_OFFLINE
  maybeToEnum k
    = Prelude.Just
        (PeerEvent'EventType'Unrecognized
           (PeerEvent'EventType'UnrecognizedValue (Prelude.fromIntegral k)))
  showEnum PeerEvent'PEER_ONLINE = "PEER_ONLINE"
  showEnum PeerEvent'PEER_OFFLINE = "PEER_OFFLINE"
  showEnum
    (PeerEvent'EventType'Unrecognized (PeerEvent'EventType'UnrecognizedValue k))
    = Prelude.show k
  readEnum k
    | (Prelude.==) k "PEER_ONLINE" = Prelude.Just PeerEvent'PEER_ONLINE
    | (Prelude.==) k "PEER_OFFLINE"
    = Prelude.Just PeerEvent'PEER_OFFLINE
    | Prelude.otherwise
    = (Prelude.>>=) (Text.Read.readMaybe k) Data.ProtoLens.maybeToEnum
instance Prelude.Bounded PeerEvent'EventType where
  minBound = PeerEvent'PEER_ONLINE
  maxBound = PeerEvent'PEER_OFFLINE
instance Prelude.Enum PeerEvent'EventType where
  toEnum k__
    = Prelude.maybe
        (Prelude.error
           ((Prelude.++)
              "toEnum: unknown value for enum EventType: " (Prelude.show k__)))
        Prelude.id (Data.ProtoLens.maybeToEnum k__)
  fromEnum PeerEvent'PEER_ONLINE = 0
  fromEnum PeerEvent'PEER_OFFLINE = 1
  fromEnum
    (PeerEvent'EventType'Unrecognized (PeerEvent'EventType'UnrecognizedValue k))
    = Prelude.fromIntegral k
  succ PeerEvent'PEER_OFFLINE
    = Prelude.error
        "PeerEvent'EventType.succ: bad argument PeerEvent'PEER_OFFLINE. This value would be out of bounds."
  succ PeerEvent'PEER_ONLINE = PeerEvent'PEER_OFFLINE
  succ (PeerEvent'EventType'Unrecognized _)
    = Prelude.error
        "PeerEvent'EventType.succ: bad argument: unrecognized value"
  pred PeerEvent'PEER_ONLINE
    = Prelude.error
        "PeerEvent'EventType.pred: bad argument PeerEvent'PEER_ONLINE. This value would be out of bounds."
  pred PeerEvent'PEER_OFFLINE = PeerEvent'PEER_ONLINE
  pred (PeerEvent'EventType'Unrecognized _)
    = Prelude.error
        "PeerEvent'EventType.pred: bad argument: unrecognized value"
  enumFrom = Data.ProtoLens.Message.Enum.messageEnumFrom
  enumFromTo = Data.ProtoLens.Message.Enum.messageEnumFromTo
  enumFromThen = Data.ProtoLens.Message.Enum.messageEnumFromThen
  enumFromThenTo = Data.ProtoLens.Message.Enum.messageEnumFromThenTo
instance Data.ProtoLens.FieldDefault PeerEvent'EventType where
  fieldDefault = PeerEvent'PEER_ONLINE
instance Control.DeepSeq.NFData PeerEvent'EventType where
  rnf x__ = Prelude.seq x__ ()
instance Text.PrettyPrint.GenericPretty.Out PeerEvent'EventType
{- | Fields :
      -}
data PeerEventSubscription
  = PeerEventSubscription'_constructor {_PeerEventSubscription'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show PeerEventSubscription where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out PeerEventSubscription
instance Data.ProtoLens.Message PeerEventSubscription where
  messageName _ = Data.Text.pack "lnrpc.PeerEventSubscription"
  packedMessageDescriptor _
    = "\n\
      \\NAKPeerEventSubscription"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _PeerEventSubscription'_unknownFields
        (\ x__ y__ -> x__ {_PeerEventSubscription'_unknownFields = y__})
  defMessage
    = PeerEventSubscription'_constructor
        {_PeerEventSubscription'_unknownFields = []}
  parseMessage
    = let
        loop ::
          PeerEventSubscription
          -> Data.ProtoLens.Encoding.Bytes.Parser PeerEventSubscription
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "PeerEventSubscription"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData PeerEventSubscription where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_PeerEventSubscription'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.fundingAddress' @:: Lens' ReadyForPsbtFunding Data.Text.Text@
         * 'Proto.Lightning_Fields.fundingAmount' @:: Lens' ReadyForPsbtFunding Data.Int.Int64@
         * 'Proto.Lightning_Fields.psbt' @:: Lens' ReadyForPsbtFunding Data.ByteString.ByteString@ -}
data ReadyForPsbtFunding
  = ReadyForPsbtFunding'_constructor {_ReadyForPsbtFunding'fundingAddress :: !Data.Text.Text,
                                      _ReadyForPsbtFunding'fundingAmount :: !Data.Int.Int64,
                                      _ReadyForPsbtFunding'psbt :: !Data.ByteString.ByteString,
                                      _ReadyForPsbtFunding'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show ReadyForPsbtFunding where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out ReadyForPsbtFunding
instance Data.ProtoLens.Field.HasField ReadyForPsbtFunding "fundingAddress" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ReadyForPsbtFunding'fundingAddress
           (\ x__ y__ -> x__ {_ReadyForPsbtFunding'fundingAddress = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ReadyForPsbtFunding "fundingAmount" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ReadyForPsbtFunding'fundingAmount
           (\ x__ y__ -> x__ {_ReadyForPsbtFunding'fundingAmount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField ReadyForPsbtFunding "psbt" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _ReadyForPsbtFunding'psbt
           (\ x__ y__ -> x__ {_ReadyForPsbtFunding'psbt = y__}))
        Prelude.id
instance Data.ProtoLens.Message ReadyForPsbtFunding where
  messageName _ = Data.Text.pack "lnrpc.ReadyForPsbtFunding"
  packedMessageDescriptor _
    = "\n\
      \\DC3ReadyForPsbtFunding\DC2'\n\
      \\SIfunding_address\CAN\SOH \SOH(\tR\SOfundingAddress\DC2%\n\
      \\SOfunding_amount\CAN\STX \SOH(\ETXR\rfundingAmount\DC2\DC2\n\
      \\EOTpsbt\CAN\ETX \SOH(\fR\EOTpsbt"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        fundingAddress__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "funding_address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"fundingAddress")) ::
              Data.ProtoLens.FieldDescriptor ReadyForPsbtFunding
        fundingAmount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "funding_amount"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"fundingAmount")) ::
              Data.ProtoLens.FieldDescriptor ReadyForPsbtFunding
        psbt__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "psbt"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"psbt")) ::
              Data.ProtoLens.FieldDescriptor ReadyForPsbtFunding
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, fundingAddress__field_descriptor),
           (Data.ProtoLens.Tag 2, fundingAmount__field_descriptor),
           (Data.ProtoLens.Tag 3, psbt__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _ReadyForPsbtFunding'_unknownFields
        (\ x__ y__ -> x__ {_ReadyForPsbtFunding'_unknownFields = y__})
  defMessage
    = ReadyForPsbtFunding'_constructor
        {_ReadyForPsbtFunding'fundingAddress = Data.ProtoLens.fieldDefault,
         _ReadyForPsbtFunding'fundingAmount = Data.ProtoLens.fieldDefault,
         _ReadyForPsbtFunding'psbt = Data.ProtoLens.fieldDefault,
         _ReadyForPsbtFunding'_unknownFields = []}
  parseMessage
    = let
        loop ::
          ReadyForPsbtFunding
          -> Data.ProtoLens.Encoding.Bytes.Parser ReadyForPsbtFunding
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "funding_address"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"fundingAddress") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "funding_amount"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"fundingAmount") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "psbt"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"psbt") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "ReadyForPsbtFunding"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view
                      (Data.ProtoLens.Field.field @"fundingAddress") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"fundingAmount") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"psbt") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData ReadyForPsbtFunding where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_ReadyForPsbtFunding'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_ReadyForPsbtFunding'fundingAddress x__)
                (Control.DeepSeq.deepseq
                   (_ReadyForPsbtFunding'fundingAmount x__)
                   (Control.DeepSeq.deepseq (_ReadyForPsbtFunding'psbt x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.addr' @:: Lens' SendCoinsRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.amount' @:: Lens' SendCoinsRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.targetConf' @:: Lens' SendCoinsRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.satPerVbyte' @:: Lens' SendCoinsRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.satPerByte' @:: Lens' SendCoinsRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.sendAll' @:: Lens' SendCoinsRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.label' @:: Lens' SendCoinsRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.minConfs' @:: Lens' SendCoinsRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.spendUnconfirmed' @:: Lens' SendCoinsRequest Prelude.Bool@ -}
data SendCoinsRequest
  = SendCoinsRequest'_constructor {_SendCoinsRequest'addr :: !Data.Text.Text,
                                   _SendCoinsRequest'amount :: !Data.Int.Int64,
                                   _SendCoinsRequest'targetConf :: !Data.Int.Int32,
                                   _SendCoinsRequest'satPerVbyte :: !Data.Word.Word64,
                                   _SendCoinsRequest'satPerByte :: !Data.Int.Int64,
                                   _SendCoinsRequest'sendAll :: !Prelude.Bool,
                                   _SendCoinsRequest'label :: !Data.Text.Text,
                                   _SendCoinsRequest'minConfs :: !Data.Int.Int32,
                                   _SendCoinsRequest'spendUnconfirmed :: !Prelude.Bool,
                                   _SendCoinsRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendCoinsRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendCoinsRequest
instance Data.ProtoLens.Field.HasField SendCoinsRequest "addr" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'addr
           (\ x__ y__ -> x__ {_SendCoinsRequest'addr = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "amount" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'amount
           (\ x__ y__ -> x__ {_SendCoinsRequest'amount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "targetConf" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'targetConf
           (\ x__ y__ -> x__ {_SendCoinsRequest'targetConf = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "satPerVbyte" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'satPerVbyte
           (\ x__ y__ -> x__ {_SendCoinsRequest'satPerVbyte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "satPerByte" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'satPerByte
           (\ x__ y__ -> x__ {_SendCoinsRequest'satPerByte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "sendAll" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'sendAll
           (\ x__ y__ -> x__ {_SendCoinsRequest'sendAll = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "label" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'label
           (\ x__ y__ -> x__ {_SendCoinsRequest'label = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "minConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'minConfs
           (\ x__ y__ -> x__ {_SendCoinsRequest'minConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCoinsRequest "spendUnconfirmed" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsRequest'spendUnconfirmed
           (\ x__ y__ -> x__ {_SendCoinsRequest'spendUnconfirmed = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendCoinsRequest where
  messageName _ = Data.Text.pack "lnrpc.SendCoinsRequest"
  packedMessageDescriptor _
    = "\n\
      \\DLESendCoinsRequest\DC2\DC2\n\
      \\EOTaddr\CAN\SOH \SOH(\tR\EOTaddr\DC2\SYN\n\
      \\ACKamount\CAN\STX \SOH(\ETXR\ACKamount\DC2\US\n\
      \\vtarget_conf\CAN\ETX \SOH(\ENQR\n\
      \targetConf\DC2\"\n\
      \\rsat_per_vbyte\CAN\EOT \SOH(\EOTR\vsatPerVbyte\DC2$\n\
      \\fsat_per_byte\CAN\ENQ \SOH(\ETXR\n\
      \satPerByteB\STX\CAN\SOH\DC2\EM\n\
      \\bsend_all\CAN\ACK \SOH(\bR\asendAll\DC2\DC4\n\
      \\ENQlabel\CAN\a \SOH(\tR\ENQlabel\DC2\ESC\n\
      \\tmin_confs\CAN\b \SOH(\ENQR\bminConfs\DC2+\n\
      \\DC1spend_unconfirmed\CAN\t \SOH(\bR\DLEspendUnconfirmed"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        addr__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "addr"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"addr")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        amount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "amount"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"amount")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        targetConf__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "target_conf"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"targetConf")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        satPerVbyte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_vbyte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerVbyte")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        satPerByte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_byte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerByte")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        sendAll__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "send_all"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"sendAll")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        label__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "label"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"label")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        minConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minConfs")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
        spendUnconfirmed__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "spend_unconfirmed"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"spendUnconfirmed")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, addr__field_descriptor),
           (Data.ProtoLens.Tag 2, amount__field_descriptor),
           (Data.ProtoLens.Tag 3, targetConf__field_descriptor),
           (Data.ProtoLens.Tag 4, satPerVbyte__field_descriptor),
           (Data.ProtoLens.Tag 5, satPerByte__field_descriptor),
           (Data.ProtoLens.Tag 6, sendAll__field_descriptor),
           (Data.ProtoLens.Tag 7, label__field_descriptor),
           (Data.ProtoLens.Tag 8, minConfs__field_descriptor),
           (Data.ProtoLens.Tag 9, spendUnconfirmed__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendCoinsRequest'_unknownFields
        (\ x__ y__ -> x__ {_SendCoinsRequest'_unknownFields = y__})
  defMessage
    = SendCoinsRequest'_constructor
        {_SendCoinsRequest'addr = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'amount = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'targetConf = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'satPerVbyte = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'satPerByte = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'sendAll = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'label = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'minConfs = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'spendUnconfirmed = Data.ProtoLens.fieldDefault,
         _SendCoinsRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendCoinsRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser SendCoinsRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "addr"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"addr") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "amount"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"amount") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "target_conf"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"targetConf") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "sat_per_vbyte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerVbyte") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_per_byte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerByte") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "send_all"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"sendAll") y x)
                        58
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "label"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"label") y x)
                        64
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minConfs") y x)
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "spend_unconfirmed"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"spendUnconfirmed") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendCoinsRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"addr") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"amount") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"targetConf") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerVbyte") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerByte") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"sendAll") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (\ b -> if b then 1 else 0) _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v = Lens.Family2.view (Data.ProtoLens.Field.field @"label") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 58)
                                        ((Prelude..)
                                           (\ bs
                                              -> (Data.Monoid.<>)
                                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                      (Prelude.fromIntegral
                                                         (Data.ByteString.length bs)))
                                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                           Data.Text.Encoding.encodeUtf8 _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"minConfs") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 64)
                                           ((Prelude..)
                                              Data.ProtoLens.Encoding.Bytes.putVarInt
                                              Prelude.fromIntegral _v))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"spendUnconfirmed") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                              ((Prelude..)
                                                 Data.ProtoLens.Encoding.Bytes.putVarInt
                                                 (\ b -> if b then 1 else 0) _v))
                                     (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                        (Lens.Family2.view Data.ProtoLens.unknownFields _x))))))))))
instance Control.DeepSeq.NFData SendCoinsRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendCoinsRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendCoinsRequest'addr x__)
                (Control.DeepSeq.deepseq
                   (_SendCoinsRequest'amount x__)
                   (Control.DeepSeq.deepseq
                      (_SendCoinsRequest'targetConf x__)
                      (Control.DeepSeq.deepseq
                         (_SendCoinsRequest'satPerVbyte x__)
                         (Control.DeepSeq.deepseq
                            (_SendCoinsRequest'satPerByte x__)
                            (Control.DeepSeq.deepseq
                               (_SendCoinsRequest'sendAll x__)
                               (Control.DeepSeq.deepseq
                                  (_SendCoinsRequest'label x__)
                                  (Control.DeepSeq.deepseq
                                     (_SendCoinsRequest'minConfs x__)
                                     (Control.DeepSeq.deepseq
                                        (_SendCoinsRequest'spendUnconfirmed x__) ())))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.txid' @:: Lens' SendCoinsResponse Data.Text.Text@ -}
data SendCoinsResponse
  = SendCoinsResponse'_constructor {_SendCoinsResponse'txid :: !Data.Text.Text,
                                    _SendCoinsResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendCoinsResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendCoinsResponse
instance Data.ProtoLens.Field.HasField SendCoinsResponse "txid" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCoinsResponse'txid
           (\ x__ y__ -> x__ {_SendCoinsResponse'txid = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendCoinsResponse where
  messageName _ = Data.Text.pack "lnrpc.SendCoinsResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC1SendCoinsResponse\DC2\DC2\n\
      \\EOTtxid\CAN\SOH \SOH(\tR\EOTtxid"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        txid__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "txid"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"txid")) ::
              Data.ProtoLens.FieldDescriptor SendCoinsResponse
      in
        Data.Map.fromList [(Data.ProtoLens.Tag 1, txid__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendCoinsResponse'_unknownFields
        (\ x__ y__ -> x__ {_SendCoinsResponse'_unknownFields = y__})
  defMessage
    = SendCoinsResponse'_constructor
        {_SendCoinsResponse'txid = Data.ProtoLens.fieldDefault,
         _SendCoinsResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendCoinsResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser SendCoinsResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "txid"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"txid") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendCoinsResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"txid") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData SendCoinsResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendCoinsResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_SendCoinsResponse'txid x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.peer' @:: Lens' SendCustomMessageRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.type'' @:: Lens' SendCustomMessageRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.data'' @:: Lens' SendCustomMessageRequest Data.ByteString.ByteString@ -}
data SendCustomMessageRequest
  = SendCustomMessageRequest'_constructor {_SendCustomMessageRequest'peer :: !Data.ByteString.ByteString,
                                           _SendCustomMessageRequest'type' :: !Data.Word.Word32,
                                           _SendCustomMessageRequest'data' :: !Data.ByteString.ByteString,
                                           _SendCustomMessageRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendCustomMessageRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendCustomMessageRequest
instance Data.ProtoLens.Field.HasField SendCustomMessageRequest "peer" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCustomMessageRequest'peer
           (\ x__ y__ -> x__ {_SendCustomMessageRequest'peer = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCustomMessageRequest "type'" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCustomMessageRequest'type'
           (\ x__ y__ -> x__ {_SendCustomMessageRequest'type' = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendCustomMessageRequest "data'" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendCustomMessageRequest'data'
           (\ x__ y__ -> x__ {_SendCustomMessageRequest'data' = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendCustomMessageRequest where
  messageName _ = Data.Text.pack "lnrpc.SendCustomMessageRequest"
  packedMessageDescriptor _
    = "\n\
      \\CANSendCustomMessageRequest\DC2\DC2\n\
      \\EOTpeer\CAN\SOH \SOH(\fR\EOTpeer\DC2\DC2\n\
      \\EOTtype\CAN\STX \SOH(\rR\EOTtype\DC2\DC2\n\
      \\EOTdata\CAN\ETX \SOH(\fR\EOTdata"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        peer__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "peer"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"peer")) ::
              Data.ProtoLens.FieldDescriptor SendCustomMessageRequest
        type'__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"type'")) ::
              Data.ProtoLens.FieldDescriptor SendCustomMessageRequest
        data'__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "data"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"data'")) ::
              Data.ProtoLens.FieldDescriptor SendCustomMessageRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, peer__field_descriptor),
           (Data.ProtoLens.Tag 2, type'__field_descriptor),
           (Data.ProtoLens.Tag 3, data'__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendCustomMessageRequest'_unknownFields
        (\ x__ y__ -> x__ {_SendCustomMessageRequest'_unknownFields = y__})
  defMessage
    = SendCustomMessageRequest'_constructor
        {_SendCustomMessageRequest'peer = Data.ProtoLens.fieldDefault,
         _SendCustomMessageRequest'type' = Data.ProtoLens.fieldDefault,
         _SendCustomMessageRequest'data' = Data.ProtoLens.fieldDefault,
         _SendCustomMessageRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendCustomMessageRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser SendCustomMessageRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "peer"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"peer") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "type"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"type'") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "data"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"data'") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendCustomMessageRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"peer") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"type'") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"data'") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                            ((\ bs
                                -> (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt
                                        (Prelude.fromIntegral (Data.ByteString.length bs)))
                                     (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                               _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData SendCustomMessageRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendCustomMessageRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendCustomMessageRequest'peer x__)
                (Control.DeepSeq.deepseq
                   (_SendCustomMessageRequest'type' x__)
                   (Control.DeepSeq.deepseq
                      (_SendCustomMessageRequest'data' x__) ())))
{- | Fields :
      -}
data SendCustomMessageResponse
  = SendCustomMessageResponse'_constructor {_SendCustomMessageResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendCustomMessageResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendCustomMessageResponse
instance Data.ProtoLens.Message SendCustomMessageResponse where
  messageName _ = Data.Text.pack "lnrpc.SendCustomMessageResponse"
  packedMessageDescriptor _
    = "\n\
      \\EMSendCustomMessageResponse"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendCustomMessageResponse'_unknownFields
        (\ x__ y__
           -> x__ {_SendCustomMessageResponse'_unknownFields = y__})
  defMessage
    = SendCustomMessageResponse'_constructor
        {_SendCustomMessageResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendCustomMessageResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser SendCustomMessageResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendCustomMessageResponse"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData SendCustomMessageResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendCustomMessageResponse'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.addrToAmount' @:: Lens' SendManyRequest (Data.Map.Map Data.Text.Text Data.Int.Int64)@
         * 'Proto.Lightning_Fields.targetConf' @:: Lens' SendManyRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.satPerVbyte' @:: Lens' SendManyRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.satPerByte' @:: Lens' SendManyRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.label' @:: Lens' SendManyRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.minConfs' @:: Lens' SendManyRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.spendUnconfirmed' @:: Lens' SendManyRequest Prelude.Bool@ -}
data SendManyRequest
  = SendManyRequest'_constructor {_SendManyRequest'addrToAmount :: !(Data.Map.Map Data.Text.Text Data.Int.Int64),
                                  _SendManyRequest'targetConf :: !Data.Int.Int32,
                                  _SendManyRequest'satPerVbyte :: !Data.Word.Word64,
                                  _SendManyRequest'satPerByte :: !Data.Int.Int64,
                                  _SendManyRequest'label :: !Data.Text.Text,
                                  _SendManyRequest'minConfs :: !Data.Int.Int32,
                                  _SendManyRequest'spendUnconfirmed :: !Prelude.Bool,
                                  _SendManyRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendManyRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendManyRequest
instance Data.ProtoLens.Field.HasField SendManyRequest "addrToAmount" (Data.Map.Map Data.Text.Text Data.Int.Int64) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'addrToAmount
           (\ x__ y__ -> x__ {_SendManyRequest'addrToAmount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest "targetConf" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'targetConf
           (\ x__ y__ -> x__ {_SendManyRequest'targetConf = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest "satPerVbyte" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'satPerVbyte
           (\ x__ y__ -> x__ {_SendManyRequest'satPerVbyte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest "satPerByte" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'satPerByte
           (\ x__ y__ -> x__ {_SendManyRequest'satPerByte = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest "label" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'label
           (\ x__ y__ -> x__ {_SendManyRequest'label = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest "minConfs" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'minConfs
           (\ x__ y__ -> x__ {_SendManyRequest'minConfs = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest "spendUnconfirmed" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'spendUnconfirmed
           (\ x__ y__ -> x__ {_SendManyRequest'spendUnconfirmed = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendManyRequest where
  messageName _ = Data.Text.pack "lnrpc.SendManyRequest"
  packedMessageDescriptor _
    = "\n\
      \\SISendManyRequest\DC2L\n\
      \\fAddrToAmount\CAN\SOH \ETX(\v2(.lnrpc.SendManyRequest.AddrToAmountEntryR\fAddrToAmount\DC2\US\n\
      \\vtarget_conf\CAN\ETX \SOH(\ENQR\n\
      \targetConf\DC2\"\n\
      \\rsat_per_vbyte\CAN\EOT \SOH(\EOTR\vsatPerVbyte\DC2$\n\
      \\fsat_per_byte\CAN\ENQ \SOH(\ETXR\n\
      \satPerByteB\STX\CAN\SOH\DC2\DC4\n\
      \\ENQlabel\CAN\ACK \SOH(\tR\ENQlabel\DC2\ESC\n\
      \\tmin_confs\CAN\a \SOH(\ENQR\bminConfs\DC2+\n\
      \\DC1spend_unconfirmed\CAN\b \SOH(\bR\DLEspendUnconfirmed\SUB?\n\
      \\DC1AddrToAmountEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\tR\ETXkey\DC2\DC4\n\
      \\ENQvalue\CAN\STX \SOH(\ETXR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        addrToAmount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "AddrToAmount"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor SendManyRequest'AddrToAmountEntry)
              (Data.ProtoLens.MapField
                 (Data.ProtoLens.Field.field @"key")
                 (Data.ProtoLens.Field.field @"value")
                 (Data.ProtoLens.Field.field @"addrToAmount")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
        targetConf__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "target_conf"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"targetConf")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
        satPerVbyte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_vbyte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerVbyte")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
        satPerByte__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "sat_per_byte"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"satPerByte")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
        label__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "label"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"label")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
        minConfs__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "min_confs"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"minConfs")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
        spendUnconfirmed__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "spend_unconfirmed"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"spendUnconfirmed")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, addrToAmount__field_descriptor),
           (Data.ProtoLens.Tag 3, targetConf__field_descriptor),
           (Data.ProtoLens.Tag 4, satPerVbyte__field_descriptor),
           (Data.ProtoLens.Tag 5, satPerByte__field_descriptor),
           (Data.ProtoLens.Tag 6, label__field_descriptor),
           (Data.ProtoLens.Tag 7, minConfs__field_descriptor),
           (Data.ProtoLens.Tag 8, spendUnconfirmed__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendManyRequest'_unknownFields
        (\ x__ y__ -> x__ {_SendManyRequest'_unknownFields = y__})
  defMessage
    = SendManyRequest'_constructor
        {_SendManyRequest'addrToAmount = Data.Map.empty,
         _SendManyRequest'targetConf = Data.ProtoLens.fieldDefault,
         _SendManyRequest'satPerVbyte = Data.ProtoLens.fieldDefault,
         _SendManyRequest'satPerByte = Data.ProtoLens.fieldDefault,
         _SendManyRequest'label = Data.ProtoLens.fieldDefault,
         _SendManyRequest'minConfs = Data.ProtoLens.fieldDefault,
         _SendManyRequest'spendUnconfirmed = Data.ProtoLens.fieldDefault,
         _SendManyRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendManyRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser SendManyRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !(entry :: SendManyRequest'AddrToAmountEntry) <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                                                                   (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                                                       Data.ProtoLens.Encoding.Bytes.isolate
                                                                                         (Prelude.fromIntegral
                                                                                            len)
                                                                                         Data.ProtoLens.parseMessage)
                                                                                   "AddrToAmount"
                                (let
                                   key = Lens.Family2.view (Data.ProtoLens.Field.field @"key") entry
                                   value
                                     = Lens.Family2.view (Data.ProtoLens.Field.field @"value") entry
                                 in
                                   loop
                                     (Lens.Family2.over
                                        (Data.ProtoLens.Field.field @"addrToAmount")
                                        (\ !t -> Data.Map.insert key value t) x))
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "target_conf"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"targetConf") y x)
                        32
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "sat_per_vbyte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerVbyte") y x)
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "sat_per_byte"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"satPerByte") y x)
                        50
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "label"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"label") y x)
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "min_confs"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"minConfs") y x)
                        64
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "spend_unconfirmed"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"spendUnconfirmed") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendManyRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.Monoid.mconcat
                (Prelude.map
                   (\ _v
                      -> (Data.Monoid.<>)
                           (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                           ((Prelude..)
                              (\ bs
                                 -> (Data.Monoid.<>)
                                      (Data.ProtoLens.Encoding.Bytes.putVarInt
                                         (Prelude.fromIntegral (Data.ByteString.length bs)))
                                      (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                              Data.ProtoLens.encodeMessage
                              (Lens.Family2.set
                                 (Data.ProtoLens.Field.field @"key") (Prelude.fst _v)
                                 (Lens.Family2.set
                                    (Data.ProtoLens.Field.field @"value") (Prelude.snd _v)
                                    (Data.ProtoLens.defMessage ::
                                       SendManyRequest'AddrToAmountEntry)))))
                   (Data.Map.toList
                      (Lens.Family2.view
                         (Data.ProtoLens.Field.field @"addrToAmount") _x))))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"targetConf") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerVbyte") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 32)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view (Data.ProtoLens.Field.field @"satPerByte") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                      ((Data.Monoid.<>)
                         (let
                            _v = Lens.Family2.view (Data.ProtoLens.Field.field @"label") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 50)
                                  ((Prelude..)
                                     (\ bs
                                        -> (Data.Monoid.<>)
                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                (Prelude.fromIntegral (Data.ByteString.length bs)))
                                             (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                     Data.Text.Encoding.encodeUtf8 _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"minConfs") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"spendUnconfirmed") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 64)
                                        ((Prelude..)
                                           Data.ProtoLens.Encoding.Bytes.putVarInt
                                           (\ b -> if b then 1 else 0) _v))
                               (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                  (Lens.Family2.view Data.ProtoLens.unknownFields _x))))))))
instance Control.DeepSeq.NFData SendManyRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendManyRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendManyRequest'addrToAmount x__)
                (Control.DeepSeq.deepseq
                   (_SendManyRequest'targetConf x__)
                   (Control.DeepSeq.deepseq
                      (_SendManyRequest'satPerVbyte x__)
                      (Control.DeepSeq.deepseq
                         (_SendManyRequest'satPerByte x__)
                         (Control.DeepSeq.deepseq
                            (_SendManyRequest'label x__)
                            (Control.DeepSeq.deepseq
                               (_SendManyRequest'minConfs x__)
                               (Control.DeepSeq.deepseq
                                  (_SendManyRequest'spendUnconfirmed x__) ())))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.key' @:: Lens' SendManyRequest'AddrToAmountEntry Data.Text.Text@
         * 'Proto.Lightning_Fields.value' @:: Lens' SendManyRequest'AddrToAmountEntry Data.Int.Int64@ -}
data SendManyRequest'AddrToAmountEntry
  = SendManyRequest'AddrToAmountEntry'_constructor {_SendManyRequest'AddrToAmountEntry'key :: !Data.Text.Text,
                                                    _SendManyRequest'AddrToAmountEntry'value :: !Data.Int.Int64,
                                                    _SendManyRequest'AddrToAmountEntry'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendManyRequest'AddrToAmountEntry where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendManyRequest'AddrToAmountEntry
instance Data.ProtoLens.Field.HasField SendManyRequest'AddrToAmountEntry "key" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'AddrToAmountEntry'key
           (\ x__ y__ -> x__ {_SendManyRequest'AddrToAmountEntry'key = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendManyRequest'AddrToAmountEntry "value" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyRequest'AddrToAmountEntry'value
           (\ x__ y__
              -> x__ {_SendManyRequest'AddrToAmountEntry'value = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendManyRequest'AddrToAmountEntry where
  messageName _
    = Data.Text.pack "lnrpc.SendManyRequest.AddrToAmountEntry"
  packedMessageDescriptor _
    = "\n\
      \\DC1AddrToAmountEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\tR\ETXkey\DC2\DC4\n\
      \\ENQvalue\CAN\STX \SOH(\ETXR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        key__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"key")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest'AddrToAmountEntry
        value__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "value"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"value")) ::
              Data.ProtoLens.FieldDescriptor SendManyRequest'AddrToAmountEntry
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, key__field_descriptor),
           (Data.ProtoLens.Tag 2, value__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendManyRequest'AddrToAmountEntry'_unknownFields
        (\ x__ y__
           -> x__ {_SendManyRequest'AddrToAmountEntry'_unknownFields = y__})
  defMessage
    = SendManyRequest'AddrToAmountEntry'_constructor
        {_SendManyRequest'AddrToAmountEntry'key = Data.ProtoLens.fieldDefault,
         _SendManyRequest'AddrToAmountEntry'value = Data.ProtoLens.fieldDefault,
         _SendManyRequest'AddrToAmountEntry'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendManyRequest'AddrToAmountEntry
          -> Data.ProtoLens.Encoding.Bytes.Parser SendManyRequest'AddrToAmountEntry
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"key") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "value"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"value") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "AddrToAmountEntry"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"key") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"value") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData SendManyRequest'AddrToAmountEntry where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendManyRequest'AddrToAmountEntry'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendManyRequest'AddrToAmountEntry'key x__)
                (Control.DeepSeq.deepseq
                   (_SendManyRequest'AddrToAmountEntry'value x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.txid' @:: Lens' SendManyResponse Data.Text.Text@ -}
data SendManyResponse
  = SendManyResponse'_constructor {_SendManyResponse'txid :: !Data.Text.Text,
                                   _SendManyResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendManyResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendManyResponse
instance Data.ProtoLens.Field.HasField SendManyResponse "txid" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendManyResponse'txid
           (\ x__ y__ -> x__ {_SendManyResponse'txid = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendManyResponse where
  messageName _ = Data.Text.pack "lnrpc.SendManyResponse"
  packedMessageDescriptor _
    = "\n\
      \\DLESendManyResponse\DC2\DC2\n\
      \\EOTtxid\CAN\SOH \SOH(\tR\EOTtxid"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        txid__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "txid"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"txid")) ::
              Data.ProtoLens.FieldDescriptor SendManyResponse
      in
        Data.Map.fromList [(Data.ProtoLens.Tag 1, txid__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendManyResponse'_unknownFields
        (\ x__ y__ -> x__ {_SendManyResponse'_unknownFields = y__})
  defMessage
    = SendManyResponse'_constructor
        {_SendManyResponse'txid = Data.ProtoLens.fieldDefault,
         _SendManyResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendManyResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser SendManyResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "txid"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"txid") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendManyResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"txid") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData SendManyResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendManyResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_SendManyResponse'txid x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.dest' @:: Lens' SendRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.destString' @:: Lens' SendRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.amt' @:: Lens' SendRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.amtMsat' @:: Lens' SendRequest Data.Int.Int64@
         * 'Proto.Lightning_Fields.paymentHash' @:: Lens' SendRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.paymentHashString' @:: Lens' SendRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.paymentRequest' @:: Lens' SendRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.finalCltvDelta' @:: Lens' SendRequest Data.Int.Int32@
         * 'Proto.Lightning_Fields.feeLimit' @:: Lens' SendRequest Proto.Lnrpc.Ln0.FeeLimit@
         * 'Proto.Lightning_Fields.maybe'feeLimit' @:: Lens' SendRequest (Prelude.Maybe Proto.Lnrpc.Ln0.FeeLimit)@
         * 'Proto.Lightning_Fields.outgoingChanId' @:: Lens' SendRequest Data.Word.Word64@
         * 'Proto.Lightning_Fields.lastHopPubkey' @:: Lens' SendRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.cltvLimit' @:: Lens' SendRequest Data.Word.Word32@
         * 'Proto.Lightning_Fields.destCustomRecords' @:: Lens' SendRequest (Data.Map.Map Data.Word.Word64 Data.ByteString.ByteString)@
         * 'Proto.Lightning_Fields.allowSelfPayment' @:: Lens' SendRequest Prelude.Bool@
         * 'Proto.Lightning_Fields.destFeatures' @:: Lens' SendRequest [Proto.Lnrpc.Ln0.FeatureBit]@
         * 'Proto.Lightning_Fields.vec'destFeatures' @:: Lens' SendRequest (Data.Vector.Vector Proto.Lnrpc.Ln0.FeatureBit)@
         * 'Proto.Lightning_Fields.paymentAddr' @:: Lens' SendRequest Data.ByteString.ByteString@ -}
data SendRequest
  = SendRequest'_constructor {_SendRequest'dest :: !Data.ByteString.ByteString,
                              _SendRequest'destString :: !Data.Text.Text,
                              _SendRequest'amt :: !Data.Int.Int64,
                              _SendRequest'amtMsat :: !Data.Int.Int64,
                              _SendRequest'paymentHash :: !Data.ByteString.ByteString,
                              _SendRequest'paymentHashString :: !Data.Text.Text,
                              _SendRequest'paymentRequest :: !Data.Text.Text,
                              _SendRequest'finalCltvDelta :: !Data.Int.Int32,
                              _SendRequest'feeLimit :: !(Prelude.Maybe Proto.Lnrpc.Ln0.FeeLimit),
                              _SendRequest'outgoingChanId :: !Data.Word.Word64,
                              _SendRequest'lastHopPubkey :: !Data.ByteString.ByteString,
                              _SendRequest'cltvLimit :: !Data.Word.Word32,
                              _SendRequest'destCustomRecords :: !(Data.Map.Map Data.Word.Word64 Data.ByteString.ByteString),
                              _SendRequest'allowSelfPayment :: !Prelude.Bool,
                              _SendRequest'destFeatures :: !(Data.Vector.Vector Proto.Lnrpc.Ln0.FeatureBit),
                              _SendRequest'paymentAddr :: !Data.ByteString.ByteString,
                              _SendRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendRequest
instance Data.ProtoLens.Field.HasField SendRequest "dest" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'dest (\ x__ y__ -> x__ {_SendRequest'dest = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "destString" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'destString
           (\ x__ y__ -> x__ {_SendRequest'destString = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "amt" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'amt (\ x__ y__ -> x__ {_SendRequest'amt = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "amtMsat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'amtMsat
           (\ x__ y__ -> x__ {_SendRequest'amtMsat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "paymentHash" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'paymentHash
           (\ x__ y__ -> x__ {_SendRequest'paymentHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "paymentHashString" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'paymentHashString
           (\ x__ y__ -> x__ {_SendRequest'paymentHashString = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "paymentRequest" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'paymentRequest
           (\ x__ y__ -> x__ {_SendRequest'paymentRequest = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "finalCltvDelta" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'finalCltvDelta
           (\ x__ y__ -> x__ {_SendRequest'finalCltvDelta = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "feeLimit" Proto.Lnrpc.Ln0.FeeLimit where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'feeLimit
           (\ x__ y__ -> x__ {_SendRequest'feeLimit = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField SendRequest "maybe'feeLimit" (Prelude.Maybe Proto.Lnrpc.Ln0.FeeLimit) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'feeLimit
           (\ x__ y__ -> x__ {_SendRequest'feeLimit = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "outgoingChanId" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'outgoingChanId
           (\ x__ y__ -> x__ {_SendRequest'outgoingChanId = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "lastHopPubkey" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'lastHopPubkey
           (\ x__ y__ -> x__ {_SendRequest'lastHopPubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "cltvLimit" Data.Word.Word32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'cltvLimit
           (\ x__ y__ -> x__ {_SendRequest'cltvLimit = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "destCustomRecords" (Data.Map.Map Data.Word.Word64 Data.ByteString.ByteString) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'destCustomRecords
           (\ x__ y__ -> x__ {_SendRequest'destCustomRecords = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "allowSelfPayment" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'allowSelfPayment
           (\ x__ y__ -> x__ {_SendRequest'allowSelfPayment = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "destFeatures" [Proto.Lnrpc.Ln0.FeatureBit] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'destFeatures
           (\ x__ y__ -> x__ {_SendRequest'destFeatures = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField SendRequest "vec'destFeatures" (Data.Vector.Vector Proto.Lnrpc.Ln0.FeatureBit) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'destFeatures
           (\ x__ y__ -> x__ {_SendRequest'destFeatures = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest "paymentAddr" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'paymentAddr
           (\ x__ y__ -> x__ {_SendRequest'paymentAddr = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendRequest where
  messageName _ = Data.Text.pack "lnrpc.SendRequest"
  packedMessageDescriptor _
    = "\n\
      \\vSendRequest\DC2\DC2\n\
      \\EOTdest\CAN\SOH \SOH(\fR\EOTdest\DC2#\n\
      \\vdest_string\CAN\STX \SOH(\tR\n\
      \destStringB\STX\CAN\SOH\DC2\DLE\n\
      \\ETXamt\CAN\ETX \SOH(\ETXR\ETXamt\DC2\EM\n\
      \\bamt_msat\CAN\f \SOH(\ETXR\aamtMsat\DC2!\n\
      \\fpayment_hash\CAN\EOT \SOH(\fR\vpaymentHash\DC22\n\
      \\DC3payment_hash_string\CAN\ENQ \SOH(\tR\DC1paymentHashStringB\STX\CAN\SOH\DC2'\n\
      \\SIpayment_request\CAN\ACK \SOH(\tR\SOpaymentRequest\DC2(\n\
      \\DLEfinal_cltv_delta\CAN\a \SOH(\ENQR\SOfinalCltvDelta\DC2,\n\
      \\tfee_limit\CAN\b \SOH(\v2\SI.lnrpc.FeeLimitR\bfeeLimit\DC2,\n\
      \\DLEoutgoing_chan_id\CAN\t \SOH(\EOTR\SOoutgoingChanIdB\STX0\SOH\DC2&\n\
      \\SIlast_hop_pubkey\CAN\r \SOH(\fR\rlastHopPubkey\DC2\GS\n\
      \\n\
      \cltv_limit\CAN\n\
      \ \SOH(\rR\tcltvLimit\DC2Y\n\
      \\DC3dest_custom_records\CAN\v \ETX(\v2).lnrpc.SendRequest.DestCustomRecordsEntryR\DC1destCustomRecords\DC2,\n\
      \\DC2allow_self_payment\CAN\SO \SOH(\bR\DLEallowSelfPayment\DC26\n\
      \\rdest_features\CAN\SI \ETX(\SO2\DC1.lnrpc.FeatureBitR\fdestFeatures\DC2!\n\
      \\fpayment_addr\CAN\DLE \SOH(\fR\vpaymentAddr\SUBD\n\
      \\SYNDestCustomRecordsEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\EOTR\ETXkey\DC2\DC4\n\
      \\ENQvalue\CAN\STX \SOH(\fR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        dest__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "dest"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"dest")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        destString__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "dest_string"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"destString")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        amt__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "amt"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"amt")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        amtMsat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "amt_msat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"amtMsat")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        paymentHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentHash")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        paymentHashString__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_hash_string"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentHashString")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        paymentRequest__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_request"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentRequest")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        finalCltvDelta__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "final_cltv_delta"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"finalCltvDelta")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        feeLimit__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "fee_limit"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.FeeLimit)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'feeLimit")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        outgoingChanId__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "outgoing_chan_id"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"outgoingChanId")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        lastHopPubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "last_hop_pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"lastHopPubkey")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        cltvLimit__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "cltv_limit"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"cltvLimit")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        destCustomRecords__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "dest_custom_records"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor SendRequest'DestCustomRecordsEntry)
              (Data.ProtoLens.MapField
                 (Data.ProtoLens.Field.field @"key")
                 (Data.ProtoLens.Field.field @"value")
                 (Data.ProtoLens.Field.field @"destCustomRecords")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        allowSelfPayment__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "allow_self_payment"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"allowSelfPayment")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        destFeatures__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "dest_features"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.FeatureBit)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Packed
                 (Data.ProtoLens.Field.field @"destFeatures")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
        paymentAddr__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_addr"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentAddr")) ::
              Data.ProtoLens.FieldDescriptor SendRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, dest__field_descriptor),
           (Data.ProtoLens.Tag 2, destString__field_descriptor),
           (Data.ProtoLens.Tag 3, amt__field_descriptor),
           (Data.ProtoLens.Tag 12, amtMsat__field_descriptor),
           (Data.ProtoLens.Tag 4, paymentHash__field_descriptor),
           (Data.ProtoLens.Tag 5, paymentHashString__field_descriptor),
           (Data.ProtoLens.Tag 6, paymentRequest__field_descriptor),
           (Data.ProtoLens.Tag 7, finalCltvDelta__field_descriptor),
           (Data.ProtoLens.Tag 8, feeLimit__field_descriptor),
           (Data.ProtoLens.Tag 9, outgoingChanId__field_descriptor),
           (Data.ProtoLens.Tag 13, lastHopPubkey__field_descriptor),
           (Data.ProtoLens.Tag 10, cltvLimit__field_descriptor),
           (Data.ProtoLens.Tag 11, destCustomRecords__field_descriptor),
           (Data.ProtoLens.Tag 14, allowSelfPayment__field_descriptor),
           (Data.ProtoLens.Tag 15, destFeatures__field_descriptor),
           (Data.ProtoLens.Tag 16, paymentAddr__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendRequest'_unknownFields
        (\ x__ y__ -> x__ {_SendRequest'_unknownFields = y__})
  defMessage
    = SendRequest'_constructor
        {_SendRequest'dest = Data.ProtoLens.fieldDefault,
         _SendRequest'destString = Data.ProtoLens.fieldDefault,
         _SendRequest'amt = Data.ProtoLens.fieldDefault,
         _SendRequest'amtMsat = Data.ProtoLens.fieldDefault,
         _SendRequest'paymentHash = Data.ProtoLens.fieldDefault,
         _SendRequest'paymentHashString = Data.ProtoLens.fieldDefault,
         _SendRequest'paymentRequest = Data.ProtoLens.fieldDefault,
         _SendRequest'finalCltvDelta = Data.ProtoLens.fieldDefault,
         _SendRequest'feeLimit = Prelude.Nothing,
         _SendRequest'outgoingChanId = Data.ProtoLens.fieldDefault,
         _SendRequest'lastHopPubkey = Data.ProtoLens.fieldDefault,
         _SendRequest'cltvLimit = Data.ProtoLens.fieldDefault,
         _SendRequest'destCustomRecords = Data.Map.empty,
         _SendRequest'allowSelfPayment = Data.ProtoLens.fieldDefault,
         _SendRequest'destFeatures = Data.Vector.Generic.empty,
         _SendRequest'paymentAddr = Data.ProtoLens.fieldDefault,
         _SendRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendRequest
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Proto.Lnrpc.Ln0.FeatureBit
             -> Data.ProtoLens.Encoding.Bytes.Parser SendRequest
        loop x mutable'destFeatures
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'destFeatures <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                               (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                                  mutable'destFeatures)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'destFeatures")
                              frozen'destFeatures x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "dest"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"dest") y x)
                                  mutable'destFeatures
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "dest_string"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"destString") y x)
                                  mutable'destFeatures
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "amt"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"amt") y x)
                                  mutable'destFeatures
                        96
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "amt_msat"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"amtMsat") y x)
                                  mutable'destFeatures
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "payment_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"paymentHash") y x)
                                  mutable'destFeatures
                        42
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "payment_hash_string"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"paymentHashString") y x)
                                  mutable'destFeatures
                        50
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "payment_request"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"paymentRequest") y x)
                                  mutable'destFeatures
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "final_cltv_delta"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"finalCltvDelta") y x)
                                  mutable'destFeatures
                        66
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "fee_limit"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"feeLimit") y x)
                                  mutable'destFeatures
                        72
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "outgoing_chan_id"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"outgoingChanId") y x)
                                  mutable'destFeatures
                        106
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "last_hop_pubkey"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"lastHopPubkey") y x)
                                  mutable'destFeatures
                        80
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "cltv_limit"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"cltvLimit") y x)
                                  mutable'destFeatures
                        90
                          -> do !(entry :: SendRequest'DestCustomRecordsEntry) <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                                                                    (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                                                        Data.ProtoLens.Encoding.Bytes.isolate
                                                                                          (Prelude.fromIntegral
                                                                                             len)
                                                                                          Data.ProtoLens.parseMessage)
                                                                                    "dest_custom_records"
                                (let
                                   key = Lens.Family2.view (Data.ProtoLens.Field.field @"key") entry
                                   value
                                     = Lens.Family2.view (Data.ProtoLens.Field.field @"value") entry
                                 in
                                   loop
                                     (Lens.Family2.over
                                        (Data.ProtoLens.Field.field @"destCustomRecords")
                                        (\ !t -> Data.Map.insert key value t) x)
                                     mutable'destFeatures)
                        112
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "allow_self_payment"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"allowSelfPayment") y x)
                                  mutable'destFeatures
                        120
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (Prelude.fmap
                                           Prelude.toEnum
                                           (Prelude.fmap
                                              Prelude.fromIntegral
                                              Data.ProtoLens.Encoding.Bytes.getVarInt))
                                        "dest_features"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append
                                          mutable'destFeatures y)
                                loop x v
                        122
                          -> do y <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                        Data.ProtoLens.Encoding.Bytes.isolate
                                          (Prelude.fromIntegral len)
                                          ((let
                                              ploop qs
                                                = do packedEnd <- Data.ProtoLens.Encoding.Bytes.atEnd
                                                     if packedEnd then
                                                         Prelude.return qs
                                                     else
                                                         do !q <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                                                    (Prelude.fmap
                                                                       Prelude.toEnum
                                                                       (Prelude.fmap
                                                                          Prelude.fromIntegral
                                                                          Data.ProtoLens.Encoding.Bytes.getVarInt))
                                                                    "dest_features"
                                                            qs' <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                                                     (Data.ProtoLens.Encoding.Growing.append
                                                                        qs q)
                                                            ploop qs'
                                            in ploop)
                                             mutable'destFeatures)
                                loop x y
                        130
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "payment_addr"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"paymentAddr") y x)
                                  mutable'destFeatures
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'destFeatures
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'destFeatures <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                        Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'destFeatures)
          "SendRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"dest") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"destString") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                ((Data.Monoid.<>)
                   (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"amt") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"amtMsat") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 96)
                               ((Prelude..)
                                  Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view (Data.ProtoLens.Field.field @"paymentHash") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                                  ((\ bs
                                      -> (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt
                                              (Prelude.fromIntegral (Data.ByteString.length bs)))
                                           (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view
                                     (Data.ProtoLens.Field.field @"paymentHashString") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 42)
                                     ((Prelude..)
                                        (\ bs
                                           -> (Data.Monoid.<>)
                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                   (Prelude.fromIntegral
                                                      (Data.ByteString.length bs)))
                                                (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                        Data.Text.Encoding.encodeUtf8 _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"paymentRequest") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 50)
                                        ((Prelude..)
                                           (\ bs
                                              -> (Data.Monoid.<>)
                                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                      (Prelude.fromIntegral
                                                         (Data.ByteString.length bs)))
                                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                           Data.Text.Encoding.encodeUtf8 _v))
                               ((Data.Monoid.<>)
                                  (let
                                     _v
                                       = Lens.Family2.view
                                           (Data.ProtoLens.Field.field @"finalCltvDelta") _x
                                   in
                                     if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                         Data.Monoid.mempty
                                     else
                                         (Data.Monoid.<>)
                                           (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                           ((Prelude..)
                                              Data.ProtoLens.Encoding.Bytes.putVarInt
                                              Prelude.fromIntegral _v))
                                  ((Data.Monoid.<>)
                                     (case
                                          Lens.Family2.view
                                            (Data.ProtoLens.Field.field @"maybe'feeLimit") _x
                                      of
                                        Prelude.Nothing -> Data.Monoid.mempty
                                        (Prelude.Just _v)
                                          -> (Data.Monoid.<>)
                                               (Data.ProtoLens.Encoding.Bytes.putVarInt 66)
                                               ((Prelude..)
                                                  (\ bs
                                                     -> (Data.Monoid.<>)
                                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                             (Prelude.fromIntegral
                                                                (Data.ByteString.length bs)))
                                                          (Data.ProtoLens.Encoding.Bytes.putBytes
                                                             bs))
                                                  Data.ProtoLens.encodeMessage _v))
                                     ((Data.Monoid.<>)
                                        (let
                                           _v
                                             = Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"outgoingChanId") _x
                                         in
                                           if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                               Data.Monoid.mempty
                                           else
                                               (Data.Monoid.<>)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt 72)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
                                        ((Data.Monoid.<>)
                                           (let
                                              _v
                                                = Lens.Family2.view
                                                    (Data.ProtoLens.Field.field @"lastHopPubkey") _x
                                            in
                                              if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                  Data.Monoid.mempty
                                              else
                                                  (Data.Monoid.<>)
                                                    (Data.ProtoLens.Encoding.Bytes.putVarInt 106)
                                                    ((\ bs
                                                        -> (Data.Monoid.<>)
                                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                (Prelude.fromIntegral
                                                                   (Data.ByteString.length bs)))
                                                             (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                bs))
                                                       _v))
                                           ((Data.Monoid.<>)
                                              (let
                                                 _v
                                                   = Lens.Family2.view
                                                       (Data.ProtoLens.Field.field @"cltvLimit") _x
                                               in
                                                 if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                                     Data.Monoid.mempty
                                                 else
                                                     (Data.Monoid.<>)
                                                       (Data.ProtoLens.Encoding.Bytes.putVarInt 80)
                                                       ((Prelude..)
                                                          Data.ProtoLens.Encoding.Bytes.putVarInt
                                                          Prelude.fromIntegral _v))
                                              ((Data.Monoid.<>)
                                                 (Data.Monoid.mconcat
                                                    (Prelude.map
                                                       (\ _v
                                                          -> (Data.Monoid.<>)
                                                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                  90)
                                                               ((Prelude..)
                                                                  (\ bs
                                                                     -> (Data.Monoid.<>)
                                                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                             (Prelude.fromIntegral
                                                                                (Data.ByteString.length
                                                                                   bs)))
                                                                          (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                             bs))
                                                                  Data.ProtoLens.encodeMessage
                                                                  (Lens.Family2.set
                                                                     (Data.ProtoLens.Field.field
                                                                        @"key")
                                                                     (Prelude.fst _v)
                                                                     (Lens.Family2.set
                                                                        (Data.ProtoLens.Field.field
                                                                           @"value")
                                                                        (Prelude.snd _v)
                                                                        (Data.ProtoLens.defMessage ::
                                                                           SendRequest'DestCustomRecordsEntry)))))
                                                       (Data.Map.toList
                                                          (Lens.Family2.view
                                                             (Data.ProtoLens.Field.field
                                                                @"destCustomRecords")
                                                             _x))))
                                                 ((Data.Monoid.<>)
                                                    (let
                                                       _v
                                                         = Lens.Family2.view
                                                             (Data.ProtoLens.Field.field
                                                                @"allowSelfPayment")
                                                             _x
                                                     in
                                                       if (Prelude.==)
                                                            _v Data.ProtoLens.fieldDefault then
                                                           Data.Monoid.mempty
                                                       else
                                                           (Data.Monoid.<>)
                                                             (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                112)
                                                             ((Prelude..)
                                                                Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                (\ b -> if b then 1 else 0) _v))
                                                    ((Data.Monoid.<>)
                                                       (let
                                                          p = Lens.Family2.view
                                                                (Data.ProtoLens.Field.field
                                                                   @"vec'destFeatures")
                                                                _x
                                                        in
                                                          if Data.Vector.Generic.null p then
                                                              Data.Monoid.mempty
                                                          else
                                                              (Data.Monoid.<>)
                                                                (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                   122)
                                                                ((\ bs
                                                                    -> (Data.Monoid.<>)
                                                                         (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                            (Prelude.fromIntegral
                                                                               (Data.ByteString.length
                                                                                  bs)))
                                                                         (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                            bs))
                                                                   (Data.ProtoLens.Encoding.Bytes.runBuilder
                                                                      (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                                                                         ((Prelude..)
                                                                            ((Prelude..)
                                                                               Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                               Prelude.fromIntegral)
                                                                            Prelude.fromEnum)
                                                                         p))))
                                                       ((Data.Monoid.<>)
                                                          (let
                                                             _v
                                                               = Lens.Family2.view
                                                                   (Data.ProtoLens.Field.field
                                                                      @"paymentAddr")
                                                                   _x
                                                           in
                                                             if (Prelude.==)
                                                                  _v
                                                                  Data.ProtoLens.fieldDefault then
                                                                 Data.Monoid.mempty
                                                             else
                                                                 (Data.Monoid.<>)
                                                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                      130)
                                                                   ((\ bs
                                                                       -> (Data.Monoid.<>)
                                                                            (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                                               (Prelude.fromIntegral
                                                                                  (Data.ByteString.length
                                                                                     bs)))
                                                                            (Data.ProtoLens.Encoding.Bytes.putBytes
                                                                               bs))
                                                                      _v))
                                                          (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                                             (Lens.Family2.view
                                                                Data.ProtoLens.unknownFields
                                                                _x)))))))))))))))))
instance Control.DeepSeq.NFData SendRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendRequest'dest x__)
                (Control.DeepSeq.deepseq
                   (_SendRequest'destString x__)
                   (Control.DeepSeq.deepseq
                      (_SendRequest'amt x__)
                      (Control.DeepSeq.deepseq
                         (_SendRequest'amtMsat x__)
                         (Control.DeepSeq.deepseq
                            (_SendRequest'paymentHash x__)
                            (Control.DeepSeq.deepseq
                               (_SendRequest'paymentHashString x__)
                               (Control.DeepSeq.deepseq
                                  (_SendRequest'paymentRequest x__)
                                  (Control.DeepSeq.deepseq
                                     (_SendRequest'finalCltvDelta x__)
                                     (Control.DeepSeq.deepseq
                                        (_SendRequest'feeLimit x__)
                                        (Control.DeepSeq.deepseq
                                           (_SendRequest'outgoingChanId x__)
                                           (Control.DeepSeq.deepseq
                                              (_SendRequest'lastHopPubkey x__)
                                              (Control.DeepSeq.deepseq
                                                 (_SendRequest'cltvLimit x__)
                                                 (Control.DeepSeq.deepseq
                                                    (_SendRequest'destCustomRecords x__)
                                                    (Control.DeepSeq.deepseq
                                                       (_SendRequest'allowSelfPayment x__)
                                                       (Control.DeepSeq.deepseq
                                                          (_SendRequest'destFeatures x__)
                                                          (Control.DeepSeq.deepseq
                                                             (_SendRequest'paymentAddr x__)
                                                             ()))))))))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.key' @:: Lens' SendRequest'DestCustomRecordsEntry Data.Word.Word64@
         * 'Proto.Lightning_Fields.value' @:: Lens' SendRequest'DestCustomRecordsEntry Data.ByteString.ByteString@ -}
data SendRequest'DestCustomRecordsEntry
  = SendRequest'DestCustomRecordsEntry'_constructor {_SendRequest'DestCustomRecordsEntry'key :: !Data.Word.Word64,
                                                     _SendRequest'DestCustomRecordsEntry'value :: !Data.ByteString.ByteString,
                                                     _SendRequest'DestCustomRecordsEntry'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendRequest'DestCustomRecordsEntry where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendRequest'DestCustomRecordsEntry
instance Data.ProtoLens.Field.HasField SendRequest'DestCustomRecordsEntry "key" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'DestCustomRecordsEntry'key
           (\ x__ y__ -> x__ {_SendRequest'DestCustomRecordsEntry'key = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendRequest'DestCustomRecordsEntry "value" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendRequest'DestCustomRecordsEntry'value
           (\ x__ y__
              -> x__ {_SendRequest'DestCustomRecordsEntry'value = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendRequest'DestCustomRecordsEntry where
  messageName _
    = Data.Text.pack "lnrpc.SendRequest.DestCustomRecordsEntry"
  packedMessageDescriptor _
    = "\n\
      \\SYNDestCustomRecordsEntry\DC2\DLE\n\
      \\ETXkey\CAN\SOH \SOH(\EOTR\ETXkey\DC2\DC4\n\
      \\ENQvalue\CAN\STX \SOH(\fR\ENQvalue:\STX8\SOH"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        key__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "key"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"key")) ::
              Data.ProtoLens.FieldDescriptor SendRequest'DestCustomRecordsEntry
        value__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "value"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"value")) ::
              Data.ProtoLens.FieldDescriptor SendRequest'DestCustomRecordsEntry
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, key__field_descriptor),
           (Data.ProtoLens.Tag 2, value__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendRequest'DestCustomRecordsEntry'_unknownFields
        (\ x__ y__
           -> x__ {_SendRequest'DestCustomRecordsEntry'_unknownFields = y__})
  defMessage
    = SendRequest'DestCustomRecordsEntry'_constructor
        {_SendRequest'DestCustomRecordsEntry'key = Data.ProtoLens.fieldDefault,
         _SendRequest'DestCustomRecordsEntry'value = Data.ProtoLens.fieldDefault,
         _SendRequest'DestCustomRecordsEntry'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendRequest'DestCustomRecordsEntry
          -> Data.ProtoLens.Encoding.Bytes.Parser SendRequest'DestCustomRecordsEntry
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "key"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"key") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "value"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"value") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "DestCustomRecordsEntry"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"key") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"value") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData SendRequest'DestCustomRecordsEntry where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendRequest'DestCustomRecordsEntry'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendRequest'DestCustomRecordsEntry'key x__)
                (Control.DeepSeq.deepseq
                   (_SendRequest'DestCustomRecordsEntry'value x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.paymentError' @:: Lens' SendResponse Data.Text.Text@
         * 'Proto.Lightning_Fields.paymentPreimage' @:: Lens' SendResponse Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.paymentRoute' @:: Lens' SendResponse Proto.Lnrpc.Ln0.Route@
         * 'Proto.Lightning_Fields.maybe'paymentRoute' @:: Lens' SendResponse (Prelude.Maybe Proto.Lnrpc.Ln0.Route)@
         * 'Proto.Lightning_Fields.paymentHash' @:: Lens' SendResponse Data.ByteString.ByteString@ -}
data SendResponse
  = SendResponse'_constructor {_SendResponse'paymentError :: !Data.Text.Text,
                               _SendResponse'paymentPreimage :: !Data.ByteString.ByteString,
                               _SendResponse'paymentRoute :: !(Prelude.Maybe Proto.Lnrpc.Ln0.Route),
                               _SendResponse'paymentHash :: !Data.ByteString.ByteString,
                               _SendResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendResponse
instance Data.ProtoLens.Field.HasField SendResponse "paymentError" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendResponse'paymentError
           (\ x__ y__ -> x__ {_SendResponse'paymentError = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendResponse "paymentPreimage" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendResponse'paymentPreimage
           (\ x__ y__ -> x__ {_SendResponse'paymentPreimage = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendResponse "paymentRoute" Proto.Lnrpc.Ln0.Route where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendResponse'paymentRoute
           (\ x__ y__ -> x__ {_SendResponse'paymentRoute = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField SendResponse "maybe'paymentRoute" (Prelude.Maybe Proto.Lnrpc.Ln0.Route) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendResponse'paymentRoute
           (\ x__ y__ -> x__ {_SendResponse'paymentRoute = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendResponse "paymentHash" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendResponse'paymentHash
           (\ x__ y__ -> x__ {_SendResponse'paymentHash = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendResponse where
  messageName _ = Data.Text.pack "lnrpc.SendResponse"
  packedMessageDescriptor _
    = "\n\
      \\fSendResponse\DC2#\n\
      \\rpayment_error\CAN\SOH \SOH(\tR\fpaymentError\DC2)\n\
      \\DLEpayment_preimage\CAN\STX \SOH(\fR\SIpaymentPreimage\DC21\n\
      \\rpayment_route\CAN\ETX \SOH(\v2\f.lnrpc.RouteR\fpaymentRoute\DC2!\n\
      \\fpayment_hash\CAN\EOT \SOH(\fR\vpaymentHash"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        paymentError__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_error"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentError")) ::
              Data.ProtoLens.FieldDescriptor SendResponse
        paymentPreimage__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_preimage"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentPreimage")) ::
              Data.ProtoLens.FieldDescriptor SendResponse
        paymentRoute__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_route"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.Route)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'paymentRoute")) ::
              Data.ProtoLens.FieldDescriptor SendResponse
        paymentHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentHash")) ::
              Data.ProtoLens.FieldDescriptor SendResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, paymentError__field_descriptor),
           (Data.ProtoLens.Tag 2, paymentPreimage__field_descriptor),
           (Data.ProtoLens.Tag 3, paymentRoute__field_descriptor),
           (Data.ProtoLens.Tag 4, paymentHash__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendResponse'_unknownFields
        (\ x__ y__ -> x__ {_SendResponse'_unknownFields = y__})
  defMessage
    = SendResponse'_constructor
        {_SendResponse'paymentError = Data.ProtoLens.fieldDefault,
         _SendResponse'paymentPreimage = Data.ProtoLens.fieldDefault,
         _SendResponse'paymentRoute = Prelude.Nothing,
         _SendResponse'paymentHash = Data.ProtoLens.fieldDefault,
         _SendResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendResponse -> Data.ProtoLens.Encoding.Bytes.Parser SendResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "payment_error"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"paymentError") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "payment_preimage"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"paymentPreimage") y x)
                        26
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "payment_route"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"paymentRoute") y x)
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "payment_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"paymentHash") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"paymentError") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"paymentPreimage") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((\ bs
                             -> (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt
                                     (Prelude.fromIntegral (Data.ByteString.length bs)))
                                  (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            _v))
                ((Data.Monoid.<>)
                   (case
                        Lens.Family2.view
                          (Data.ProtoLens.Field.field @"maybe'paymentRoute") _x
                    of
                      Prelude.Nothing -> Data.Monoid.mempty
                      (Prelude.Just _v)
                        -> (Data.Monoid.<>)
                             (Data.ProtoLens.Encoding.Bytes.putVarInt 26)
                             ((Prelude..)
                                (\ bs
                                   -> (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt
                                           (Prelude.fromIntegral (Data.ByteString.length bs)))
                                        (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                Data.ProtoLens.encodeMessage _v))
                   ((Data.Monoid.<>)
                      (let
                         _v
                           = Lens.Family2.view (Data.ProtoLens.Field.field @"paymentHash") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                               ((\ bs
                                   -> (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt
                                           (Prelude.fromIntegral (Data.ByteString.length bs)))
                                        (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                  _v))
                      (Data.ProtoLens.Encoding.Wire.buildFieldSet
                         (Lens.Family2.view Data.ProtoLens.unknownFields _x)))))
instance Control.DeepSeq.NFData SendResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendResponse'paymentError x__)
                (Control.DeepSeq.deepseq
                   (_SendResponse'paymentPreimage x__)
                   (Control.DeepSeq.deepseq
                      (_SendResponse'paymentRoute x__)
                      (Control.DeepSeq.deepseq (_SendResponse'paymentHash x__) ()))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.paymentHash' @:: Lens' SendToRouteRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.paymentHashString' @:: Lens' SendToRouteRequest Data.Text.Text@
         * 'Proto.Lightning_Fields.route' @:: Lens' SendToRouteRequest Proto.Lnrpc.Ln0.Route@
         * 'Proto.Lightning_Fields.maybe'route' @:: Lens' SendToRouteRequest (Prelude.Maybe Proto.Lnrpc.Ln0.Route)@ -}
data SendToRouteRequest
  = SendToRouteRequest'_constructor {_SendToRouteRequest'paymentHash :: !Data.ByteString.ByteString,
                                     _SendToRouteRequest'paymentHashString :: !Data.Text.Text,
                                     _SendToRouteRequest'route :: !(Prelude.Maybe Proto.Lnrpc.Ln0.Route),
                                     _SendToRouteRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SendToRouteRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SendToRouteRequest
instance Data.ProtoLens.Field.HasField SendToRouteRequest "paymentHash" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendToRouteRequest'paymentHash
           (\ x__ y__ -> x__ {_SendToRouteRequest'paymentHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendToRouteRequest "paymentHashString" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendToRouteRequest'paymentHashString
           (\ x__ y__ -> x__ {_SendToRouteRequest'paymentHashString = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SendToRouteRequest "route" Proto.Lnrpc.Ln0.Route where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendToRouteRequest'route
           (\ x__ y__ -> x__ {_SendToRouteRequest'route = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField SendToRouteRequest "maybe'route" (Prelude.Maybe Proto.Lnrpc.Ln0.Route) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SendToRouteRequest'route
           (\ x__ y__ -> x__ {_SendToRouteRequest'route = y__}))
        Prelude.id
instance Data.ProtoLens.Message SendToRouteRequest where
  messageName _ = Data.Text.pack "lnrpc.SendToRouteRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC2SendToRouteRequest\DC2!\n\
      \\fpayment_hash\CAN\SOH \SOH(\fR\vpaymentHash\DC22\n\
      \\DC3payment_hash_string\CAN\STX \SOH(\tR\DC1paymentHashStringB\STX\CAN\SOH\DC2\"\n\
      \\ENQroute\CAN\EOT \SOH(\v2\f.lnrpc.RouteR\ENQrouteJ\EOT\b\ETX\DLE\EOT"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        paymentHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentHash")) ::
              Data.ProtoLens.FieldDescriptor SendToRouteRequest
        paymentHashString__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "payment_hash_string"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"paymentHashString")) ::
              Data.ProtoLens.FieldDescriptor SendToRouteRequest
        route__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "route"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.Route)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'route")) ::
              Data.ProtoLens.FieldDescriptor SendToRouteRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, paymentHash__field_descriptor),
           (Data.ProtoLens.Tag 2, paymentHashString__field_descriptor),
           (Data.ProtoLens.Tag 4, route__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SendToRouteRequest'_unknownFields
        (\ x__ y__ -> x__ {_SendToRouteRequest'_unknownFields = y__})
  defMessage
    = SendToRouteRequest'_constructor
        {_SendToRouteRequest'paymentHash = Data.ProtoLens.fieldDefault,
         _SendToRouteRequest'paymentHashString = Data.ProtoLens.fieldDefault,
         _SendToRouteRequest'route = Prelude.Nothing,
         _SendToRouteRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SendToRouteRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser SendToRouteRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "payment_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"paymentHash") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "payment_hash_string"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"paymentHashString") y x)
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "route"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"route") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SendToRouteRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"paymentHash") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view
                         (Data.ProtoLens.Field.field @"paymentHashString") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                ((Data.Monoid.<>)
                   (case
                        Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'route") _x
                    of
                      Prelude.Nothing -> Data.Monoid.mempty
                      (Prelude.Just _v)
                        -> (Data.Monoid.<>)
                             (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                             ((Prelude..)
                                (\ bs
                                   -> (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt
                                           (Prelude.fromIntegral (Data.ByteString.length bs)))
                                        (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                Data.ProtoLens.encodeMessage _v))
                   (Data.ProtoLens.Encoding.Wire.buildFieldSet
                      (Lens.Family2.view Data.ProtoLens.unknownFields _x))))
instance Control.DeepSeq.NFData SendToRouteRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SendToRouteRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SendToRouteRequest'paymentHash x__)
                (Control.DeepSeq.deepseq
                   (_SendToRouteRequest'paymentHashString x__)
                   (Control.DeepSeq.deepseq (_SendToRouteRequest'route x__) ())))
{- | Fields :
     
         * 'Proto.Lightning_Fields.msg' @:: Lens' SignMessageRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.singleHash' @:: Lens' SignMessageRequest Prelude.Bool@ -}
data SignMessageRequest
  = SignMessageRequest'_constructor {_SignMessageRequest'msg :: !Data.ByteString.ByteString,
                                     _SignMessageRequest'singleHash :: !Prelude.Bool,
                                     _SignMessageRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SignMessageRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SignMessageRequest
instance Data.ProtoLens.Field.HasField SignMessageRequest "msg" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SignMessageRequest'msg
           (\ x__ y__ -> x__ {_SignMessageRequest'msg = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField SignMessageRequest "singleHash" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SignMessageRequest'singleHash
           (\ x__ y__ -> x__ {_SignMessageRequest'singleHash = y__}))
        Prelude.id
instance Data.ProtoLens.Message SignMessageRequest where
  messageName _ = Data.Text.pack "lnrpc.SignMessageRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC2SignMessageRequest\DC2\DLE\n\
      \\ETXmsg\CAN\SOH \SOH(\fR\ETXmsg\DC2\US\n\
      \\vsingle_hash\CAN\STX \SOH(\bR\n\
      \singleHash"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        msg__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "msg"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"msg")) ::
              Data.ProtoLens.FieldDescriptor SignMessageRequest
        singleHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "single_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"singleHash")) ::
              Data.ProtoLens.FieldDescriptor SignMessageRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, msg__field_descriptor),
           (Data.ProtoLens.Tag 2, singleHash__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SignMessageRequest'_unknownFields
        (\ x__ y__ -> x__ {_SignMessageRequest'_unknownFields = y__})
  defMessage
    = SignMessageRequest'_constructor
        {_SignMessageRequest'msg = Data.ProtoLens.fieldDefault,
         _SignMessageRequest'singleHash = Data.ProtoLens.fieldDefault,
         _SignMessageRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SignMessageRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser SignMessageRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "msg"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"msg") y x)
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "single_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"singleHash") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SignMessageRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"msg") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v
                     = Lens.Family2.view (Data.ProtoLens.Field.field @"singleHash") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                            _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData SignMessageRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SignMessageRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_SignMessageRequest'msg x__)
                (Control.DeepSeq.deepseq (_SignMessageRequest'singleHash x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.signature' @:: Lens' SignMessageResponse Data.Text.Text@ -}
data SignMessageResponse
  = SignMessageResponse'_constructor {_SignMessageResponse'signature :: !Data.Text.Text,
                                      _SignMessageResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SignMessageResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SignMessageResponse
instance Data.ProtoLens.Field.HasField SignMessageResponse "signature" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _SignMessageResponse'signature
           (\ x__ y__ -> x__ {_SignMessageResponse'signature = y__}))
        Prelude.id
instance Data.ProtoLens.Message SignMessageResponse where
  messageName _ = Data.Text.pack "lnrpc.SignMessageResponse"
  packedMessageDescriptor _
    = "\n\
      \\DC3SignMessageResponse\DC2\FS\n\
      \\tsignature\CAN\SOH \SOH(\tR\tsignature"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        signature__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "signature"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"signature")) ::
              Data.ProtoLens.FieldDescriptor SignMessageResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, signature__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SignMessageResponse'_unknownFields
        (\ x__ y__ -> x__ {_SignMessageResponse'_unknownFields = y__})
  defMessage
    = SignMessageResponse'_constructor
        {_SignMessageResponse'signature = Data.ProtoLens.fieldDefault,
         _SignMessageResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SignMessageResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser SignMessageResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "signature"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"signature") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "SignMessageResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"signature") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData SignMessageResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SignMessageResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq (_SignMessageResponse'signature x__) ())
{- | Fields :
      -}
data SubscribeCustomMessagesRequest
  = SubscribeCustomMessagesRequest'_constructor {_SubscribeCustomMessagesRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show SubscribeCustomMessagesRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out SubscribeCustomMessagesRequest
instance Data.ProtoLens.Message SubscribeCustomMessagesRequest where
  messageName _
    = Data.Text.pack "lnrpc.SubscribeCustomMessagesRequest"
  packedMessageDescriptor _
    = "\n\
      \\RSSubscribeCustomMessagesRequest"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag = let in Data.Map.fromList []
  unknownFields
    = Lens.Family2.Unchecked.lens
        _SubscribeCustomMessagesRequest'_unknownFields
        (\ x__ y__
           -> x__ {_SubscribeCustomMessagesRequest'_unknownFields = y__})
  defMessage
    = SubscribeCustomMessagesRequest'_constructor
        {_SubscribeCustomMessagesRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          SubscribeCustomMessagesRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser SubscribeCustomMessagesRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of {
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x) }
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage)
          "SubscribeCustomMessagesRequest"
  buildMessage
    = \ _x
        -> Data.ProtoLens.Encoding.Wire.buildFieldSet
             (Lens.Family2.view Data.ProtoLens.unknownFields _x)
instance Control.DeepSeq.NFData SubscribeCustomMessagesRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_SubscribeCustomMessagesRequest'_unknownFields x__) ()
{- | Fields :
     
         * 'Proto.Lightning_Fields.timestamp' @:: Lens' TimestampedError Data.Word.Word64@
         * 'Proto.Lightning_Fields.error' @:: Lens' TimestampedError Data.Text.Text@ -}
data TimestampedError
  = TimestampedError'_constructor {_TimestampedError'timestamp :: !Data.Word.Word64,
                                   _TimestampedError'error :: !Data.Text.Text,
                                   _TimestampedError'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show TimestampedError where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out TimestampedError
instance Data.ProtoLens.Field.HasField TimestampedError "timestamp" Data.Word.Word64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _TimestampedError'timestamp
           (\ x__ y__ -> x__ {_TimestampedError'timestamp = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField TimestampedError "error" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _TimestampedError'error
           (\ x__ y__ -> x__ {_TimestampedError'error = y__}))
        Prelude.id
instance Data.ProtoLens.Message TimestampedError where
  messageName _ = Data.Text.pack "lnrpc.TimestampedError"
  packedMessageDescriptor _
    = "\n\
      \\DLETimestampedError\DC2\FS\n\
      \\ttimestamp\CAN\SOH \SOH(\EOTR\ttimestamp\DC2\DC4\n\
      \\ENQerror\CAN\STX \SOH(\tR\ENQerror"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        timestamp__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "timestamp"
              (Data.ProtoLens.ScalarField Data.ProtoLens.UInt64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Word.Word64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"timestamp")) ::
              Data.ProtoLens.FieldDescriptor TimestampedError
        error__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "error"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"error")) ::
              Data.ProtoLens.FieldDescriptor TimestampedError
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, timestamp__field_descriptor),
           (Data.ProtoLens.Tag 2, error__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _TimestampedError'_unknownFields
        (\ x__ y__ -> x__ {_TimestampedError'_unknownFields = y__})
  defMessage
    = TimestampedError'_constructor
        {_TimestampedError'timestamp = Data.ProtoLens.fieldDefault,
         _TimestampedError'error = Data.ProtoLens.fieldDefault,
         _TimestampedError'_unknownFields = []}
  parseMessage
    = let
        loop ::
          TimestampedError
          -> Data.ProtoLens.Encoding.Bytes.Parser TimestampedError
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       Data.ProtoLens.Encoding.Bytes.getVarInt "timestamp"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"timestamp") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "error"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"error") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "TimestampedError"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"timestamp") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"error") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData TimestampedError where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_TimestampedError'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_TimestampedError'timestamp x__)
                (Control.DeepSeq.deepseq (_TimestampedError'error x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.txHash' @:: Lens' Transaction Data.Text.Text@
         * 'Proto.Lightning_Fields.amount' @:: Lens' Transaction Data.Int.Int64@
         * 'Proto.Lightning_Fields.numConfirmations' @:: Lens' Transaction Data.Int.Int32@
         * 'Proto.Lightning_Fields.blockHash' @:: Lens' Transaction Data.Text.Text@
         * 'Proto.Lightning_Fields.blockHeight' @:: Lens' Transaction Data.Int.Int32@
         * 'Proto.Lightning_Fields.timeStamp' @:: Lens' Transaction Data.Int.Int64@
         * 'Proto.Lightning_Fields.totalFees' @:: Lens' Transaction Data.Int.Int64@
         * 'Proto.Lightning_Fields.destAddresses' @:: Lens' Transaction [Data.Text.Text]@
         * 'Proto.Lightning_Fields.vec'destAddresses' @:: Lens' Transaction (Data.Vector.Vector Data.Text.Text)@
         * 'Proto.Lightning_Fields.rawTxHex' @:: Lens' Transaction Data.Text.Text@
         * 'Proto.Lightning_Fields.label' @:: Lens' Transaction Data.Text.Text@ -}
data Transaction
  = Transaction'_constructor {_Transaction'txHash :: !Data.Text.Text,
                              _Transaction'amount :: !Data.Int.Int64,
                              _Transaction'numConfirmations :: !Data.Int.Int32,
                              _Transaction'blockHash :: !Data.Text.Text,
                              _Transaction'blockHeight :: !Data.Int.Int32,
                              _Transaction'timeStamp :: !Data.Int.Int64,
                              _Transaction'totalFees :: !Data.Int.Int64,
                              _Transaction'destAddresses :: !(Data.Vector.Vector Data.Text.Text),
                              _Transaction'rawTxHex :: !Data.Text.Text,
                              _Transaction'label :: !Data.Text.Text,
                              _Transaction'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show Transaction where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out Transaction
instance Data.ProtoLens.Field.HasField Transaction "txHash" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'txHash (\ x__ y__ -> x__ {_Transaction'txHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "amount" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'amount (\ x__ y__ -> x__ {_Transaction'amount = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "numConfirmations" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'numConfirmations
           (\ x__ y__ -> x__ {_Transaction'numConfirmations = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "blockHash" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'blockHash
           (\ x__ y__ -> x__ {_Transaction'blockHash = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "blockHeight" Data.Int.Int32 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'blockHeight
           (\ x__ y__ -> x__ {_Transaction'blockHeight = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "timeStamp" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'timeStamp
           (\ x__ y__ -> x__ {_Transaction'timeStamp = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "totalFees" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'totalFees
           (\ x__ y__ -> x__ {_Transaction'totalFees = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "destAddresses" [Data.Text.Text] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'destAddresses
           (\ x__ y__ -> x__ {_Transaction'destAddresses = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField Transaction "vec'destAddresses" (Data.Vector.Vector Data.Text.Text) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'destAddresses
           (\ x__ y__ -> x__ {_Transaction'destAddresses = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "rawTxHex" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'rawTxHex
           (\ x__ y__ -> x__ {_Transaction'rawTxHex = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Transaction "label" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Transaction'label (\ x__ y__ -> x__ {_Transaction'label = y__}))
        Prelude.id
instance Data.ProtoLens.Message Transaction where
  messageName _ = Data.Text.pack "lnrpc.Transaction"
  packedMessageDescriptor _
    = "\n\
      \\vTransaction\DC2\ETB\n\
      \\atx_hash\CAN\SOH \SOH(\tR\ACKtxHash\DC2\SYN\n\
      \\ACKamount\CAN\STX \SOH(\ETXR\ACKamount\DC2+\n\
      \\DC1num_confirmations\CAN\ETX \SOH(\ENQR\DLEnumConfirmations\DC2\GS\n\
      \\n\
      \block_hash\CAN\EOT \SOH(\tR\tblockHash\DC2!\n\
      \\fblock_height\CAN\ENQ \SOH(\ENQR\vblockHeight\DC2\GS\n\
      \\n\
      \time_stamp\CAN\ACK \SOH(\ETXR\ttimeStamp\DC2\GS\n\
      \\n\
      \total_fees\CAN\a \SOH(\ETXR\ttotalFees\DC2%\n\
      \\SOdest_addresses\CAN\b \ETX(\tR\rdestAddresses\DC2\FS\n\
      \\n\
      \raw_tx_hex\CAN\t \SOH(\tR\brawTxHex\DC2\DC4\n\
      \\ENQlabel\CAN\n\
      \ \SOH(\tR\ENQlabel"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        txHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "tx_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"txHash")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        amount__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "amount"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"amount")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        numConfirmations__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "num_confirmations"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"numConfirmations")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        blockHash__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "block_hash"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"blockHash")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        blockHeight__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "block_height"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int32Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int32)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"blockHeight")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        timeStamp__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "time_stamp"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"timeStamp")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        totalFees__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "total_fees"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"totalFees")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        destAddresses__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "dest_addresses"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked
                 (Data.ProtoLens.Field.field @"destAddresses")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        rawTxHex__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "raw_tx_hex"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"rawTxHex")) ::
              Data.ProtoLens.FieldDescriptor Transaction
        label__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "label"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"label")) ::
              Data.ProtoLens.FieldDescriptor Transaction
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, txHash__field_descriptor),
           (Data.ProtoLens.Tag 2, amount__field_descriptor),
           (Data.ProtoLens.Tag 3, numConfirmations__field_descriptor),
           (Data.ProtoLens.Tag 4, blockHash__field_descriptor),
           (Data.ProtoLens.Tag 5, blockHeight__field_descriptor),
           (Data.ProtoLens.Tag 6, timeStamp__field_descriptor),
           (Data.ProtoLens.Tag 7, totalFees__field_descriptor),
           (Data.ProtoLens.Tag 8, destAddresses__field_descriptor),
           (Data.ProtoLens.Tag 9, rawTxHex__field_descriptor),
           (Data.ProtoLens.Tag 10, label__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _Transaction'_unknownFields
        (\ x__ y__ -> x__ {_Transaction'_unknownFields = y__})
  defMessage
    = Transaction'_constructor
        {_Transaction'txHash = Data.ProtoLens.fieldDefault,
         _Transaction'amount = Data.ProtoLens.fieldDefault,
         _Transaction'numConfirmations = Data.ProtoLens.fieldDefault,
         _Transaction'blockHash = Data.ProtoLens.fieldDefault,
         _Transaction'blockHeight = Data.ProtoLens.fieldDefault,
         _Transaction'timeStamp = Data.ProtoLens.fieldDefault,
         _Transaction'totalFees = Data.ProtoLens.fieldDefault,
         _Transaction'destAddresses = Data.Vector.Generic.empty,
         _Transaction'rawTxHex = Data.ProtoLens.fieldDefault,
         _Transaction'label = Data.ProtoLens.fieldDefault,
         _Transaction'_unknownFields = []}
  parseMessage
    = let
        loop ::
          Transaction
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Data.Text.Text
             -> Data.ProtoLens.Encoding.Bytes.Parser Transaction
        loop x mutable'destAddresses
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'destAddresses <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                                (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                                   mutable'destAddresses)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'destAddresses")
                              frozen'destAddresses x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "tx_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"txHash") y x)
                                  mutable'destAddresses
                        16
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "amount"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"amount") y x)
                                  mutable'destAddresses
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "num_confirmations"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"numConfirmations") y x)
                                  mutable'destAddresses
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "block_hash"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"blockHash") y x)
                                  mutable'destAddresses
                        40
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "block_height"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"blockHeight") y x)
                                  mutable'destAddresses
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "time_stamp"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"timeStamp") y x)
                                  mutable'destAddresses
                        56
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "total_fees"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"totalFees") y x)
                                  mutable'destAddresses
                        66
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                        Data.ProtoLens.Encoding.Bytes.getBytes
                                                          (Prelude.fromIntegral len)
                                            Data.ProtoLens.Encoding.Bytes.runEither
                                              (case Data.Text.Encoding.decodeUtf8' value of
                                                 (Prelude.Left err)
                                                   -> Prelude.Left (Prelude.show err)
                                                 (Prelude.Right r) -> Prelude.Right r))
                                        "dest_addresses"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append
                                          mutable'destAddresses y)
                                loop x v
                        74
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "raw_tx_hex"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"rawTxHex") y x)
                                  mutable'destAddresses
                        82
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "label"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"label") y x)
                                  mutable'destAddresses
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'destAddresses
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'destAddresses <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                         Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'destAddresses)
          "Transaction"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"txHash") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((Prelude..)
                         (\ bs
                            -> (Data.Monoid.<>)
                                 (Data.ProtoLens.Encoding.Bytes.putVarInt
                                    (Prelude.fromIntegral (Data.ByteString.length bs)))
                                 (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         Data.Text.Encoding.encodeUtf8 _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"amount") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 16)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                ((Data.Monoid.<>)
                   (let
                      _v
                        = Lens.Family2.view
                            (Data.ProtoLens.Field.field @"numConfirmations") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"blockHash") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                               ((Prelude..)
                                  (\ bs
                                     -> (Data.Monoid.<>)
                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                             (Prelude.fromIntegral (Data.ByteString.length bs)))
                                          (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                  Data.Text.Encoding.encodeUtf8 _v))
                      ((Data.Monoid.<>)
                         (let
                            _v
                              = Lens.Family2.view (Data.ProtoLens.Field.field @"blockHeight") _x
                          in
                            if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                Data.Monoid.mempty
                            else
                                (Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.putVarInt 40)
                                  ((Prelude..)
                                     Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                     _v))
                         ((Data.Monoid.<>)
                            (let
                               _v = Lens.Family2.view (Data.ProtoLens.Field.field @"timeStamp") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            ((Data.Monoid.<>)
                               (let
                                  _v
                                    = Lens.Family2.view (Data.ProtoLens.Field.field @"totalFees") _x
                                in
                                  if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                      Data.Monoid.mempty
                                  else
                                      (Data.Monoid.<>)
                                        (Data.ProtoLens.Encoding.Bytes.putVarInt 56)
                                        ((Prelude..)
                                           Data.ProtoLens.Encoding.Bytes.putVarInt
                                           Prelude.fromIntegral _v))
                               ((Data.Monoid.<>)
                                  (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                                     (\ _v
                                        -> (Data.Monoid.<>)
                                             (Data.ProtoLens.Encoding.Bytes.putVarInt 66)
                                             ((Prelude..)
                                                (\ bs
                                                   -> (Data.Monoid.<>)
                                                        (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                           (Prelude.fromIntegral
                                                              (Data.ByteString.length bs)))
                                                        (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                                Data.Text.Encoding.encodeUtf8 _v))
                                     (Lens.Family2.view
                                        (Data.ProtoLens.Field.field @"vec'destAddresses") _x))
                                  ((Data.Monoid.<>)
                                     (let
                                        _v
                                          = Lens.Family2.view
                                              (Data.ProtoLens.Field.field @"rawTxHex") _x
                                      in
                                        if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                            Data.Monoid.mempty
                                        else
                                            (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt 74)
                                              ((Prelude..)
                                                 (\ bs
                                                    -> (Data.Monoid.<>)
                                                         (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                            (Prelude.fromIntegral
                                                               (Data.ByteString.length bs)))
                                                         (Data.ProtoLens.Encoding.Bytes.putBytes
                                                            bs))
                                                 Data.Text.Encoding.encodeUtf8 _v))
                                     ((Data.Monoid.<>)
                                        (let
                                           _v
                                             = Lens.Family2.view
                                                 (Data.ProtoLens.Field.field @"label") _x
                                         in
                                           if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                               Data.Monoid.mempty
                                           else
                                               (Data.Monoid.<>)
                                                 (Data.ProtoLens.Encoding.Bytes.putVarInt 82)
                                                 ((Prelude..)
                                                    (\ bs
                                                       -> (Data.Monoid.<>)
                                                            (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                               (Prelude.fromIntegral
                                                                  (Data.ByteString.length bs)))
                                                            (Data.ProtoLens.Encoding.Bytes.putBytes
                                                               bs))
                                                    Data.Text.Encoding.encodeUtf8 _v))
                                        (Data.ProtoLens.Encoding.Wire.buildFieldSet
                                           (Lens.Family2.view
                                              Data.ProtoLens.unknownFields _x)))))))))))
instance Control.DeepSeq.NFData Transaction where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_Transaction'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_Transaction'txHash x__)
                (Control.DeepSeq.deepseq
                   (_Transaction'amount x__)
                   (Control.DeepSeq.deepseq
                      (_Transaction'numConfirmations x__)
                      (Control.DeepSeq.deepseq
                         (_Transaction'blockHash x__)
                         (Control.DeepSeq.deepseq
                            (_Transaction'blockHeight x__)
                            (Control.DeepSeq.deepseq
                               (_Transaction'timeStamp x__)
                               (Control.DeepSeq.deepseq
                                  (_Transaction'totalFees x__)
                                  (Control.DeepSeq.deepseq
                                     (_Transaction'destAddresses x__)
                                     (Control.DeepSeq.deepseq
                                        (_Transaction'rawTxHex x__)
                                        (Control.DeepSeq.deepseq
                                           (_Transaction'label x__) ()))))))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.transactions' @:: Lens' TransactionDetails [Transaction]@
         * 'Proto.Lightning_Fields.vec'transactions' @:: Lens' TransactionDetails (Data.Vector.Vector Transaction)@ -}
data TransactionDetails
  = TransactionDetails'_constructor {_TransactionDetails'transactions :: !(Data.Vector.Vector Transaction),
                                     _TransactionDetails'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show TransactionDetails where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out TransactionDetails
instance Data.ProtoLens.Field.HasField TransactionDetails "transactions" [Transaction] where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _TransactionDetails'transactions
           (\ x__ y__ -> x__ {_TransactionDetails'transactions = y__}))
        (Lens.Family2.Unchecked.lens
           Data.Vector.Generic.toList
           (\ _ y__ -> Data.Vector.Generic.fromList y__))
instance Data.ProtoLens.Field.HasField TransactionDetails "vec'transactions" (Data.Vector.Vector Transaction) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _TransactionDetails'transactions
           (\ x__ y__ -> x__ {_TransactionDetails'transactions = y__}))
        Prelude.id
instance Data.ProtoLens.Message TransactionDetails where
  messageName _ = Data.Text.pack "lnrpc.TransactionDetails"
  packedMessageDescriptor _
    = "\n\
      \\DC2TransactionDetails\DC26\n\
      \\ftransactions\CAN\SOH \ETX(\v2\DC2.lnrpc.TransactionR\ftransactions"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        transactions__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "transactions"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Transaction)
              (Data.ProtoLens.RepeatedField
                 Data.ProtoLens.Unpacked
                 (Data.ProtoLens.Field.field @"transactions")) ::
              Data.ProtoLens.FieldDescriptor TransactionDetails
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, transactions__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _TransactionDetails'_unknownFields
        (\ x__ y__ -> x__ {_TransactionDetails'_unknownFields = y__})
  defMessage
    = TransactionDetails'_constructor
        {_TransactionDetails'transactions = Data.Vector.Generic.empty,
         _TransactionDetails'_unknownFields = []}
  parseMessage
    = let
        loop ::
          TransactionDetails
          -> Data.ProtoLens.Encoding.Growing.Growing Data.Vector.Vector Data.ProtoLens.Encoding.Growing.RealWorld Transaction
             -> Data.ProtoLens.Encoding.Bytes.Parser TransactionDetails
        loop x mutable'transactions
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do frozen'transactions <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                               (Data.ProtoLens.Encoding.Growing.unsafeFreeze
                                                  mutable'transactions)
                      (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t)
                           (Lens.Family2.set
                              (Data.ProtoLens.Field.field @"vec'transactions")
                              frozen'transactions x))
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do !y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                        (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                            Data.ProtoLens.Encoding.Bytes.isolate
                                              (Prelude.fromIntegral len)
                                              Data.ProtoLens.parseMessage)
                                        "transactions"
                                v <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                       (Data.ProtoLens.Encoding.Growing.append
                                          mutable'transactions y)
                                loop x v
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
                                  mutable'transactions
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do mutable'transactions <- Data.ProtoLens.Encoding.Parser.Unsafe.unsafeLiftIO
                                        Data.ProtoLens.Encoding.Growing.new
              loop Data.ProtoLens.defMessage mutable'transactions)
          "TransactionDetails"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (Data.ProtoLens.Encoding.Bytes.foldMapBuilder
                (\ _v
                   -> (Data.Monoid.<>)
                        (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                        ((Prelude..)
                           (\ bs
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt
                                      (Prelude.fromIntegral (Data.ByteString.length bs)))
                                   (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                           Data.ProtoLens.encodeMessage _v))
                (Lens.Family2.view
                   (Data.ProtoLens.Field.field @"vec'transactions") _x))
             (Data.ProtoLens.Encoding.Wire.buildFieldSet
                (Lens.Family2.view Data.ProtoLens.unknownFields _x))
instance Control.DeepSeq.NFData TransactionDetails where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_TransactionDetails'_unknownFields x__)
             (Control.DeepSeq.deepseq (_TransactionDetails'transactions x__) ())
{- | Fields :
     
         * 'Proto.Lightning_Fields.addressType' @:: Lens' Utxo AddressType@
         * 'Proto.Lightning_Fields.address' @:: Lens' Utxo Data.Text.Text@
         * 'Proto.Lightning_Fields.amountSat' @:: Lens' Utxo Data.Int.Int64@
         * 'Proto.Lightning_Fields.pkScript' @:: Lens' Utxo Data.Text.Text@
         * 'Proto.Lightning_Fields.outpoint' @:: Lens' Utxo Proto.Lnrpc.Ln0.OutPoint@
         * 'Proto.Lightning_Fields.maybe'outpoint' @:: Lens' Utxo (Prelude.Maybe Proto.Lnrpc.Ln0.OutPoint)@
         * 'Proto.Lightning_Fields.confirmations' @:: Lens' Utxo Data.Int.Int64@ -}
data Utxo
  = Utxo'_constructor {_Utxo'addressType :: !AddressType,
                       _Utxo'address :: !Data.Text.Text,
                       _Utxo'amountSat :: !Data.Int.Int64,
                       _Utxo'pkScript :: !Data.Text.Text,
                       _Utxo'outpoint :: !(Prelude.Maybe Proto.Lnrpc.Ln0.OutPoint),
                       _Utxo'confirmations :: !Data.Int.Int64,
                       _Utxo'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show Utxo where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out Utxo
instance Data.ProtoLens.Field.HasField Utxo "addressType" AddressType where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'addressType (\ x__ y__ -> x__ {_Utxo'addressType = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Utxo "address" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'address (\ x__ y__ -> x__ {_Utxo'address = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Utxo "amountSat" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'amountSat (\ x__ y__ -> x__ {_Utxo'amountSat = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Utxo "pkScript" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'pkScript (\ x__ y__ -> x__ {_Utxo'pkScript = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Utxo "outpoint" Proto.Lnrpc.Ln0.OutPoint where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'outpoint (\ x__ y__ -> x__ {_Utxo'outpoint = y__}))
        (Data.ProtoLens.maybeLens Data.ProtoLens.defMessage)
instance Data.ProtoLens.Field.HasField Utxo "maybe'outpoint" (Prelude.Maybe Proto.Lnrpc.Ln0.OutPoint) where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'outpoint (\ x__ y__ -> x__ {_Utxo'outpoint = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField Utxo "confirmations" Data.Int.Int64 where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _Utxo'confirmations (\ x__ y__ -> x__ {_Utxo'confirmations = y__}))
        Prelude.id
instance Data.ProtoLens.Message Utxo where
  messageName _ = Data.Text.pack "lnrpc.Utxo"
  packedMessageDescriptor _
    = "\n\
      \\EOTUtxo\DC25\n\
      \\faddress_type\CAN\SOH \SOH(\SO2\DC2.lnrpc.AddressTypeR\vaddressType\DC2\CAN\n\
      \\aaddress\CAN\STX \SOH(\tR\aaddress\DC2\GS\n\
      \\n\
      \amount_sat\CAN\ETX \SOH(\ETXR\tamountSat\DC2\ESC\n\
      \\tpk_script\CAN\EOT \SOH(\tR\bpkScript\DC2+\n\
      \\boutpoint\CAN\ENQ \SOH(\v2\SI.lnrpc.OutPointR\boutpoint\DC2$\n\
      \\rconfirmations\CAN\ACK \SOH(\ETXR\rconfirmations"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        addressType__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "address_type"
              (Data.ProtoLens.ScalarField Data.ProtoLens.EnumField ::
                 Data.ProtoLens.FieldTypeDescriptor AddressType)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"addressType")) ::
              Data.ProtoLens.FieldDescriptor Utxo
        address__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "address"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"address")) ::
              Data.ProtoLens.FieldDescriptor Utxo
        amountSat__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "amount_sat"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"amountSat")) ::
              Data.ProtoLens.FieldDescriptor Utxo
        pkScript__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pk_script"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"pkScript")) ::
              Data.ProtoLens.FieldDescriptor Utxo
        outpoint__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "outpoint"
              (Data.ProtoLens.MessageField Data.ProtoLens.MessageType ::
                 Data.ProtoLens.FieldTypeDescriptor Proto.Lnrpc.Ln0.OutPoint)
              (Data.ProtoLens.OptionalField
                 (Data.ProtoLens.Field.field @"maybe'outpoint")) ::
              Data.ProtoLens.FieldDescriptor Utxo
        confirmations__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "confirmations"
              (Data.ProtoLens.ScalarField Data.ProtoLens.Int64Field ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Int.Int64)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"confirmations")) ::
              Data.ProtoLens.FieldDescriptor Utxo
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, addressType__field_descriptor),
           (Data.ProtoLens.Tag 2, address__field_descriptor),
           (Data.ProtoLens.Tag 3, amountSat__field_descriptor),
           (Data.ProtoLens.Tag 4, pkScript__field_descriptor),
           (Data.ProtoLens.Tag 5, outpoint__field_descriptor),
           (Data.ProtoLens.Tag 6, confirmations__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _Utxo'_unknownFields
        (\ x__ y__ -> x__ {_Utxo'_unknownFields = y__})
  defMessage
    = Utxo'_constructor
        {_Utxo'addressType = Data.ProtoLens.fieldDefault,
         _Utxo'address = Data.ProtoLens.fieldDefault,
         _Utxo'amountSat = Data.ProtoLens.fieldDefault,
         _Utxo'pkScript = Data.ProtoLens.fieldDefault,
         _Utxo'outpoint = Prelude.Nothing,
         _Utxo'confirmations = Data.ProtoLens.fieldDefault,
         _Utxo'_unknownFields = []}
  parseMessage
    = let
        loop :: Utxo -> Data.ProtoLens.Encoding.Bytes.Parser Utxo
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.toEnum
                                          (Prelude.fmap
                                             Prelude.fromIntegral
                                             Data.ProtoLens.Encoding.Bytes.getVarInt))
                                       "address_type"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"addressType") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "address"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"address") y x)
                        24
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "amount_sat"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"amountSat") y x)
                        34
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "pk_script"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"pkScript") y x)
                        42
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.isolate
                                             (Prelude.fromIntegral len) Data.ProtoLens.parseMessage)
                                       "outpoint"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"outpoint") y x)
                        48
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          Prelude.fromIntegral
                                          Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "confirmations"
                                loop
                                  (Lens.Family2.set
                                     (Data.ProtoLens.Field.field @"confirmations") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "Utxo"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v
                  = Lens.Family2.view (Data.ProtoLens.Field.field @"addressType") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         ((Prelude..)
                            Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral)
                         Prelude.fromEnum _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"address") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                ((Data.Monoid.<>)
                   (let
                      _v = Lens.Family2.view (Data.ProtoLens.Field.field @"amountSat") _x
                    in
                      if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                          Data.Monoid.mempty
                      else
                          (Data.Monoid.<>)
                            (Data.ProtoLens.Encoding.Bytes.putVarInt 24)
                            ((Prelude..)
                               Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral _v))
                   ((Data.Monoid.<>)
                      (let
                         _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pkScript") _x
                       in
                         if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                             Data.Monoid.mempty
                         else
                             (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt 34)
                               ((Prelude..)
                                  (\ bs
                                     -> (Data.Monoid.<>)
                                          (Data.ProtoLens.Encoding.Bytes.putVarInt
                                             (Prelude.fromIntegral (Data.ByteString.length bs)))
                                          (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                  Data.Text.Encoding.encodeUtf8 _v))
                      ((Data.Monoid.<>)
                         (case
                              Lens.Family2.view (Data.ProtoLens.Field.field @"maybe'outpoint") _x
                          of
                            Prelude.Nothing -> Data.Monoid.mempty
                            (Prelude.Just _v)
                              -> (Data.Monoid.<>)
                                   (Data.ProtoLens.Encoding.Bytes.putVarInt 42)
                                   ((Prelude..)
                                      (\ bs
                                         -> (Data.Monoid.<>)
                                              (Data.ProtoLens.Encoding.Bytes.putVarInt
                                                 (Prelude.fromIntegral (Data.ByteString.length bs)))
                                              (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                                      Data.ProtoLens.encodeMessage _v))
                         ((Data.Monoid.<>)
                            (let
                               _v
                                 = Lens.Family2.view
                                     (Data.ProtoLens.Field.field @"confirmations") _x
                             in
                               if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                                   Data.Monoid.mempty
                               else
                                   (Data.Monoid.<>)
                                     (Data.ProtoLens.Encoding.Bytes.putVarInt 48)
                                     ((Prelude..)
                                        Data.ProtoLens.Encoding.Bytes.putVarInt Prelude.fromIntegral
                                        _v))
                            (Data.ProtoLens.Encoding.Wire.buildFieldSet
                               (Lens.Family2.view Data.ProtoLens.unknownFields _x)))))))
instance Control.DeepSeq.NFData Utxo where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_Utxo'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_Utxo'addressType x__)
                (Control.DeepSeq.deepseq
                   (_Utxo'address x__)
                   (Control.DeepSeq.deepseq
                      (_Utxo'amountSat x__)
                      (Control.DeepSeq.deepseq
                         (_Utxo'pkScript x__)
                         (Control.DeepSeq.deepseq
                            (_Utxo'outpoint x__)
                            (Control.DeepSeq.deepseq (_Utxo'confirmations x__) ()))))))
{- | Fields :
     
         * 'Proto.Lightning_Fields.msg' @:: Lens' VerifyMessageRequest Data.ByteString.ByteString@
         * 'Proto.Lightning_Fields.signature' @:: Lens' VerifyMessageRequest Data.Text.Text@ -}
data VerifyMessageRequest
  = VerifyMessageRequest'_constructor {_VerifyMessageRequest'msg :: !Data.ByteString.ByteString,
                                       _VerifyMessageRequest'signature :: !Data.Text.Text,
                                       _VerifyMessageRequest'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show VerifyMessageRequest where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out VerifyMessageRequest
instance Data.ProtoLens.Field.HasField VerifyMessageRequest "msg" Data.ByteString.ByteString where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _VerifyMessageRequest'msg
           (\ x__ y__ -> x__ {_VerifyMessageRequest'msg = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField VerifyMessageRequest "signature" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _VerifyMessageRequest'signature
           (\ x__ y__ -> x__ {_VerifyMessageRequest'signature = y__}))
        Prelude.id
instance Data.ProtoLens.Message VerifyMessageRequest where
  messageName _ = Data.Text.pack "lnrpc.VerifyMessageRequest"
  packedMessageDescriptor _
    = "\n\
      \\DC4VerifyMessageRequest\DC2\DLE\n\
      \\ETXmsg\CAN\SOH \SOH(\fR\ETXmsg\DC2\FS\n\
      \\tsignature\CAN\STX \SOH(\tR\tsignature"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        msg__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "msg"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BytesField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.ByteString.ByteString)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"msg")) ::
              Data.ProtoLens.FieldDescriptor VerifyMessageRequest
        signature__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "signature"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional
                 (Data.ProtoLens.Field.field @"signature")) ::
              Data.ProtoLens.FieldDescriptor VerifyMessageRequest
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, msg__field_descriptor),
           (Data.ProtoLens.Tag 2, signature__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _VerifyMessageRequest'_unknownFields
        (\ x__ y__ -> x__ {_VerifyMessageRequest'_unknownFields = y__})
  defMessage
    = VerifyMessageRequest'_constructor
        {_VerifyMessageRequest'msg = Data.ProtoLens.fieldDefault,
         _VerifyMessageRequest'signature = Data.ProtoLens.fieldDefault,
         _VerifyMessageRequest'_unknownFields = []}
  parseMessage
    = let
        loop ::
          VerifyMessageRequest
          -> Data.ProtoLens.Encoding.Bytes.Parser VerifyMessageRequest
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        10
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                           Data.ProtoLens.Encoding.Bytes.getBytes
                                             (Prelude.fromIntegral len))
                                       "msg"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"msg") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "signature"
                                loop
                                  (Lens.Family2.set (Data.ProtoLens.Field.field @"signature") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "VerifyMessageRequest"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let _v = Lens.Family2.view (Data.ProtoLens.Field.field @"msg") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 10)
                      ((\ bs
                          -> (Data.Monoid.<>)
                               (Data.ProtoLens.Encoding.Bytes.putVarInt
                                  (Prelude.fromIntegral (Data.ByteString.length bs)))
                               (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"signature") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData VerifyMessageRequest where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_VerifyMessageRequest'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_VerifyMessageRequest'msg x__)
                (Control.DeepSeq.deepseq (_VerifyMessageRequest'signature x__) ()))
{- | Fields :
     
         * 'Proto.Lightning_Fields.valid' @:: Lens' VerifyMessageResponse Prelude.Bool@
         * 'Proto.Lightning_Fields.pubkey' @:: Lens' VerifyMessageResponse Data.Text.Text@ -}
data VerifyMessageResponse
  = VerifyMessageResponse'_constructor {_VerifyMessageResponse'valid :: !Prelude.Bool,
                                        _VerifyMessageResponse'pubkey :: !Data.Text.Text,
                                        _VerifyMessageResponse'_unknownFields :: !Data.ProtoLens.FieldSet}
  deriving stock (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic)
instance Prelude.Show VerifyMessageResponse where
  showsPrec _ __x __s
    = Prelude.showChar
        '{'
        (Prelude.showString
           (Data.ProtoLens.showMessageShort __x) (Prelude.showChar '}' __s))
instance Text.PrettyPrint.GenericPretty.Out VerifyMessageResponse
instance Data.ProtoLens.Field.HasField VerifyMessageResponse "valid" Prelude.Bool where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _VerifyMessageResponse'valid
           (\ x__ y__ -> x__ {_VerifyMessageResponse'valid = y__}))
        Prelude.id
instance Data.ProtoLens.Field.HasField VerifyMessageResponse "pubkey" Data.Text.Text where
  fieldOf _
    = (Prelude..)
        (Lens.Family2.Unchecked.lens
           _VerifyMessageResponse'pubkey
           (\ x__ y__ -> x__ {_VerifyMessageResponse'pubkey = y__}))
        Prelude.id
instance Data.ProtoLens.Message VerifyMessageResponse where
  messageName _ = Data.Text.pack "lnrpc.VerifyMessageResponse"
  packedMessageDescriptor _
    = "\n\
      \\NAKVerifyMessageResponse\DC2\DC4\n\
      \\ENQvalid\CAN\SOH \SOH(\bR\ENQvalid\DC2\SYN\n\
      \\ACKpubkey\CAN\STX \SOH(\tR\ACKpubkey"
  packedFileDescriptor _ = packedFileDescriptor
  fieldsByTag
    = let
        valid__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "valid"
              (Data.ProtoLens.ScalarField Data.ProtoLens.BoolField ::
                 Data.ProtoLens.FieldTypeDescriptor Prelude.Bool)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"valid")) ::
              Data.ProtoLens.FieldDescriptor VerifyMessageResponse
        pubkey__field_descriptor
          = Data.ProtoLens.FieldDescriptor
              "pubkey"
              (Data.ProtoLens.ScalarField Data.ProtoLens.StringField ::
                 Data.ProtoLens.FieldTypeDescriptor Data.Text.Text)
              (Data.ProtoLens.PlainField
                 Data.ProtoLens.Optional (Data.ProtoLens.Field.field @"pubkey")) ::
              Data.ProtoLens.FieldDescriptor VerifyMessageResponse
      in
        Data.Map.fromList
          [(Data.ProtoLens.Tag 1, valid__field_descriptor),
           (Data.ProtoLens.Tag 2, pubkey__field_descriptor)]
  unknownFields
    = Lens.Family2.Unchecked.lens
        _VerifyMessageResponse'_unknownFields
        (\ x__ y__ -> x__ {_VerifyMessageResponse'_unknownFields = y__})
  defMessage
    = VerifyMessageResponse'_constructor
        {_VerifyMessageResponse'valid = Data.ProtoLens.fieldDefault,
         _VerifyMessageResponse'pubkey = Data.ProtoLens.fieldDefault,
         _VerifyMessageResponse'_unknownFields = []}
  parseMessage
    = let
        loop ::
          VerifyMessageResponse
          -> Data.ProtoLens.Encoding.Bytes.Parser VerifyMessageResponse
        loop x
          = do end <- Data.ProtoLens.Encoding.Bytes.atEnd
               if end then
                   do (let missing = []
                       in
                         if Prelude.null missing then
                             Prelude.return ()
                         else
                             Prelude.fail
                               ((Prelude.++)
                                  "Missing required fields: "
                                  (Prelude.show (missing :: [Prelude.String]))))
                      Prelude.return
                        (Lens.Family2.over
                           Data.ProtoLens.unknownFields (\ !t -> Prelude.reverse t) x)
               else
                   do tag <- Data.ProtoLens.Encoding.Bytes.getVarInt
                      case tag of
                        8 -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (Prelude.fmap
                                          ((Prelude./=) 0) Data.ProtoLens.Encoding.Bytes.getVarInt)
                                       "valid"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"valid") y x)
                        18
                          -> do y <- (Data.ProtoLens.Encoding.Bytes.<?>)
                                       (do value <- do len <- Data.ProtoLens.Encoding.Bytes.getVarInt
                                                       Data.ProtoLens.Encoding.Bytes.getBytes
                                                         (Prelude.fromIntegral len)
                                           Data.ProtoLens.Encoding.Bytes.runEither
                                             (case Data.Text.Encoding.decodeUtf8' value of
                                                (Prelude.Left err)
                                                  -> Prelude.Left (Prelude.show err)
                                                (Prelude.Right r) -> Prelude.Right r))
                                       "pubkey"
                                loop (Lens.Family2.set (Data.ProtoLens.Field.field @"pubkey") y x)
                        wire
                          -> do !y <- Data.ProtoLens.Encoding.Wire.parseTaggedValueFromWire
                                        wire
                                loop
                                  (Lens.Family2.over
                                     Data.ProtoLens.unknownFields (\ !t -> (:) y t) x)
      in
        (Data.ProtoLens.Encoding.Bytes.<?>)
          (do loop Data.ProtoLens.defMessage) "VerifyMessageResponse"
  buildMessage
    = \ _x
        -> (Data.Monoid.<>)
             (let
                _v = Lens.Family2.view (Data.ProtoLens.Field.field @"valid") _x
              in
                if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                    Data.Monoid.mempty
                else
                    (Data.Monoid.<>)
                      (Data.ProtoLens.Encoding.Bytes.putVarInt 8)
                      ((Prelude..)
                         Data.ProtoLens.Encoding.Bytes.putVarInt (\ b -> if b then 1 else 0)
                         _v))
             ((Data.Monoid.<>)
                (let
                   _v = Lens.Family2.view (Data.ProtoLens.Field.field @"pubkey") _x
                 in
                   if (Prelude.==) _v Data.ProtoLens.fieldDefault then
                       Data.Monoid.mempty
                   else
                       (Data.Monoid.<>)
                         (Data.ProtoLens.Encoding.Bytes.putVarInt 18)
                         ((Prelude..)
                            (\ bs
                               -> (Data.Monoid.<>)
                                    (Data.ProtoLens.Encoding.Bytes.putVarInt
                                       (Prelude.fromIntegral (Data.ByteString.length bs)))
                                    (Data.ProtoLens.Encoding.Bytes.putBytes bs))
                            Data.Text.Encoding.encodeUtf8 _v))
                (Data.ProtoLens.Encoding.Wire.buildFieldSet
                   (Lens.Family2.view Data.ProtoLens.unknownFields _x)))
instance Control.DeepSeq.NFData VerifyMessageResponse where
  rnf
    = \ x__
        -> Control.DeepSeq.deepseq
             (_VerifyMessageResponse'_unknownFields x__)
             (Control.DeepSeq.deepseq
                (_VerifyMessageResponse'valid x__)
                (Control.DeepSeq.deepseq (_VerifyMessageResponse'pubkey x__) ()))
data Lightning = Lightning {}
instance Data.ProtoLens.Service.Types.Service Lightning where
  type ServiceName Lightning = "Lightning"
  type ServicePackage Lightning = "lnrpc"
  type ServiceMethods Lightning = '["abandonChannel",
                                    "addInvoice",
                                    "bakeMacaroon",
                                    "batchOpenChannel",
                                    "channelAcceptor",
                                    "channelBalance",
                                    "checkMacaroonPermissions",
                                    "closeChannel",
                                    "closedChannels",
                                    "connectPeer",
                                    "debugLevel",
                                    "decodePayReq",
                                    "deleteAllPayments",
                                    "deleteMacaroonID",
                                    "deletePayment",
                                    "describeGraph",
                                    "disconnectPeer",
                                    "estimateFee",
                                    "exportAllChannelBackups",
                                    "exportChannelBackup",
                                    "feeReport",
                                    "forwardingHistory",
                                    "fundingStateStep",
                                    "getChanInfo",
                                    "getInfo",
                                    "getNetworkInfo",
                                    "getNodeInfo",
                                    "getNodeMetrics",
                                    "getRecoveryInfo",
                                    "getTransactions",
                                    "listChannels",
                                    "listInvoices",
                                    "listMacaroonIDs",
                                    "listPayments",
                                    "listPeers",
                                    "listPermissions",
                                    "listUnspent",
                                    "lookupInvoice",
                                    "newAddress",
                                    "openChannel",
                                    "openChannelSync",
                                    "pendingChannels",
                                    "queryRoutes",
                                    "registerRPCMiddleware",
                                    "restoreChannelBackups",
                                    "sendCoins",
                                    "sendCustomMessage",
                                    "sendMany",
                                    "sendPayment",
                                    "sendPaymentSync",
                                    "sendToRoute",
                                    "sendToRouteSync",
                                    "signMessage",
                                    "stopDaemon",
                                    "subscribeChannelBackups",
                                    "subscribeChannelEvents",
                                    "subscribeChannelGraph",
                                    "subscribeCustomMessages",
                                    "subscribeInvoices",
                                    "subscribePeerEvents",
                                    "subscribeTransactions",
                                    "updateChannelPolicy",
                                    "verifyChanBackup",
                                    "verifyMessage",
                                    "walletBalance"]
  packedServiceDescriptor _
    = "\n\
      \\tLightning\DC2J\n\
      \\rWalletBalance\DC2\ESC.lnrpc.WalletBalanceRequest\SUB\FS.lnrpc.WalletBalanceResponse\DC2M\n\
      \\SOChannelBalance\DC2\FS.lnrpc.ChannelBalanceRequest\SUB\GS.lnrpc.ChannelBalanceResponse\DC2K\n\
      \\SIGetTransactions\DC2\GS.lnrpc.GetTransactionsRequest\SUB\EM.lnrpc.TransactionDetails\DC2D\n\
      \\vEstimateFee\DC2\EM.lnrpc.EstimateFeeRequest\SUB\SUB.lnrpc.EstimateFeeResponse\DC2>\n\
      \\tSendCoins\DC2\ETB.lnrpc.SendCoinsRequest\SUB\CAN.lnrpc.SendCoinsResponse\DC2D\n\
      \\vListUnspent\DC2\EM.lnrpc.ListUnspentRequest\SUB\SUB.lnrpc.ListUnspentResponse\DC2L\n\
      \\NAKSubscribeTransactions\DC2\GS.lnrpc.GetTransactionsRequest\SUB\DC2.lnrpc.Transaction0\SOH\DC2;\n\
      \\bSendMany\DC2\SYN.lnrpc.SendManyRequest\SUB\ETB.lnrpc.SendManyResponse\DC2A\n\
      \\n\
      \NewAddress\DC2\CAN.lnrpc.NewAddressRequest\SUB\EM.lnrpc.NewAddressResponse\DC2D\n\
      \\vSignMessage\DC2\EM.lnrpc.SignMessageRequest\SUB\SUB.lnrpc.SignMessageResponse\DC2J\n\
      \\rVerifyMessage\DC2\ESC.lnrpc.VerifyMessageRequest\SUB\FS.lnrpc.VerifyMessageResponse\DC2D\n\
      \\vConnectPeer\DC2\EM.lnrpc.ConnectPeerRequest\SUB\SUB.lnrpc.ConnectPeerResponse\DC2M\n\
      \\SODisconnectPeer\DC2\FS.lnrpc.DisconnectPeerRequest\SUB\GS.lnrpc.DisconnectPeerResponse\DC2>\n\
      \\tListPeers\DC2\ETB.lnrpc.ListPeersRequest\SUB\CAN.lnrpc.ListPeersResponse\DC2G\n\
      \\DC3SubscribePeerEvents\DC2\FS.lnrpc.PeerEventSubscription\SUB\DLE.lnrpc.PeerEvent0\SOH\DC28\n\
      \\aGetInfo\DC2\NAK.lnrpc.GetInfoRequest\SUB\SYN.lnrpc.GetInfoResponse\DC2P\n\
      \\SIGetRecoveryInfo\DC2\GS.lnrpc.GetRecoveryInfoRequest\SUB\RS.lnrpc.GetRecoveryInfoResponse\DC2P\n\
      \\SIPendingChannels\DC2\GS.lnrpc.PendingChannelsRequest\SUB\RS.lnrpc.PendingChannelsResponse\DC2G\n\
      \\fListChannels\DC2\SUB.lnrpc.ListChannelsRequest\SUB\ESC.lnrpc.ListChannelsResponse\DC2V\n\
      \\SYNSubscribeChannelEvents\DC2\US.lnrpc.ChannelEventSubscription\SUB\EM.lnrpc.ChannelEventUpdate0\SOH\DC2M\n\
      \\SOClosedChannels\DC2\FS.lnrpc.ClosedChannelsRequest\SUB\GS.lnrpc.ClosedChannelsResponse\DC2A\n\
      \\SIOpenChannelSync\DC2\EM.lnrpc.OpenChannelRequest\SUB\DC3.lnrpc.ChannelPoint\DC2C\n\
      \\vOpenChannel\DC2\EM.lnrpc.OpenChannelRequest\SUB\ETB.lnrpc.OpenStatusUpdate0\SOH\DC2S\n\
      \\DLEBatchOpenChannel\DC2\RS.lnrpc.BatchOpenChannelRequest\SUB\US.lnrpc.BatchOpenChannelResponse\DC2L\n\
      \\DLEFundingStateStep\DC2\ESC.lnrpc.FundingTransitionMsg\SUB\ESC.lnrpc.FundingStateStepResp\DC2P\n\
      \\SIChannelAcceptor\DC2\FS.lnrpc.ChannelAcceptResponse\SUB\ESC.lnrpc.ChannelAcceptRequest(\SOH0\SOH\DC2F\n\
      \\fCloseChannel\DC2\SUB.lnrpc.CloseChannelRequest\SUB\CAN.lnrpc.CloseStatusUpdate0\SOH\DC2M\n\
      \\SOAbandonChannel\DC2\FS.lnrpc.AbandonChannelRequest\SUB\GS.lnrpc.AbandonChannelResponse\DC2?\n\
      \\vSendPayment\DC2\DC2.lnrpc.SendRequest\SUB\DC3.lnrpc.SendResponse\"\ETX\136\STX\SOH(\SOH0\SOH\DC2:\n\
      \\SISendPaymentSync\DC2\DC2.lnrpc.SendRequest\SUB\DC3.lnrpc.SendResponse\DC2F\n\
      \\vSendToRoute\DC2\EM.lnrpc.SendToRouteRequest\SUB\DC3.lnrpc.SendResponse\"\ETX\136\STX\SOH(\SOH0\SOH\DC2A\n\
      \\SISendToRouteSync\DC2\EM.lnrpc.SendToRouteRequest\SUB\DC3.lnrpc.SendResponse\DC27\n\
      \\n\
      \AddInvoice\DC2\SO.lnrpc.Invoice\SUB\EM.lnrpc.AddInvoiceResponse\DC2E\n\
      \\fListInvoices\DC2\EM.lnrpc.ListInvoiceRequest\SUB\SUB.lnrpc.ListInvoiceResponse\DC23\n\
      \\rLookupInvoice\DC2\DC2.lnrpc.PaymentHash\SUB\SO.lnrpc.Invoice\DC2A\n\
      \\DC1SubscribeInvoices\DC2\SUB.lnrpc.InvoiceSubscription\SUB\SO.lnrpc.Invoice0\SOH\DC22\n\
      \\fDecodePayReq\DC2\DC3.lnrpc.PayReqString\SUB\r.lnrpc.PayReq\DC2G\n\
      \\fListPayments\DC2\SUB.lnrpc.ListPaymentsRequest\SUB\ESC.lnrpc.ListPaymentsResponse\DC2J\n\
      \\rDeletePayment\DC2\ESC.lnrpc.DeletePaymentRequest\SUB\FS.lnrpc.DeletePaymentResponse\DC2V\n\
      \\DC1DeleteAllPayments\DC2\US.lnrpc.DeleteAllPaymentsRequest\SUB .lnrpc.DeleteAllPaymentsResponse\DC2@\n\
      \\rDescribeGraph\DC2\SUB.lnrpc.ChannelGraphRequest\SUB\DC3.lnrpc.ChannelGraph\DC2G\n\
      \\SOGetNodeMetrics\DC2\EM.lnrpc.NodeMetricsRequest\SUB\SUB.lnrpc.NodeMetricsResponse\DC29\n\
      \\vGetChanInfo\DC2\SYN.lnrpc.ChanInfoRequest\SUB\DC2.lnrpc.ChannelEdge\DC26\n\
      \\vGetNodeInfo\DC2\SYN.lnrpc.NodeInfoRequest\SUB\SI.lnrpc.NodeInfo\DC2D\n\
      \\vQueryRoutes\DC2\EM.lnrpc.QueryRoutesRequest\SUB\SUB.lnrpc.QueryRoutesResponse\DC2?\n\
      \\SOGetNetworkInfo\DC2\EM.lnrpc.NetworkInfoRequest\SUB\DC2.lnrpc.NetworkInfo\DC25\n\
      \\n\
      \StopDaemon\DC2\DC2.lnrpc.StopRequest\SUB\DC3.lnrpc.StopResponse\DC2W\n\
      \\NAKSubscribeChannelGraph\DC2 .lnrpc.GraphTopologySubscription\SUB\SUB.lnrpc.GraphTopologyUpdate0\SOH\DC2A\n\
      \\n\
      \DebugLevel\DC2\CAN.lnrpc.DebugLevelRequest\SUB\EM.lnrpc.DebugLevelResponse\DC2>\n\
      \\tFeeReport\DC2\ETB.lnrpc.FeeReportRequest\SUB\CAN.lnrpc.FeeReportResponse\DC2N\n\
      \\DC3UpdateChannelPolicy\DC2\SUB.lnrpc.PolicyUpdateRequest\SUB\ESC.lnrpc.PolicyUpdateResponse\DC2V\n\
      \\DC1ForwardingHistory\DC2\US.lnrpc.ForwardingHistoryRequest\SUB .lnrpc.ForwardingHistoryResponse\DC2N\n\
      \\DC3ExportChannelBackup\DC2!.lnrpc.ExportChannelBackupRequest\SUB\DC4.lnrpc.ChannelBackup\DC2T\n\
      \\ETBExportAllChannelBackups\DC2\RS.lnrpc.ChanBackupExportRequest\SUB\EM.lnrpc.ChanBackupSnapshot\DC2N\n\
      \\DLEVerifyChanBackup\DC2\EM.lnrpc.ChanBackupSnapshot\SUB\US.lnrpc.VerifyChanBackupResponse\DC2V\n\
      \\NAKRestoreChannelBackups\DC2\US.lnrpc.RestoreChanBackupRequest\SUB\FS.lnrpc.RestoreBackupResponse\DC2X\n\
      \\ETBSubscribeChannelBackups\DC2 .lnrpc.ChannelBackupSubscription\SUB\EM.lnrpc.ChanBackupSnapshot0\SOH\DC2G\n\
      \\fBakeMacaroon\DC2\SUB.lnrpc.BakeMacaroonRequest\SUB\ESC.lnrpc.BakeMacaroonResponse\DC2P\n\
      \\SIListMacaroonIDs\DC2\GS.lnrpc.ListMacaroonIDsRequest\SUB\RS.lnrpc.ListMacaroonIDsResponse\DC2S\n\
      \\DLEDeleteMacaroonID\DC2\RS.lnrpc.DeleteMacaroonIDRequest\SUB\US.lnrpc.DeleteMacaroonIDResponse\DC2P\n\
      \\SIListPermissions\DC2\GS.lnrpc.ListPermissionsRequest\SUB\RS.lnrpc.ListPermissionsResponse\DC2S\n\
      \\CANCheckMacaroonPermissions\DC2\SUB.lnrpc.CheckMacPermRequest\SUB\ESC.lnrpc.CheckMacPermResponse\DC2V\n\
      \\NAKRegisterRPCMiddleware\DC2\FS.lnrpc.RPCMiddlewareResponse\SUB\ESC.lnrpc.RPCMiddlewareRequest(\SOH0\SOH\DC2V\n\
      \\DC1SendCustomMessage\DC2\US.lnrpc.SendCustomMessageRequest\SUB .lnrpc.SendCustomMessageResponse\DC2X\n\
      \\ETBSubscribeCustomMessages\DC2%.lnrpc.SubscribeCustomMessagesRequest\SUB\DC4.lnrpc.CustomMessage0\SOH"
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "walletBalance" where
  type MethodName Lightning "walletBalance" = "WalletBalance"
  type MethodInput Lightning "walletBalance" = Proto.Lnrpc.Ln0.WalletBalanceRequest
  type MethodOutput Lightning "walletBalance" = Proto.Lnrpc.Ln0.WalletBalanceResponse
  type MethodStreamingType Lightning "walletBalance" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "channelBalance" where
  type MethodName Lightning "channelBalance" = "ChannelBalance"
  type MethodInput Lightning "channelBalance" = Proto.Lnrpc.Ln0.ChannelBalanceRequest
  type MethodOutput Lightning "channelBalance" = Proto.Lnrpc.Ln0.ChannelBalanceResponse
  type MethodStreamingType Lightning "channelBalance" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getTransactions" where
  type MethodName Lightning "getTransactions" = "GetTransactions"
  type MethodInput Lightning "getTransactions" = GetTransactionsRequest
  type MethodOutput Lightning "getTransactions" = TransactionDetails
  type MethodStreamingType Lightning "getTransactions" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "estimateFee" where
  type MethodName Lightning "estimateFee" = "EstimateFee"
  type MethodInput Lightning "estimateFee" = EstimateFeeRequest
  type MethodOutput Lightning "estimateFee" = EstimateFeeResponse
  type MethodStreamingType Lightning "estimateFee" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendCoins" where
  type MethodName Lightning "sendCoins" = "SendCoins"
  type MethodInput Lightning "sendCoins" = SendCoinsRequest
  type MethodOutput Lightning "sendCoins" = SendCoinsResponse
  type MethodStreamingType Lightning "sendCoins" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listUnspent" where
  type MethodName Lightning "listUnspent" = "ListUnspent"
  type MethodInput Lightning "listUnspent" = ListUnspentRequest
  type MethodOutput Lightning "listUnspent" = ListUnspentResponse
  type MethodStreamingType Lightning "listUnspent" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribeTransactions" where
  type MethodName Lightning "subscribeTransactions" = "SubscribeTransactions"
  type MethodInput Lightning "subscribeTransactions" = GetTransactionsRequest
  type MethodOutput Lightning "subscribeTransactions" = Transaction
  type MethodStreamingType Lightning "subscribeTransactions" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendMany" where
  type MethodName Lightning "sendMany" = "SendMany"
  type MethodInput Lightning "sendMany" = SendManyRequest
  type MethodOutput Lightning "sendMany" = SendManyResponse
  type MethodStreamingType Lightning "sendMany" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "newAddress" where
  type MethodName Lightning "newAddress" = "NewAddress"
  type MethodInput Lightning "newAddress" = NewAddressRequest
  type MethodOutput Lightning "newAddress" = NewAddressResponse
  type MethodStreamingType Lightning "newAddress" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "signMessage" where
  type MethodName Lightning "signMessage" = "SignMessage"
  type MethodInput Lightning "signMessage" = SignMessageRequest
  type MethodOutput Lightning "signMessage" = SignMessageResponse
  type MethodStreamingType Lightning "signMessage" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "verifyMessage" where
  type MethodName Lightning "verifyMessage" = "VerifyMessage"
  type MethodInput Lightning "verifyMessage" = VerifyMessageRequest
  type MethodOutput Lightning "verifyMessage" = VerifyMessageResponse
  type MethodStreamingType Lightning "verifyMessage" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "connectPeer" where
  type MethodName Lightning "connectPeer" = "ConnectPeer"
  type MethodInput Lightning "connectPeer" = ConnectPeerRequest
  type MethodOutput Lightning "connectPeer" = ConnectPeerResponse
  type MethodStreamingType Lightning "connectPeer" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "disconnectPeer" where
  type MethodName Lightning "disconnectPeer" = "DisconnectPeer"
  type MethodInput Lightning "disconnectPeer" = DisconnectPeerRequest
  type MethodOutput Lightning "disconnectPeer" = DisconnectPeerResponse
  type MethodStreamingType Lightning "disconnectPeer" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listPeers" where
  type MethodName Lightning "listPeers" = "ListPeers"
  type MethodInput Lightning "listPeers" = ListPeersRequest
  type MethodOutput Lightning "listPeers" = ListPeersResponse
  type MethodStreamingType Lightning "listPeers" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribePeerEvents" where
  type MethodName Lightning "subscribePeerEvents" = "SubscribePeerEvents"
  type MethodInput Lightning "subscribePeerEvents" = PeerEventSubscription
  type MethodOutput Lightning "subscribePeerEvents" = PeerEvent
  type MethodStreamingType Lightning "subscribePeerEvents" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getInfo" where
  type MethodName Lightning "getInfo" = "GetInfo"
  type MethodInput Lightning "getInfo" = GetInfoRequest
  type MethodOutput Lightning "getInfo" = GetInfoResponse
  type MethodStreamingType Lightning "getInfo" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getRecoveryInfo" where
  type MethodName Lightning "getRecoveryInfo" = "GetRecoveryInfo"
  type MethodInput Lightning "getRecoveryInfo" = GetRecoveryInfoRequest
  type MethodOutput Lightning "getRecoveryInfo" = GetRecoveryInfoResponse
  type MethodStreamingType Lightning "getRecoveryInfo" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "pendingChannels" where
  type MethodName Lightning "pendingChannels" = "PendingChannels"
  type MethodInput Lightning "pendingChannels" = Proto.Lnrpc.Ln0.PendingChannelsRequest
  type MethodOutput Lightning "pendingChannels" = Proto.Lnrpc.Ln0.PendingChannelsResponse
  type MethodStreamingType Lightning "pendingChannels" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listChannels" where
  type MethodName Lightning "listChannels" = "ListChannels"
  type MethodInput Lightning "listChannels" = ListChannelsRequest
  type MethodOutput Lightning "listChannels" = ListChannelsResponse
  type MethodStreamingType Lightning "listChannels" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribeChannelEvents" where
  type MethodName Lightning "subscribeChannelEvents" = "SubscribeChannelEvents"
  type MethodInput Lightning "subscribeChannelEvents" = Proto.Lnrpc.Ln0.ChannelEventSubscription
  type MethodOutput Lightning "subscribeChannelEvents" = Proto.Lnrpc.Ln0.ChannelEventUpdate
  type MethodStreamingType Lightning "subscribeChannelEvents" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "closedChannels" where
  type MethodName Lightning "closedChannels" = "ClosedChannels"
  type MethodInput Lightning "closedChannels" = ClosedChannelsRequest
  type MethodOutput Lightning "closedChannels" = ClosedChannelsResponse
  type MethodStreamingType Lightning "closedChannels" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "openChannelSync" where
  type MethodName Lightning "openChannelSync" = "OpenChannelSync"
  type MethodInput Lightning "openChannelSync" = OpenChannelRequest
  type MethodOutput Lightning "openChannelSync" = Proto.Lnrpc.Ln0.ChannelPoint
  type MethodStreamingType Lightning "openChannelSync" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "openChannel" where
  type MethodName Lightning "openChannel" = "OpenChannel"
  type MethodInput Lightning "openChannel" = OpenChannelRequest
  type MethodOutput Lightning "openChannel" = OpenStatusUpdate
  type MethodStreamingType Lightning "openChannel" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "batchOpenChannel" where
  type MethodName Lightning "batchOpenChannel" = "BatchOpenChannel"
  type MethodInput Lightning "batchOpenChannel" = BatchOpenChannelRequest
  type MethodOutput Lightning "batchOpenChannel" = BatchOpenChannelResponse
  type MethodStreamingType Lightning "batchOpenChannel" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "fundingStateStep" where
  type MethodName Lightning "fundingStateStep" = "FundingStateStep"
  type MethodInput Lightning "fundingStateStep" = Proto.Lnrpc.Ln0.FundingTransitionMsg
  type MethodOutput Lightning "fundingStateStep" = Proto.Lnrpc.Ln0.FundingStateStepResp
  type MethodStreamingType Lightning "fundingStateStep" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "channelAcceptor" where
  type MethodName Lightning "channelAcceptor" = "ChannelAcceptor"
  type MethodInput Lightning "channelAcceptor" = ChannelAcceptResponse
  type MethodOutput Lightning "channelAcceptor" = ChannelAcceptRequest
  type MethodStreamingType Lightning "channelAcceptor" = 'Data.ProtoLens.Service.Types.BiDiStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "closeChannel" where
  type MethodName Lightning "closeChannel" = "CloseChannel"
  type MethodInput Lightning "closeChannel" = CloseChannelRequest
  type MethodOutput Lightning "closeChannel" = CloseStatusUpdate
  type MethodStreamingType Lightning "closeChannel" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "abandonChannel" where
  type MethodName Lightning "abandonChannel" = "AbandonChannel"
  type MethodInput Lightning "abandonChannel" = Proto.Lnrpc.Ln1.AbandonChannelRequest
  type MethodOutput Lightning "abandonChannel" = Proto.Lnrpc.Ln1.AbandonChannelResponse
  type MethodStreamingType Lightning "abandonChannel" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendPayment" where
  type MethodName Lightning "sendPayment" = "SendPayment"
  type MethodInput Lightning "sendPayment" = SendRequest
  type MethodOutput Lightning "sendPayment" = SendResponse
  type MethodStreamingType Lightning "sendPayment" = 'Data.ProtoLens.Service.Types.BiDiStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendPaymentSync" where
  type MethodName Lightning "sendPaymentSync" = "SendPaymentSync"
  type MethodInput Lightning "sendPaymentSync" = SendRequest
  type MethodOutput Lightning "sendPaymentSync" = SendResponse
  type MethodStreamingType Lightning "sendPaymentSync" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendToRoute" where
  type MethodName Lightning "sendToRoute" = "SendToRoute"
  type MethodInput Lightning "sendToRoute" = SendToRouteRequest
  type MethodOutput Lightning "sendToRoute" = SendResponse
  type MethodStreamingType Lightning "sendToRoute" = 'Data.ProtoLens.Service.Types.BiDiStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendToRouteSync" where
  type MethodName Lightning "sendToRouteSync" = "SendToRouteSync"
  type MethodInput Lightning "sendToRouteSync" = SendToRouteRequest
  type MethodOutput Lightning "sendToRouteSync" = SendResponse
  type MethodStreamingType Lightning "sendToRouteSync" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "addInvoice" where
  type MethodName Lightning "addInvoice" = "AddInvoice"
  type MethodInput Lightning "addInvoice" = Proto.Lnrpc.Ln1.Invoice
  type MethodOutput Lightning "addInvoice" = Proto.Lnrpc.Ln1.AddInvoiceResponse
  type MethodStreamingType Lightning "addInvoice" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listInvoices" where
  type MethodName Lightning "listInvoices" = "ListInvoices"
  type MethodInput Lightning "listInvoices" = Proto.Lnrpc.Ln1.ListInvoiceRequest
  type MethodOutput Lightning "listInvoices" = Proto.Lnrpc.Ln1.ListInvoiceResponse
  type MethodStreamingType Lightning "listInvoices" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "lookupInvoice" where
  type MethodName Lightning "lookupInvoice" = "LookupInvoice"
  type MethodInput Lightning "lookupInvoice" = Proto.Lnrpc.Ln1.PaymentHash
  type MethodOutput Lightning "lookupInvoice" = Proto.Lnrpc.Ln1.Invoice
  type MethodStreamingType Lightning "lookupInvoice" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribeInvoices" where
  type MethodName Lightning "subscribeInvoices" = "SubscribeInvoices"
  type MethodInput Lightning "subscribeInvoices" = Proto.Lnrpc.Ln1.InvoiceSubscription
  type MethodOutput Lightning "subscribeInvoices" = Proto.Lnrpc.Ln1.Invoice
  type MethodStreamingType Lightning "subscribeInvoices" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "decodePayReq" where
  type MethodName Lightning "decodePayReq" = "DecodePayReq"
  type MethodInput Lightning "decodePayReq" = Proto.Lnrpc.Ln1.PayReqString
  type MethodOutput Lightning "decodePayReq" = Proto.Lnrpc.Ln1.PayReq
  type MethodStreamingType Lightning "decodePayReq" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listPayments" where
  type MethodName Lightning "listPayments" = "ListPayments"
  type MethodInput Lightning "listPayments" = Proto.Lnrpc.Ln1.ListPaymentsRequest
  type MethodOutput Lightning "listPayments" = Proto.Lnrpc.Ln1.ListPaymentsResponse
  type MethodStreamingType Lightning "listPayments" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "deletePayment" where
  type MethodName Lightning "deletePayment" = "DeletePayment"
  type MethodInput Lightning "deletePayment" = Proto.Lnrpc.Ln1.DeletePaymentRequest
  type MethodOutput Lightning "deletePayment" = Proto.Lnrpc.Ln1.DeletePaymentResponse
  type MethodStreamingType Lightning "deletePayment" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "deleteAllPayments" where
  type MethodName Lightning "deleteAllPayments" = "DeleteAllPayments"
  type MethodInput Lightning "deleteAllPayments" = Proto.Lnrpc.Ln1.DeleteAllPaymentsRequest
  type MethodOutput Lightning "deleteAllPayments" = Proto.Lnrpc.Ln1.DeleteAllPaymentsResponse
  type MethodStreamingType Lightning "deleteAllPayments" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "describeGraph" where
  type MethodName Lightning "describeGraph" = "DescribeGraph"
  type MethodInput Lightning "describeGraph" = Proto.Lnrpc.Ln0.ChannelGraphRequest
  type MethodOutput Lightning "describeGraph" = Proto.Lnrpc.Ln0.ChannelGraph
  type MethodStreamingType Lightning "describeGraph" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getNodeMetrics" where
  type MethodName Lightning "getNodeMetrics" = "GetNodeMetrics"
  type MethodInput Lightning "getNodeMetrics" = Proto.Lnrpc.Ln0.NodeMetricsRequest
  type MethodOutput Lightning "getNodeMetrics" = Proto.Lnrpc.Ln0.NodeMetricsResponse
  type MethodStreamingType Lightning "getNodeMetrics" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getChanInfo" where
  type MethodName Lightning "getChanInfo" = "GetChanInfo"
  type MethodInput Lightning "getChanInfo" = Proto.Lnrpc.Ln0.ChanInfoRequest
  type MethodOutput Lightning "getChanInfo" = Proto.Lnrpc.Ln0.ChannelEdge
  type MethodStreamingType Lightning "getChanInfo" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getNodeInfo" where
  type MethodName Lightning "getNodeInfo" = "GetNodeInfo"
  type MethodInput Lightning "getNodeInfo" = Proto.Lnrpc.Ln0.NodeInfoRequest
  type MethodOutput Lightning "getNodeInfo" = Proto.Lnrpc.Ln0.NodeInfo
  type MethodStreamingType Lightning "getNodeInfo" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "queryRoutes" where
  type MethodName Lightning "queryRoutes" = "QueryRoutes"
  type MethodInput Lightning "queryRoutes" = Proto.Lnrpc.Ln0.QueryRoutesRequest
  type MethodOutput Lightning "queryRoutes" = Proto.Lnrpc.Ln0.QueryRoutesResponse
  type MethodStreamingType Lightning "queryRoutes" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "getNetworkInfo" where
  type MethodName Lightning "getNetworkInfo" = "GetNetworkInfo"
  type MethodInput Lightning "getNetworkInfo" = Proto.Lnrpc.Ln0.NetworkInfoRequest
  type MethodOutput Lightning "getNetworkInfo" = Proto.Lnrpc.Ln0.NetworkInfo
  type MethodStreamingType Lightning "getNetworkInfo" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "stopDaemon" where
  type MethodName Lightning "stopDaemon" = "StopDaemon"
  type MethodInput Lightning "stopDaemon" = Proto.Lnrpc.Ln0.StopRequest
  type MethodOutput Lightning "stopDaemon" = Proto.Lnrpc.Ln0.StopResponse
  type MethodStreamingType Lightning "stopDaemon" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribeChannelGraph" where
  type MethodName Lightning "subscribeChannelGraph" = "SubscribeChannelGraph"
  type MethodInput Lightning "subscribeChannelGraph" = Proto.Lnrpc.Ln0.GraphTopologySubscription
  type MethodOutput Lightning "subscribeChannelGraph" = Proto.Lnrpc.Ln0.GraphTopologyUpdate
  type MethodStreamingType Lightning "subscribeChannelGraph" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "debugLevel" where
  type MethodName Lightning "debugLevel" = "DebugLevel"
  type MethodInput Lightning "debugLevel" = Proto.Lnrpc.Ln1.DebugLevelRequest
  type MethodOutput Lightning "debugLevel" = Proto.Lnrpc.Ln1.DebugLevelResponse
  type MethodStreamingType Lightning "debugLevel" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "feeReport" where
  type MethodName Lightning "feeReport" = "FeeReport"
  type MethodInput Lightning "feeReport" = Proto.Lnrpc.Ln1.FeeReportRequest
  type MethodOutput Lightning "feeReport" = Proto.Lnrpc.Ln1.FeeReportResponse
  type MethodStreamingType Lightning "feeReport" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "updateChannelPolicy" where
  type MethodName Lightning "updateChannelPolicy" = "UpdateChannelPolicy"
  type MethodInput Lightning "updateChannelPolicy" = Proto.Lnrpc.Ln1.PolicyUpdateRequest
  type MethodOutput Lightning "updateChannelPolicy" = Proto.Lnrpc.Ln1.PolicyUpdateResponse
  type MethodStreamingType Lightning "updateChannelPolicy" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "forwardingHistory" where
  type MethodName Lightning "forwardingHistory" = "ForwardingHistory"
  type MethodInput Lightning "forwardingHistory" = Proto.Lnrpc.Ln1.ForwardingHistoryRequest
  type MethodOutput Lightning "forwardingHistory" = Proto.Lnrpc.Ln1.ForwardingHistoryResponse
  type MethodStreamingType Lightning "forwardingHistory" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "exportChannelBackup" where
  type MethodName Lightning "exportChannelBackup" = "ExportChannelBackup"
  type MethodInput Lightning "exportChannelBackup" = Proto.Lnrpc.Ln1.ExportChannelBackupRequest
  type MethodOutput Lightning "exportChannelBackup" = Proto.Lnrpc.Ln1.ChannelBackup
  type MethodStreamingType Lightning "exportChannelBackup" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "exportAllChannelBackups" where
  type MethodName Lightning "exportAllChannelBackups" = "ExportAllChannelBackups"
  type MethodInput Lightning "exportAllChannelBackups" = Proto.Lnrpc.Ln1.ChanBackupExportRequest
  type MethodOutput Lightning "exportAllChannelBackups" = Proto.Lnrpc.Ln1.ChanBackupSnapshot
  type MethodStreamingType Lightning "exportAllChannelBackups" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "verifyChanBackup" where
  type MethodName Lightning "verifyChanBackup" = "VerifyChanBackup"
  type MethodInput Lightning "verifyChanBackup" = Proto.Lnrpc.Ln1.ChanBackupSnapshot
  type MethodOutput Lightning "verifyChanBackup" = Proto.Lnrpc.Ln1.VerifyChanBackupResponse
  type MethodStreamingType Lightning "verifyChanBackup" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "restoreChannelBackups" where
  type MethodName Lightning "restoreChannelBackups" = "RestoreChannelBackups"
  type MethodInput Lightning "restoreChannelBackups" = Proto.Lnrpc.Ln1.RestoreChanBackupRequest
  type MethodOutput Lightning "restoreChannelBackups" = Proto.Lnrpc.Ln1.RestoreBackupResponse
  type MethodStreamingType Lightning "restoreChannelBackups" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribeChannelBackups" where
  type MethodName Lightning "subscribeChannelBackups" = "SubscribeChannelBackups"
  type MethodInput Lightning "subscribeChannelBackups" = Proto.Lnrpc.Ln1.ChannelBackupSubscription
  type MethodOutput Lightning "subscribeChannelBackups" = Proto.Lnrpc.Ln1.ChanBackupSnapshot
  type MethodStreamingType Lightning "subscribeChannelBackups" = 'Data.ProtoLens.Service.Types.ServerStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "bakeMacaroon" where
  type MethodName Lightning "bakeMacaroon" = "BakeMacaroon"
  type MethodInput Lightning "bakeMacaroon" = Proto.Lnrpc.Ln1.BakeMacaroonRequest
  type MethodOutput Lightning "bakeMacaroon" = Proto.Lnrpc.Ln1.BakeMacaroonResponse
  type MethodStreamingType Lightning "bakeMacaroon" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listMacaroonIDs" where
  type MethodName Lightning "listMacaroonIDs" = "ListMacaroonIDs"
  type MethodInput Lightning "listMacaroonIDs" = Proto.Lnrpc.Ln1.ListMacaroonIDsRequest
  type MethodOutput Lightning "listMacaroonIDs" = Proto.Lnrpc.Ln1.ListMacaroonIDsResponse
  type MethodStreamingType Lightning "listMacaroonIDs" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "deleteMacaroonID" where
  type MethodName Lightning "deleteMacaroonID" = "DeleteMacaroonID"
  type MethodInput Lightning "deleteMacaroonID" = Proto.Lnrpc.Ln1.DeleteMacaroonIDRequest
  type MethodOutput Lightning "deleteMacaroonID" = Proto.Lnrpc.Ln1.DeleteMacaroonIDResponse
  type MethodStreamingType Lightning "deleteMacaroonID" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "listPermissions" where
  type MethodName Lightning "listPermissions" = "ListPermissions"
  type MethodInput Lightning "listPermissions" = Proto.Lnrpc.Ln1.ListPermissionsRequest
  type MethodOutput Lightning "listPermissions" = Proto.Lnrpc.Ln1.ListPermissionsResponse
  type MethodStreamingType Lightning "listPermissions" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "checkMacaroonPermissions" where
  type MethodName Lightning "checkMacaroonPermissions" = "CheckMacaroonPermissions"
  type MethodInput Lightning "checkMacaroonPermissions" = Proto.Lnrpc.Ln1.CheckMacPermRequest
  type MethodOutput Lightning "checkMacaroonPermissions" = Proto.Lnrpc.Ln1.CheckMacPermResponse
  type MethodStreamingType Lightning "checkMacaroonPermissions" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "registerRPCMiddleware" where
  type MethodName Lightning "registerRPCMiddleware" = "RegisterRPCMiddleware"
  type MethodInput Lightning "registerRPCMiddleware" = Proto.Lnrpc.Ln1.RPCMiddlewareResponse
  type MethodOutput Lightning "registerRPCMiddleware" = Proto.Lnrpc.Ln1.RPCMiddlewareRequest
  type MethodStreamingType Lightning "registerRPCMiddleware" = 'Data.ProtoLens.Service.Types.BiDiStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "sendCustomMessage" where
  type MethodName Lightning "sendCustomMessage" = "SendCustomMessage"
  type MethodInput Lightning "sendCustomMessage" = SendCustomMessageRequest
  type MethodOutput Lightning "sendCustomMessage" = SendCustomMessageResponse
  type MethodStreamingType Lightning "sendCustomMessage" = 'Data.ProtoLens.Service.Types.NonStreaming
instance Data.ProtoLens.Service.Types.HasMethodImpl Lightning "subscribeCustomMessages" where
  type MethodName Lightning "subscribeCustomMessages" = "SubscribeCustomMessages"
  type MethodInput Lightning "subscribeCustomMessages" = SubscribeCustomMessagesRequest
  type MethodOutput Lightning "subscribeCustomMessages" = CustomMessage
  type MethodStreamingType Lightning "subscribeCustomMessages" = 'Data.ProtoLens.Service.Types.ServerStreaming
packedFileDescriptor :: Data.ByteString.ByteString
packedFileDescriptor
  = "\n\
    \\SIlightning.proto\DC2\ENQlnrpc\SUB\SIlnrpc/ln0.proto\SUB\SIlnrpc/ln1.proto\" \n\
    \\RSSubscribeCustomMessagesRequest\"K\n\
    \\rCustomMessage\DC2\DC2\n\
    \\EOTpeer\CAN\SOH \SOH(\fR\EOTpeer\DC2\DC2\n\
    \\EOTtype\CAN\STX \SOH(\rR\EOTtype\DC2\DC2\n\
    \\EOTdata\CAN\ETX \SOH(\fR\EOTdata\"V\n\
    \\CANSendCustomMessageRequest\DC2\DC2\n\
    \\EOTpeer\CAN\SOH \SOH(\fR\EOTpeer\DC2\DC2\n\
    \\EOTtype\CAN\STX \SOH(\rR\EOTtype\DC2\DC2\n\
    \\EOTdata\CAN\ETX \SOH(\fR\EOTdata\"\ESC\n\
    \\EMSendCustomMessageResponse\"\230\SOH\n\
    \\EOTUtxo\DC25\n\
    \\faddress_type\CAN\SOH \SOH(\SO2\DC2.lnrpc.AddressTypeR\vaddressType\DC2\CAN\n\
    \\aaddress\CAN\STX \SOH(\tR\aaddress\DC2\GS\n\
    \\n\
    \amount_sat\CAN\ETX \SOH(\ETXR\tamountSat\DC2\ESC\n\
    \\tpk_script\CAN\EOT \SOH(\tR\bpkScript\DC2+\n\
    \\boutpoint\CAN\ENQ \SOH(\v2\SI.lnrpc.OutPointR\boutpoint\DC2$\n\
    \\rconfirmations\CAN\ACK \SOH(\ETXR\rconfirmations\"\198\STX\n\
    \\vTransaction\DC2\ETB\n\
    \\atx_hash\CAN\SOH \SOH(\tR\ACKtxHash\DC2\SYN\n\
    \\ACKamount\CAN\STX \SOH(\ETXR\ACKamount\DC2+\n\
    \\DC1num_confirmations\CAN\ETX \SOH(\ENQR\DLEnumConfirmations\DC2\GS\n\
    \\n\
    \block_hash\CAN\EOT \SOH(\tR\tblockHash\DC2!\n\
    \\fblock_height\CAN\ENQ \SOH(\ENQR\vblockHeight\DC2\GS\n\
    \\n\
    \time_stamp\CAN\ACK \SOH(\ETXR\ttimeStamp\DC2\GS\n\
    \\n\
    \total_fees\CAN\a \SOH(\ETXR\ttotalFees\DC2%\n\
    \\SOdest_addresses\CAN\b \ETX(\tR\rdestAddresses\DC2\FS\n\
    \\n\
    \raw_tx_hex\CAN\t \SOH(\tR\brawTxHex\DC2\DC4\n\
    \\ENQlabel\CAN\n\
    \ \SOH(\tR\ENQlabel\"t\n\
    \\SYNGetTransactionsRequest\DC2!\n\
    \\fstart_height\CAN\SOH \SOH(\ENQR\vstartHeight\DC2\GS\n\
    \\n\
    \end_height\CAN\STX \SOH(\ENQR\tendHeight\DC2\CAN\n\
    \\aaccount\CAN\ETX \SOH(\tR\aaccount\"L\n\
    \\DC2TransactionDetails\DC26\n\
    \\ftransactions\CAN\SOH \ETX(\v2\DC2.lnrpc.TransactionR\ftransactions\"\234\ENQ\n\
    \\vSendRequest\DC2\DC2\n\
    \\EOTdest\CAN\SOH \SOH(\fR\EOTdest\DC2#\n\
    \\vdest_string\CAN\STX \SOH(\tR\n\
    \destStringB\STX\CAN\SOH\DC2\DLE\n\
    \\ETXamt\CAN\ETX \SOH(\ETXR\ETXamt\DC2\EM\n\
    \\bamt_msat\CAN\f \SOH(\ETXR\aamtMsat\DC2!\n\
    \\fpayment_hash\CAN\EOT \SOH(\fR\vpaymentHash\DC22\n\
    \\DC3payment_hash_string\CAN\ENQ \SOH(\tR\DC1paymentHashStringB\STX\CAN\SOH\DC2'\n\
    \\SIpayment_request\CAN\ACK \SOH(\tR\SOpaymentRequest\DC2(\n\
    \\DLEfinal_cltv_delta\CAN\a \SOH(\ENQR\SOfinalCltvDelta\DC2,\n\
    \\tfee_limit\CAN\b \SOH(\v2\SI.lnrpc.FeeLimitR\bfeeLimit\DC2,\n\
    \\DLEoutgoing_chan_id\CAN\t \SOH(\EOTR\SOoutgoingChanIdB\STX0\SOH\DC2&\n\
    \\SIlast_hop_pubkey\CAN\r \SOH(\fR\rlastHopPubkey\DC2\GS\n\
    \\n\
    \cltv_limit\CAN\n\
    \ \SOH(\rR\tcltvLimit\DC2Y\n\
    \\DC3dest_custom_records\CAN\v \ETX(\v2).lnrpc.SendRequest.DestCustomRecordsEntryR\DC1destCustomRecords\DC2,\n\
    \\DC2allow_self_payment\CAN\SO \SOH(\bR\DLEallowSelfPayment\DC26\n\
    \\rdest_features\CAN\SI \ETX(\SO2\DC1.lnrpc.FeatureBitR\fdestFeatures\DC2!\n\
    \\fpayment_addr\CAN\DLE \SOH(\fR\vpaymentAddr\SUBD\n\
    \\SYNDestCustomRecordsEntry\DC2\DLE\n\
    \\ETXkey\CAN\SOH \SOH(\EOTR\ETXkey\DC2\DC4\n\
    \\ENQvalue\CAN\STX \SOH(\fR\ENQvalue:\STX8\SOH\"\180\SOH\n\
    \\fSendResponse\DC2#\n\
    \\rpayment_error\CAN\SOH \SOH(\tR\fpaymentError\DC2)\n\
    \\DLEpayment_preimage\CAN\STX \SOH(\fR\SIpaymentPreimage\DC21\n\
    \\rpayment_route\CAN\ETX \SOH(\v2\f.lnrpc.RouteR\fpaymentRoute\DC2!\n\
    \\fpayment_hash\CAN\EOT \SOH(\fR\vpaymentHash\"\149\SOH\n\
    \\DC2SendToRouteRequest\DC2!\n\
    \\fpayment_hash\CAN\SOH \SOH(\fR\vpaymentHash\DC22\n\
    \\DC3payment_hash_string\CAN\STX \SOH(\tR\DC1paymentHashStringB\STX\CAN\SOH\DC2\"\n\
    \\ENQroute\CAN\EOT \SOH(\v2\f.lnrpc.RouteR\ENQrouteJ\EOT\b\ETX\DLE\EOT\"\154\EOT\n\
    \\DC4ChannelAcceptRequest\DC2\US\n\
    \\vnode_pubkey\CAN\SOH \SOH(\fR\n\
    \nodePubkey\DC2\GS\n\
    \\n\
    \chain_hash\CAN\STX \SOH(\fR\tchainHash\DC2&\n\
    \\SIpending_chan_id\CAN\ETX \SOH(\fR\rpendingChanId\DC2\US\n\
    \\vfunding_amt\CAN\EOT \SOH(\EOTR\n\
    \fundingAmt\DC2\EM\n\
    \\bpush_amt\CAN\ENQ \SOH(\EOTR\apushAmt\DC2\GS\n\
    \\n\
    \dust_limit\CAN\ACK \SOH(\EOTR\tdustLimit\DC2-\n\
    \\DC3max_value_in_flight\CAN\a \SOH(\EOTR\DLEmaxValueInFlight\DC2'\n\
    \\SIchannel_reserve\CAN\b \SOH(\EOTR\SOchannelReserve\DC2\EM\n\
    \\bmin_htlc\CAN\t \SOH(\EOTR\aminHtlc\DC2\FS\n\
    \\n\
    \fee_per_kw\CAN\n\
    \ \SOH(\EOTR\bfeePerKw\DC2\ESC\n\
    \\tcsv_delay\CAN\v \SOH(\rR\bcsvDelay\DC2,\n\
    \\DC2max_accepted_htlcs\CAN\f \SOH(\rR\DLEmaxAcceptedHtlcs\DC2#\n\
    \\rchannel_flags\CAN\r \SOH(\rR\fchannelFlags\DC2>\n\
    \\SIcommitment_type\CAN\SO \SOH(\SO2\NAK.lnrpc.CommitmentTypeR\SOcommitmentType\"\243\STX\n\
    \\NAKChannelAcceptResponse\DC2\SYN\n\
    \\ACKaccept\CAN\SOH \SOH(\bR\ACKaccept\DC2&\n\
    \\SIpending_chan_id\CAN\STX \SOH(\fR\rpendingChanId\DC2\DC4\n\
    \\ENQerror\CAN\ETX \SOH(\tR\ENQerror\DC2)\n\
    \\DLEupfront_shutdown\CAN\EOT \SOH(\tR\SIupfrontShutdown\DC2\ESC\n\
    \\tcsv_delay\CAN\ENQ \SOH(\rR\bcsvDelay\DC2\US\n\
    \\vreserve_sat\CAN\ACK \SOH(\EOTR\n\
    \reserveSat\DC2+\n\
    \\DC2in_flight_max_msat\CAN\a \SOH(\EOTR\SIinFlightMaxMsat\DC2$\n\
    \\SOmax_htlc_count\CAN\b \SOH(\rR\fmaxHtlcCount\DC2\RS\n\
    \\vmin_htlc_in\CAN\t \SOH(\EOTR\tminHtlcIn\DC2(\n\
    \\DLEmin_accept_depth\CAN\n\
    \ \SOH(\rR\SOminAcceptDepth\">\n\
    \\DLELightningAddress\DC2\SYN\n\
    \\ACKpubkey\CAN\SOH \SOH(\tR\ACKpubkey\DC2\DC2\n\
    \\EOThost\CAN\STX \SOH(\tR\EOThost\"\145\STX\n\
    \\DC2EstimateFeeRequest\DC2O\n\
    \\fAddrToAmount\CAN\SOH \ETX(\v2+.lnrpc.EstimateFeeRequest.AddrToAmountEntryR\fAddrToAmount\DC2\US\n\
    \\vtarget_conf\CAN\STX \SOH(\ENQR\n\
    \targetConf\DC2\ESC\n\
    \\tmin_confs\CAN\ETX \SOH(\ENQR\bminConfs\DC2+\n\
    \\DC1spend_unconfirmed\CAN\EOT \SOH(\bR\DLEspendUnconfirmed\SUB?\n\
    \\DC1AddrToAmountEntry\DC2\DLE\n\
    \\ETXkey\CAN\SOH \SOH(\tR\ETXkey\DC2\DC4\n\
    \\ENQvalue\CAN\STX \SOH(\ETXR\ENQvalue:\STX8\SOH\"\135\SOH\n\
    \\DC3EstimateFeeResponse\DC2\ETB\n\
    \\afee_sat\CAN\SOH \SOH(\ETXR\ACKfeeSat\DC23\n\
    \\DC4feerate_sat_per_byte\CAN\STX \SOH(\ETXR\DC1feerateSatPerByteB\STX\CAN\SOH\DC2\"\n\
    \\rsat_per_vbyte\CAN\ETX \SOH(\EOTR\vsatPerVbyte\"\235\STX\n\
    \\SISendManyRequest\DC2L\n\
    \\fAddrToAmount\CAN\SOH \ETX(\v2(.lnrpc.SendManyRequest.AddrToAmountEntryR\fAddrToAmount\DC2\US\n\
    \\vtarget_conf\CAN\ETX \SOH(\ENQR\n\
    \targetConf\DC2\"\n\
    \\rsat_per_vbyte\CAN\EOT \SOH(\EOTR\vsatPerVbyte\DC2$\n\
    \\fsat_per_byte\CAN\ENQ \SOH(\ETXR\n\
    \satPerByteB\STX\CAN\SOH\DC2\DC4\n\
    \\ENQlabel\CAN\ACK \SOH(\tR\ENQlabel\DC2\ESC\n\
    \\tmin_confs\CAN\a \SOH(\ENQR\bminConfs\DC2+\n\
    \\DC1spend_unconfirmed\CAN\b \SOH(\bR\DLEspendUnconfirmed\SUB?\n\
    \\DC1AddrToAmountEntry\DC2\DLE\n\
    \\ETXkey\CAN\SOH \SOH(\tR\ETXkey\DC2\DC4\n\
    \\ENQvalue\CAN\STX \SOH(\ETXR\ENQvalue:\STX8\SOH\"&\n\
    \\DLESendManyResponse\DC2\DC2\n\
    \\EOTtxid\CAN\SOH \SOH(\tR\EOTtxid\"\164\STX\n\
    \\DLESendCoinsRequest\DC2\DC2\n\
    \\EOTaddr\CAN\SOH \SOH(\tR\EOTaddr\DC2\SYN\n\
    \\ACKamount\CAN\STX \SOH(\ETXR\ACKamount\DC2\US\n\
    \\vtarget_conf\CAN\ETX \SOH(\ENQR\n\
    \targetConf\DC2\"\n\
    \\rsat_per_vbyte\CAN\EOT \SOH(\EOTR\vsatPerVbyte\DC2$\n\
    \\fsat_per_byte\CAN\ENQ \SOH(\ETXR\n\
    \satPerByteB\STX\CAN\SOH\DC2\EM\n\
    \\bsend_all\CAN\ACK \SOH(\bR\asendAll\DC2\DC4\n\
    \\ENQlabel\CAN\a \SOH(\tR\ENQlabel\DC2\ESC\n\
    \\tmin_confs\CAN\b \SOH(\ENQR\bminConfs\DC2+\n\
    \\DC1spend_unconfirmed\CAN\t \SOH(\bR\DLEspendUnconfirmed\"'\n\
    \\DC1SendCoinsResponse\DC2\DC2\n\
    \\EOTtxid\CAN\SOH \SOH(\tR\EOTtxid\"h\n\
    \\DC2ListUnspentRequest\DC2\ESC\n\
    \\tmin_confs\CAN\SOH \SOH(\ENQR\bminConfs\DC2\ESC\n\
    \\tmax_confs\CAN\STX \SOH(\ENQR\bmaxConfs\DC2\CAN\n\
    \\aaccount\CAN\ETX \SOH(\tR\aaccount\"8\n\
    \\DC3ListUnspentResponse\DC2!\n\
    \\ENQutxos\CAN\SOH \ETX(\v2\v.lnrpc.UtxoR\ENQutxos\"U\n\
    \\DC1NewAddressRequest\DC2&\n\
    \\EOTtype\CAN\SOH \SOH(\SO2\DC2.lnrpc.AddressTypeR\EOTtype\DC2\CAN\n\
    \\aaccount\CAN\STX \SOH(\tR\aaccount\".\n\
    \\DC2NewAddressResponse\DC2\CAN\n\
    \\aaddress\CAN\SOH \SOH(\tR\aaddress\"G\n\
    \\DC2SignMessageRequest\DC2\DLE\n\
    \\ETXmsg\CAN\SOH \SOH(\fR\ETXmsg\DC2\US\n\
    \\vsingle_hash\CAN\STX \SOH(\bR\n\
    \singleHash\"3\n\
    \\DC3SignMessageResponse\DC2\FS\n\
    \\tsignature\CAN\SOH \SOH(\tR\tsignature\"F\n\
    \\DC4VerifyMessageRequest\DC2\DLE\n\
    \\ETXmsg\CAN\SOH \SOH(\fR\ETXmsg\DC2\FS\n\
    \\tsignature\CAN\STX \SOH(\tR\tsignature\"E\n\
    \\NAKVerifyMessageResponse\DC2\DC4\n\
    \\ENQvalid\CAN\SOH \SOH(\bR\ENQvalid\DC2\SYN\n\
    \\ACKpubkey\CAN\STX \SOH(\tR\ACKpubkey\"o\n\
    \\DC2ConnectPeerRequest\DC2+\n\
    \\EOTaddr\CAN\SOH \SOH(\v2\ETB.lnrpc.LightningAddressR\EOTaddr\DC2\DC2\n\
    \\EOTperm\CAN\STX \SOH(\bR\EOTperm\DC2\CAN\n\
    \\atimeout\CAN\ETX \SOH(\EOTR\atimeout\"\NAK\n\
    \\DC3ConnectPeerResponse\"0\n\
    \\NAKDisconnectPeerRequest\DC2\ETB\n\
    \\apub_key\CAN\SOH \SOH(\tR\ACKpubKey\"\CAN\n\
    \\SYNDisconnectPeerResponse\"\179\SOH\n\
    \\DC3ListChannelsRequest\DC2\US\n\
    \\vactive_only\CAN\SOH \SOH(\bR\n\
    \activeOnly\DC2#\n\
    \\rinactive_only\CAN\STX \SOH(\bR\finactiveOnly\DC2\US\n\
    \\vpublic_only\CAN\ETX \SOH(\bR\n\
    \publicOnly\DC2!\n\
    \\fprivate_only\CAN\EOT \SOH(\bR\vprivateOnly\DC2\DC2\n\
    \\EOTpeer\CAN\ENQ \SOH(\fR\EOTpeer\"B\n\
    \\DC4ListChannelsResponse\DC2*\n\
    \\bchannels\CAN\v \ETX(\v2\SO.lnrpc.ChannelR\bchannels\"\222\SOH\n\
    \\NAKClosedChannelsRequest\DC2 \n\
    \\vcooperative\CAN\SOH \SOH(\bR\vcooperative\DC2\US\n\
    \\vlocal_force\CAN\STX \SOH(\bR\n\
    \localForce\DC2!\n\
    \\fremote_force\CAN\ETX \SOH(\bR\vremoteForce\DC2\SYN\n\
    \\ACKbreach\CAN\EOT \SOH(\bR\ACKbreach\DC2)\n\
    \\DLEfunding_canceled\CAN\ENQ \SOH(\bR\SIfundingCanceled\DC2\FS\n\
    \\tabandoned\CAN\ACK \SOH(\bR\tabandoned\"P\n\
    \\SYNClosedChannelsResponse\DC26\n\
    \\bchannels\CAN\SOH \ETX(\v2\SUB.lnrpc.ChannelCloseSummaryR\bchannels\"\139\ENQ\n\
    \\EOTPeer\DC2\ETB\n\
    \\apub_key\CAN\SOH \SOH(\tR\ACKpubKey\DC2\CAN\n\
    \\aaddress\CAN\ETX \SOH(\tR\aaddress\DC2\GS\n\
    \\n\
    \bytes_sent\CAN\EOT \SOH(\EOTR\tbytesSent\DC2\GS\n\
    \\n\
    \bytes_recv\CAN\ENQ \SOH(\EOTR\tbytesRecv\DC2\EM\n\
    \\bsat_sent\CAN\ACK \SOH(\ETXR\asatSent\DC2\EM\n\
    \\bsat_recv\CAN\a \SOH(\ETXR\asatRecv\DC2\CAN\n\
    \\ainbound\CAN\b \SOH(\bR\ainbound\DC2\ESC\n\
    \\tping_time\CAN\t \SOH(\ETXR\bpingTime\DC21\n\
    \\tsync_type\CAN\n\
    \ \SOH(\SO2\DC4.lnrpc.Peer.SyncTypeR\bsyncType\DC25\n\
    \\bfeatures\CAN\v \ETX(\v2\EM.lnrpc.Peer.FeaturesEntryR\bfeatures\DC2/\n\
    \\ACKerrors\CAN\f \ETX(\v2\ETB.lnrpc.TimestampedErrorR\ACKerrors\DC2\GS\n\
    \\n\
    \flap_count\CAN\r \SOH(\ENQR\tflapCount\DC2 \n\
    \\flast_flap_ns\CAN\SO \SOH(\ETXR\n\
    \lastFlapNs\DC2*\n\
    \\DC1last_ping_payload\CAN\SI \SOH(\fR\SIlastPingPayload\SUBK\n\
    \\rFeaturesEntry\DC2\DLE\n\
    \\ETXkey\CAN\SOH \SOH(\rR\ETXkey\DC2$\n\
    \\ENQvalue\CAN\STX \SOH(\v2\SO.lnrpc.FeatureR\ENQvalue:\STX8\SOH\"P\n\
    \\bSyncType\DC2\DLE\n\
    \\fUNKNOWN_SYNC\DLE\NUL\DC2\SI\n\
    \\vACTIVE_SYNC\DLE\SOH\DC2\DLE\n\
    \\fPASSIVE_SYNC\DLE\STX\DC2\SI\n\
    \\vPINNED_SYNC\DLE\ETX\"F\n\
    \\DLETimestampedError\DC2\FS\n\
    \\ttimestamp\CAN\SOH \SOH(\EOTR\ttimestamp\DC2\DC4\n\
    \\ENQerror\CAN\STX \SOH(\tR\ENQerror\"5\n\
    \\DLEListPeersRequest\DC2!\n\
    \\flatest_error\CAN\SOH \SOH(\bR\vlatestError\"6\n\
    \\DC1ListPeersResponse\DC2!\n\
    \\ENQpeers\CAN\SOH \ETX(\v2\v.lnrpc.PeerR\ENQpeers\"\ETB\n\
    \\NAKPeerEventSubscription\"\132\SOH\n\
    \\tPeerEvent\DC2\ETB\n\
    \\apub_key\CAN\SOH \SOH(\tR\ACKpubKey\DC2.\n\
    \\EOTtype\CAN\STX \SOH(\SO2\SUB.lnrpc.PeerEvent.EventTypeR\EOTtype\".\n\
    \\tEventType\DC2\SI\n\
    \\vPEER_ONLINE\DLE\NUL\DC2\DLE\n\
    \\fPEER_OFFLINE\DLE\SOH\"\DLE\n\
    \\SOGetInfoRequest\"\135\ACK\n\
    \\SIGetInfoResponse\DC2\CAN\n\
    \\aversion\CAN\SO \SOH(\tR\aversion\DC2\US\n\
    \\vcommit_hash\CAN\DC4 \SOH(\tR\n\
    \commitHash\DC2'\n\
    \\SIidentity_pubkey\CAN\SOH \SOH(\tR\SOidentityPubkey\DC2\DC4\n\
    \\ENQalias\CAN\STX \SOH(\tR\ENQalias\DC2\DC4\n\
    \\ENQcolor\CAN\DC1 \SOH(\tR\ENQcolor\DC20\n\
    \\DC4num_pending_channels\CAN\ETX \SOH(\rR\DC2numPendingChannels\DC2.\n\
    \\DC3num_active_channels\CAN\EOT \SOH(\rR\DC1numActiveChannels\DC22\n\
    \\NAKnum_inactive_channels\CAN\SI \SOH(\rR\DC3numInactiveChannels\DC2\ESC\n\
    \\tnum_peers\CAN\ENQ \SOH(\rR\bnumPeers\DC2!\n\
    \\fblock_height\CAN\ACK \SOH(\rR\vblockHeight\DC2\GS\n\
    \\n\
    \block_hash\CAN\b \SOH(\tR\tblockHash\DC22\n\
    \\NAKbest_header_timestamp\CAN\r \SOH(\ETXR\DC3bestHeaderTimestamp\DC2&\n\
    \\SIsynced_to_chain\CAN\t \SOH(\bR\rsyncedToChain\DC2&\n\
    \\SIsynced_to_graph\CAN\DC2 \SOH(\bR\rsyncedToGraph\DC2\FS\n\
    \\atestnet\CAN\n\
    \ \SOH(\bR\atestnetB\STX\CAN\SOH\DC2$\n\
    \\ACKchains\CAN\DLE \ETX(\v2\f.lnrpc.ChainR\ACKchains\DC2\DC2\n\
    \\EOTuris\CAN\f \ETX(\tR\EOTuris\DC2@\n\
    \\bfeatures\CAN\DC3 \ETX(\v2$.lnrpc.GetInfoResponse.FeaturesEntryR\bfeatures\SUBK\n\
    \\rFeaturesEntry\DC2\DLE\n\
    \\ETXkey\CAN\SOH \SOH(\rR\ETXkey\DC2$\n\
    \\ENQvalue\CAN\STX \SOH(\v2\SO.lnrpc.FeatureR\ENQvalue:\STX8\SOHJ\EOT\b\v\DLE\f\"\CAN\n\
    \\SYNGetRecoveryInfoRequest\"\135\SOH\n\
    \\ETBGetRecoveryInfoResponse\DC2#\n\
    \\rrecovery_mode\CAN\SOH \SOH(\bR\frecoveryMode\DC2+\n\
    \\DC1recovery_finished\CAN\STX \SOH(\bR\DLErecoveryFinished\DC2\SUB\n\
    \\bprogress\CAN\ETX \SOH(\SOHR\bprogress\"7\n\
    \\ENQChain\DC2\DC4\n\
    \\ENQchain\CAN\SOH \SOH(\tR\ENQchain\DC2\CAN\n\
    \\anetwork\CAN\STX \SOH(\tR\anetwork\"z\n\
    \\DC2ConfirmationUpdate\DC2\ESC\n\
    \\tblock_sha\CAN\SOH \SOH(\fR\bblockSha\DC2!\n\
    \\fblock_height\CAN\STX \SOH(\ENQR\vblockHeight\DC2$\n\
    \\SOnum_confs_left\CAN\ETX \SOH(\rR\fnumConfsLeft\"M\n\
    \\DC1ChannelOpenUpdate\DC28\n\
    \\rchannel_point\CAN\SOH \SOH(\v2\DC3.lnrpc.ChannelPointR\fchannelPoint\"Q\n\
    \\DC2ChannelCloseUpdate\DC2!\n\
    \\fclosing_txid\CAN\SOH \SOH(\fR\vclosingTxid\DC2\CAN\n\
    \\asuccess\CAN\STX \SOH(\bR\asuccess\"\251\SOH\n\
    \\DC3CloseChannelRequest\DC28\n\
    \\rchannel_point\CAN\SOH \SOH(\v2\DC3.lnrpc.ChannelPointR\fchannelPoint\DC2\DC4\n\
    \\ENQforce\CAN\STX \SOH(\bR\ENQforce\DC2\US\n\
    \\vtarget_conf\CAN\ETX \SOH(\ENQR\n\
    \targetConf\DC2$\n\
    \\fsat_per_byte\CAN\EOT \SOH(\ETXR\n\
    \satPerByteB\STX\CAN\SOH\DC2)\n\
    \\DLEdelivery_address\CAN\ENQ \SOH(\tR\SIdeliveryAddress\DC2\"\n\
    \\rsat_per_vbyte\CAN\ACK \SOH(\EOTR\vsatPerVbyte\"\150\SOH\n\
    \\DC1CloseStatusUpdate\DC2;\n\
    \\rclose_pending\CAN\SOH \SOH(\v2\DC4.lnrpc.PendingUpdateH\NULR\fclosePending\DC2:\n\
    \\n\
    \chan_close\CAN\ETX \SOH(\v2\EM.lnrpc.ChannelCloseUpdateH\NULR\tchanCloseB\b\n\
    \\ACKupdate\"y\n\
    \\DC3ReadyForPsbtFunding\DC2'\n\
    \\SIfunding_address\CAN\SOH \SOH(\tR\SOfundingAddress\DC2%\n\
    \\SOfunding_amount\CAN\STX \SOH(\ETXR\rfundingAmount\DC2\DC2\n\
    \\EOTpsbt\CAN\ETX \SOH(\fR\EOTpsbt\"\243\SOH\n\
    \\ETBBatchOpenChannelRequest\DC23\n\
    \\bchannels\CAN\SOH \ETX(\v2\ETB.lnrpc.BatchOpenChannelR\bchannels\DC2\US\n\
    \\vtarget_conf\CAN\STX \SOH(\ENQR\n\
    \targetConf\DC2\"\n\
    \\rsat_per_vbyte\CAN\ETX \SOH(\ETXR\vsatPerVbyte\DC2\ESC\n\
    \\tmin_confs\CAN\EOT \SOH(\ENQR\bminConfs\DC2+\n\
    \\DC1spend_unconfirmed\CAN\ENQ \SOH(\bR\DLEspendUnconfirmed\DC2\DC4\n\
    \\ENQlabel\CAN\ACK \SOH(\tR\ENQlabel\"\245\STX\n\
    \\DLEBatchOpenChannel\DC2\US\n\
    \\vnode_pubkey\CAN\SOH \SOH(\fR\n\
    \nodePubkey\DC20\n\
    \\DC4local_funding_amount\CAN\STX \SOH(\ETXR\DC2localFundingAmount\DC2\EM\n\
    \\bpush_sat\CAN\ETX \SOH(\ETXR\apushSat\DC2\CAN\n\
    \\aprivate\CAN\EOT \SOH(\bR\aprivate\DC2\"\n\
    \\rmin_htlc_msat\CAN\ENQ \SOH(\ETXR\vminHtlcMsat\DC2(\n\
    \\DLEremote_csv_delay\CAN\ACK \SOH(\rR\SOremoteCsvDelay\DC2#\n\
    \\rclose_address\CAN\a \SOH(\tR\fcloseAddress\DC2&\n\
    \\SIpending_chan_id\CAN\b \SOH(\fR\rpendingChanId\DC2>\n\
    \\SIcommitment_type\CAN\t \SOH(\SO2\NAK.lnrpc.CommitmentTypeR\SOcommitmentType\"[\n\
    \\CANBatchOpenChannelResponse\DC2?\n\
    \\DLEpending_channels\CAN\SOH \ETX(\v2\DC4.lnrpc.PendingUpdateR\SIpendingChannels\"\128\ACK\n\
    \\DC2OpenChannelRequest\DC2\"\n\
    \\rsat_per_vbyte\CAN\SOH \SOH(\EOTR\vsatPerVbyte\DC2\US\n\
    \\vnode_pubkey\CAN\STX \SOH(\fR\n\
    \nodePubkey\DC20\n\
    \\DC2node_pubkey_string\CAN\ETX \SOH(\tR\DLEnodePubkeyStringB\STX\CAN\SOH\DC20\n\
    \\DC4local_funding_amount\CAN\EOT \SOH(\ETXR\DC2localFundingAmount\DC2\EM\n\
    \\bpush_sat\CAN\ENQ \SOH(\ETXR\apushSat\DC2\US\n\
    \\vtarget_conf\CAN\ACK \SOH(\ENQR\n\
    \targetConf\DC2$\n\
    \\fsat_per_byte\CAN\a \SOH(\ETXR\n\
    \satPerByteB\STX\CAN\SOH\DC2\CAN\n\
    \\aprivate\CAN\b \SOH(\bR\aprivate\DC2\"\n\
    \\rmin_htlc_msat\CAN\t \SOH(\ETXR\vminHtlcMsat\DC2(\n\
    \\DLEremote_csv_delay\CAN\n\
    \ \SOH(\rR\SOremoteCsvDelay\DC2\ESC\n\
    \\tmin_confs\CAN\v \SOH(\ENQR\bminConfs\DC2+\n\
    \\DC1spend_unconfirmed\CAN\f \SOH(\bR\DLEspendUnconfirmed\DC2#\n\
    \\rclose_address\CAN\r \SOH(\tR\fcloseAddress\DC25\n\
    \\ffunding_shim\CAN\SO \SOH(\v2\DC2.lnrpc.FundingShimR\vfundingShim\DC2C\n\
    \\USremote_max_value_in_flight_msat\CAN\SI \SOH(\EOTR\SUBremoteMaxValueInFlightMsat\DC2(\n\
    \\DLEremote_max_htlcs\CAN\DLE \SOH(\rR\SOremoteMaxHtlcs\DC2\"\n\
    \\rmax_local_csv\CAN\DC1 \SOH(\rR\vmaxLocalCsv\DC2>\n\
    \\SIcommitment_type\CAN\DC2 \SOH(\SO2\NAK.lnrpc.CommitmentTypeR\SOcommitmentType\"\243\SOH\n\
    \\DLEOpenStatusUpdate\DC29\n\
    \\fchan_pending\CAN\SOH \SOH(\v2\DC4.lnrpc.PendingUpdateH\NULR\vchanPending\DC27\n\
    \\tchan_open\CAN\ETX \SOH(\v2\CAN.lnrpc.ChannelOpenUpdateH\NULR\bchanOpen\DC29\n\
    \\tpsbt_fund\CAN\ENQ \SOH(\v2\SUB.lnrpc.ReadyForPsbtFundingH\NULR\bpsbtFund\DC2&\n\
    \\SIpending_chan_id\CAN\EOT \SOH(\fR\rpendingChanIdB\b\n\
    \\ACKupdate*}\n\
    \\vAddressType\DC2\ETB\n\
    \\DC3WITNESS_PUBKEY_HASH\DLE\NUL\DC2\SYN\n\
    \\DC2NESTED_PUBKEY_HASH\DLE\SOH\DC2\RS\n\
    \\SUBUNUSED_WITNESS_PUBKEY_HASH\DLE\STX\DC2\GS\n\
    \\EMUNUSED_NESTED_PUBKEY_HASH\DLE\ETX2\201%\n\
    \\tLightning\DC2J\n\
    \\rWalletBalance\DC2\ESC.lnrpc.WalletBalanceRequest\SUB\FS.lnrpc.WalletBalanceResponse\DC2M\n\
    \\SOChannelBalance\DC2\FS.lnrpc.ChannelBalanceRequest\SUB\GS.lnrpc.ChannelBalanceResponse\DC2K\n\
    \\SIGetTransactions\DC2\GS.lnrpc.GetTransactionsRequest\SUB\EM.lnrpc.TransactionDetails\DC2D\n\
    \\vEstimateFee\DC2\EM.lnrpc.EstimateFeeRequest\SUB\SUB.lnrpc.EstimateFeeResponse\DC2>\n\
    \\tSendCoins\DC2\ETB.lnrpc.SendCoinsRequest\SUB\CAN.lnrpc.SendCoinsResponse\DC2D\n\
    \\vListUnspent\DC2\EM.lnrpc.ListUnspentRequest\SUB\SUB.lnrpc.ListUnspentResponse\DC2L\n\
    \\NAKSubscribeTransactions\DC2\GS.lnrpc.GetTransactionsRequest\SUB\DC2.lnrpc.Transaction0\SOH\DC2;\n\
    \\bSendMany\DC2\SYN.lnrpc.SendManyRequest\SUB\ETB.lnrpc.SendManyResponse\DC2A\n\
    \\n\
    \NewAddress\DC2\CAN.lnrpc.NewAddressRequest\SUB\EM.lnrpc.NewAddressResponse\DC2D\n\
    \\vSignMessage\DC2\EM.lnrpc.SignMessageRequest\SUB\SUB.lnrpc.SignMessageResponse\DC2J\n\
    \\rVerifyMessage\DC2\ESC.lnrpc.VerifyMessageRequest\SUB\FS.lnrpc.VerifyMessageResponse\DC2D\n\
    \\vConnectPeer\DC2\EM.lnrpc.ConnectPeerRequest\SUB\SUB.lnrpc.ConnectPeerResponse\DC2M\n\
    \\SODisconnectPeer\DC2\FS.lnrpc.DisconnectPeerRequest\SUB\GS.lnrpc.DisconnectPeerResponse\DC2>\n\
    \\tListPeers\DC2\ETB.lnrpc.ListPeersRequest\SUB\CAN.lnrpc.ListPeersResponse\DC2G\n\
    \\DC3SubscribePeerEvents\DC2\FS.lnrpc.PeerEventSubscription\SUB\DLE.lnrpc.PeerEvent0\SOH\DC28\n\
    \\aGetInfo\DC2\NAK.lnrpc.GetInfoRequest\SUB\SYN.lnrpc.GetInfoResponse\DC2P\n\
    \\SIGetRecoveryInfo\DC2\GS.lnrpc.GetRecoveryInfoRequest\SUB\RS.lnrpc.GetRecoveryInfoResponse\DC2P\n\
    \\SIPendingChannels\DC2\GS.lnrpc.PendingChannelsRequest\SUB\RS.lnrpc.PendingChannelsResponse\DC2G\n\
    \\fListChannels\DC2\SUB.lnrpc.ListChannelsRequest\SUB\ESC.lnrpc.ListChannelsResponse\DC2V\n\
    \\SYNSubscribeChannelEvents\DC2\US.lnrpc.ChannelEventSubscription\SUB\EM.lnrpc.ChannelEventUpdate0\SOH\DC2M\n\
    \\SOClosedChannels\DC2\FS.lnrpc.ClosedChannelsRequest\SUB\GS.lnrpc.ClosedChannelsResponse\DC2A\n\
    \\SIOpenChannelSync\DC2\EM.lnrpc.OpenChannelRequest\SUB\DC3.lnrpc.ChannelPoint\DC2C\n\
    \\vOpenChannel\DC2\EM.lnrpc.OpenChannelRequest\SUB\ETB.lnrpc.OpenStatusUpdate0\SOH\DC2S\n\
    \\DLEBatchOpenChannel\DC2\RS.lnrpc.BatchOpenChannelRequest\SUB\US.lnrpc.BatchOpenChannelResponse\DC2L\n\
    \\DLEFundingStateStep\DC2\ESC.lnrpc.FundingTransitionMsg\SUB\ESC.lnrpc.FundingStateStepResp\DC2P\n\
    \\SIChannelAcceptor\DC2\FS.lnrpc.ChannelAcceptResponse\SUB\ESC.lnrpc.ChannelAcceptRequest(\SOH0\SOH\DC2F\n\
    \\fCloseChannel\DC2\SUB.lnrpc.CloseChannelRequest\SUB\CAN.lnrpc.CloseStatusUpdate0\SOH\DC2M\n\
    \\SOAbandonChannel\DC2\FS.lnrpc.AbandonChannelRequest\SUB\GS.lnrpc.AbandonChannelResponse\DC2?\n\
    \\vSendPayment\DC2\DC2.lnrpc.SendRequest\SUB\DC3.lnrpc.SendResponse\"\ETX\136\STX\SOH(\SOH0\SOH\DC2:\n\
    \\SISendPaymentSync\DC2\DC2.lnrpc.SendRequest\SUB\DC3.lnrpc.SendResponse\DC2F\n\
    \\vSendToRoute\DC2\EM.lnrpc.SendToRouteRequest\SUB\DC3.lnrpc.SendResponse\"\ETX\136\STX\SOH(\SOH0\SOH\DC2A\n\
    \\SISendToRouteSync\DC2\EM.lnrpc.SendToRouteRequest\SUB\DC3.lnrpc.SendResponse\DC27\n\
    \\n\
    \AddInvoice\DC2\SO.lnrpc.Invoice\SUB\EM.lnrpc.AddInvoiceResponse\DC2E\n\
    \\fListInvoices\DC2\EM.lnrpc.ListInvoiceRequest\SUB\SUB.lnrpc.ListInvoiceResponse\DC23\n\
    \\rLookupInvoice\DC2\DC2.lnrpc.PaymentHash\SUB\SO.lnrpc.Invoice\DC2A\n\
    \\DC1SubscribeInvoices\DC2\SUB.lnrpc.InvoiceSubscription\SUB\SO.lnrpc.Invoice0\SOH\DC22\n\
    \\fDecodePayReq\DC2\DC3.lnrpc.PayReqString\SUB\r.lnrpc.PayReq\DC2G\n\
    \\fListPayments\DC2\SUB.lnrpc.ListPaymentsRequest\SUB\ESC.lnrpc.ListPaymentsResponse\DC2J\n\
    \\rDeletePayment\DC2\ESC.lnrpc.DeletePaymentRequest\SUB\FS.lnrpc.DeletePaymentResponse\DC2V\n\
    \\DC1DeleteAllPayments\DC2\US.lnrpc.DeleteAllPaymentsRequest\SUB .lnrpc.DeleteAllPaymentsResponse\DC2@\n\
    \\rDescribeGraph\DC2\SUB.lnrpc.ChannelGraphRequest\SUB\DC3.lnrpc.ChannelGraph\DC2G\n\
    \\SOGetNodeMetrics\DC2\EM.lnrpc.NodeMetricsRequest\SUB\SUB.lnrpc.NodeMetricsResponse\DC29\n\
    \\vGetChanInfo\DC2\SYN.lnrpc.ChanInfoRequest\SUB\DC2.lnrpc.ChannelEdge\DC26\n\
    \\vGetNodeInfo\DC2\SYN.lnrpc.NodeInfoRequest\SUB\SI.lnrpc.NodeInfo\DC2D\n\
    \\vQueryRoutes\DC2\EM.lnrpc.QueryRoutesRequest\SUB\SUB.lnrpc.QueryRoutesResponse\DC2?\n\
    \\SOGetNetworkInfo\DC2\EM.lnrpc.NetworkInfoRequest\SUB\DC2.lnrpc.NetworkInfo\DC25\n\
    \\n\
    \StopDaemon\DC2\DC2.lnrpc.StopRequest\SUB\DC3.lnrpc.StopResponse\DC2W\n\
    \\NAKSubscribeChannelGraph\DC2 .lnrpc.GraphTopologySubscription\SUB\SUB.lnrpc.GraphTopologyUpdate0\SOH\DC2A\n\
    \\n\
    \DebugLevel\DC2\CAN.lnrpc.DebugLevelRequest\SUB\EM.lnrpc.DebugLevelResponse\DC2>\n\
    \\tFeeReport\DC2\ETB.lnrpc.FeeReportRequest\SUB\CAN.lnrpc.FeeReportResponse\DC2N\n\
    \\DC3UpdateChannelPolicy\DC2\SUB.lnrpc.PolicyUpdateRequest\SUB\ESC.lnrpc.PolicyUpdateResponse\DC2V\n\
    \\DC1ForwardingHistory\DC2\US.lnrpc.ForwardingHistoryRequest\SUB .lnrpc.ForwardingHistoryResponse\DC2N\n\
    \\DC3ExportChannelBackup\DC2!.lnrpc.ExportChannelBackupRequest\SUB\DC4.lnrpc.ChannelBackup\DC2T\n\
    \\ETBExportAllChannelBackups\DC2\RS.lnrpc.ChanBackupExportRequest\SUB\EM.lnrpc.ChanBackupSnapshot\DC2N\n\
    \\DLEVerifyChanBackup\DC2\EM.lnrpc.ChanBackupSnapshot\SUB\US.lnrpc.VerifyChanBackupResponse\DC2V\n\
    \\NAKRestoreChannelBackups\DC2\US.lnrpc.RestoreChanBackupRequest\SUB\FS.lnrpc.RestoreBackupResponse\DC2X\n\
    \\ETBSubscribeChannelBackups\DC2 .lnrpc.ChannelBackupSubscription\SUB\EM.lnrpc.ChanBackupSnapshot0\SOH\DC2G\n\
    \\fBakeMacaroon\DC2\SUB.lnrpc.BakeMacaroonRequest\SUB\ESC.lnrpc.BakeMacaroonResponse\DC2P\n\
    \\SIListMacaroonIDs\DC2\GS.lnrpc.ListMacaroonIDsRequest\SUB\RS.lnrpc.ListMacaroonIDsResponse\DC2S\n\
    \\DLEDeleteMacaroonID\DC2\RS.lnrpc.DeleteMacaroonIDRequest\SUB\US.lnrpc.DeleteMacaroonIDResponse\DC2P\n\
    \\SIListPermissions\DC2\GS.lnrpc.ListPermissionsRequest\SUB\RS.lnrpc.ListPermissionsResponse\DC2S\n\
    \\CANCheckMacaroonPermissions\DC2\SUB.lnrpc.CheckMacPermRequest\SUB\ESC.lnrpc.CheckMacPermResponse\DC2V\n\
    \\NAKRegisterRPCMiddleware\DC2\FS.lnrpc.RPCMiddlewareResponse\SUB\ESC.lnrpc.RPCMiddlewareRequest(\SOH0\SOH\DC2V\n\
    \\DC1SendCustomMessage\DC2\US.lnrpc.SendCustomMessageRequest\SUB .lnrpc.SendCustomMessageResponse\DC2X\n\
    \\ETBSubscribeCustomMessages\DC2%.lnrpc.SubscribeCustomMessagesRequest\SUB\DC4.lnrpc.CustomMessage0\SOHB'Z%github.com/lightningnetwork/lnd/lnrpcJ\217\201\ETX\n\
    \\a\DC2\ENQ\NUL\NUL\247\f\SOH\n\
    \\b\n\
    \\SOH\f\DC2\ETX\NUL\NUL\DC2\n\
    \\t\n\
    \\STX\ETX\NUL\DC2\ETX\STX\NUL\EM\n\
    \\t\n\
    \\STX\ETX\SOH\DC2\ETX\ETX\NUL\EM\n\
    \\b\n\
    \\SOH\STX\DC2\ETX\ENQ\NUL\SO\n\
    \\b\n\
    \\SOH\b\DC2\ETX\a\NUL<\n\
    \\t\n\
    \\STX\b\v\DC2\ETX\a\NUL<\n\
    \\228\ENQ\n\
    \\STX\ACK\NUL\DC2\ENQ\FS\NUL\191\EOT\SOH\SUB1 Lightning is the main RPC server of the daemon.\n\
    \2\163\ENQ\n\
    \ Comments in this file will be directly parsed into the API\n\
    \ Documentation as descriptions of the associated method, message, or field.\n\
    \ These descriptions should go right above the definition of the object, and\n\
    \ can be in either block or // comment format.\n\
    \\n\
    \ An RPC method can be matched to an lncli command by placing a line in the\n\
    \ beginning of the description in exactly the following format:\n\
    \ lncli: `methodname`\n\
    \\n\
    \ Failure to specify the exact name of the command will cause documentation\n\
    \ generation to fail.\n\
    \\n\
    \ More information on how exactly the gRPC documentation is generated from\n\
    \ this proto file can be found here:\n\
    \ https://github.com/lightninglabs/lightning-api\n\
    \\n\
    \\n\
    \\n\
    \\ETX\ACK\NUL\SOH\DC2\ETX\FS\b\DC1\n\
    \\205\SOH\n\
    \\EOT\ACK\NUL\STX\NUL\DC2\ETX\"\EOTM\SUB\191\SOH lncli: `walletbalance`\n\
    \WalletBalance returns total unspent outputs(confirmed and unconfirmed), all\n\
    \confirmed unspent outputs and all unconfirmed unspent outputs under control\n\
    \of the wallet.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\NUL\SOH\DC2\ETX\"\b\NAK\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\NUL\STX\DC2\ETX\"\ETB+\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\NUL\ETX\DC2\ETX\"6K\n\
    \\203\SOH\n\
    \\EOT\ACK\NUL\STX\SOH\DC2\ETX)\EOTP\SUB\189\SOH lncli: `channelbalance`\n\
    \ChannelBalance returns a report on the total funds across all open channels,\n\
    \categorized in local/remote, pending local/remote and unsettled local/remote\n\
    \balances.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\SOH\SOH\DC2\ETX)\b\SYN\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\SOH\STX\DC2\ETX)\CAN-\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\SOH\ETX\DC2\ETX)8N\n\
    \\130\SOH\n\
    \\EOT\ACK\NUL\STX\STX\DC2\ETX/\EOTN\SUBu lncli: `listchaintxns`\n\
    \GetTransactions returns a list describing all the known transactions\n\
    \relevant to the wallet.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\STX\SOH\DC2\ETX/\b\ETB\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\STX\STX\DC2\ETX/\EM/\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\STX\ETX\DC2\ETX/:L\n\
    \\159\ETX\n\
    \\EOT\ACK\NUL\STX\ETX\DC2\ETX:\EOTG\SUB\145\ETX lncli: `estimatefee`\n\
    \EstimateFee asks the chain backend to estimate the fee rate and total fees\n\
    \for a transaction that pays to multiple specified outputs.\n\
    \\n\
    \When using REST, the `AddrToAmount` map type can be set by appending\n\
    \`&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this\n\
    \map type doesn't appear in the REST API documentation because of a bug in\n\
    \the grpc-gateway library.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ETX\SOH\DC2\ETX:\b\DC3\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ETX\STX\DC2\ETX:\NAK'\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ETX\ETX\DC2\ETX:2E\n\
    \\211\STX\n\
    \\EOT\ACK\NUL\STX\EOT\DC2\ETXC\EOTA\SUB\197\STX lncli: `sendcoins`\n\
    \SendCoins executes a request to send coins to a particular address. Unlike\n\
    \SendMany, this RPC call only allows creating a single output at a time. If\n\
    \neither target_conf, or sat_per_vbyte are set, then the internal wallet will\n\
    \consult its fee model to determine a fee for the default confirmation\n\
    \target.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\EOT\SOH\DC2\ETXC\b\DC1\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\EOT\STX\DC2\ETXC\DC3#\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\EOT\ETX\DC2\ETXC.?\n\
    \\222\SOH\n\
    \\EOT\ACK\NUL\STX\ENQ\DC2\ETXK\EOTG\SUB\208\SOH lncli: `listunspent`\n\
    \Deprecated, use walletrpc.ListUnspent instead.\n\
    \\n\
    \ListUnspent returns a list of all utxos spendable by the wallet with a\n\
    \number of confirmations between the specified minimum and maximum.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ENQ\SOH\DC2\ETXK\b\DC3\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ENQ\STX\DC2\ETXK\NAK'\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ENQ\ETX\DC2\ETXK2E\n\
    \\182\SOH\n\
    \\EOT\ACK\NUL\STX\ACK\DC2\EOTR\EOTS%\SUB\167\SOH\n\
    \SubscribeTransactions creates a uni-directional stream from the server to\n\
    \the client in which any newly discovered transactions relevant to the\n\
    \wallet are sent over.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ACK\SOH\DC2\ETXR\b\GS\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ACK\STX\DC2\ETXR\US5\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ACK\ACK\DC2\ETXS\DC1\ETB\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\ACK\ETX\DC2\ETXS\CAN#\n\
    \\161\STX\n\
    \\EOT\ACK\NUL\STX\a\DC2\ETX[\EOT>\SUB\147\STX lncli: `sendmany`\n\
    \SendMany handles a request for a transaction that creates multiple specified\n\
    \outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then\n\
    \the internal wallet will consult its fee model to determine a fee for the\n\
    \default confirmation target.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\a\SOH\DC2\ETX[\b\DLE\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\a\STX\DC2\ETX[\DC2!\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\a\ETX\DC2\ETX[,<\n\
    \f\n\
    \\EOT\ACK\NUL\STX\b\DC2\ETX`\EOTD\SUBY lncli: `newaddress`\n\
    \NewAddress creates a new address under control of the local wallet.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\b\SOH\DC2\ETX`\b\DC2\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\b\STX\DC2\ETX`\DC4%\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\b\ETX\DC2\ETX`0B\n\
    \\249\SOH\n\
    \\EOT\ACK\NUL\STX\t\DC2\ETXg\EOTG\SUB\235\SOH lncli: `signmessage`\n\
    \SignMessage signs a message with this node's private key. The returned\n\
    \signature string is `zbase32` encoded and pubkey recoverable, meaning that\n\
    \only the message digest and signature are needed for verification.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\t\SOH\DC2\ETXg\b\DC3\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\t\STX\DC2\ETXg\NAK'\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\t\ETX\DC2\ETXg2E\n\
    \\189\STX\n\
    \\EOT\ACK\NUL\STX\n\
    \\DC2\ETXo\EOTM\SUB\175\STX lncli: `verifymessage`\n\
    \VerifyMessage verifies a signature over a msg. The signature must be\n\
    \zbase32 encoded and signed by an active node in the resident node's\n\
    \channel database. In addition to returning the validity of the signature,\n\
    \VerifyMessage also returns the recovered pubkey from the signature.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\n\
    \\SOH\DC2\ETXo\b\NAK\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\n\
    \\STX\DC2\ETXo\ETB+\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\n\
    \\ETX\DC2\ETXo6K\n\
    \\233\SOH\n\
    \\EOT\ACK\NUL\STX\v\DC2\ETXv\EOTG\SUB\219\SOH lncli: `connect`\n\
    \ConnectPeer attempts to establish a connection to a remote peer. This is at\n\
    \the networking level, and is used for communication between nodes. This is\n\
    \distinct from establishing a channel with a peer.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\v\SOH\DC2\ETXv\b\DC3\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\v\STX\DC2\ETXv\NAK'\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\v\ETX\DC2\ETXv2E\n\
    \\251\SOH\n\
    \\EOT\ACK\NUL\STX\f\DC2\ETX}\EOTP\SUB\237\SOH lncli: `disconnect`\n\
    \DisconnectPeer attempts to disconnect one peer from another identified by a\n\
    \given pubKey. In the case that we currently have a pending or active channel\n\
    \with the target peer, then this action will be not be allowed.\n\
    \\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\f\SOH\DC2\ETX}\b\SYN\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\f\STX\DC2\ETX}\CAN-\n\
    \\f\n\
    \\ENQ\ACK\NUL\STX\f\ETX\DC2\ETX}8N\n\
    \e\n\
    \\EOT\ACK\NUL\STX\r\DC2\EOT\130\SOH\EOTA\SUBW lncli: `listpeers`\n\
    \ListPeers returns a verbose listing of all currently active peers.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\r\SOH\DC2\EOT\130\SOH\b\DC1\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\r\STX\DC2\EOT\130\SOH\DC3#\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\r\ETX\DC2\EOT\130\SOH.?\n\
    \\212\SOH\n\
    \\EOT\ACK\NUL\STX\SO\DC2\EOT\137\SOH\EOTO\SUB\197\SOH\n\
    \SubscribePeerEvents creates a uni-directional stream from the server to\n\
    \the client in which any events relevant to the state of peers are sent\n\
    \over. Events include peers going online and offline.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SO\SOH\DC2\EOT\137\SOH\b\ESC\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SO\STX\DC2\EOT\137\SOH\GS2\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SO\ACK\DC2\EOT\137\SOH=C\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SO\ETX\DC2\EOT\137\SOHDM\n\
    \\233\SOH\n\
    \\EOT\ACK\NUL\STX\SI\DC2\EOT\144\SOH\EOT;\SUB\218\SOH lncli: `getinfo`\n\
    \GetInfo returns general information concerning the lightning node including\n\
    \it's identity pubkey, alias, the chains it is connected to, and information\n\
    \concerning the number of open+pending channels.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SI\SOH\DC2\EOT\144\SOH\b\SI\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SI\STX\DC2\EOT\144\SOH\DC1\US\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SI\ETX\DC2\EOT\144\SOH*9\n\
    \\216\SOH\n\
    \\EOT\ACK\NUL\STX\DLE\DC2\ACK\151\SOH\EOT\152\SOH*\SUB\199\SOH* lncli: `getrecoveryinfo`\n\
    \GetRecoveryInfo returns information concerning the recovery mode including\n\
    \whether it's in a recovery mode, whether the recovery is finished, and the\n\
    \progress made so far.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DLE\SOH\DC2\EOT\151\SOH\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DLE\STX\DC2\EOT\151\SOH\EM/\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DLE\ETX\DC2\EOT\152\SOH\DC1(\n\
    \\255\STX\n\
    \\EOT\ACK\NUL\STX\DC1\DC2\ACK\161\SOH\EOT\162\SOH*\SUB\191\STX lncli: `pendingchannels`\n\
    \PendingChannels returns a list of all the channels that are currently\n\
    \considered \"pending\". A channel is pending if it has finished the funding\n\
    \workflow and is waiting for confirmations for the funding txn, or is in the\n\
    \process of closure, either initiated cooperatively or non-cooperatively.\n\
    \2- TODO(roasbeef): merge with below with bool?\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC1\SOH\DC2\EOT\161\SOH\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC1\STX\DC2\EOT\161\SOH\EM/\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC1\ETX\DC2\EOT\162\SOH\DC1(\n\
    \\133\SOH\n\
    \\EOT\ACK\NUL\STX\DC2\DC2\EOT\168\SOH\EOTJ\SUBw lncli: `listchannels`\n\
    \ListChannels returns a description of all the open channels that this node\n\
    \is a participant in.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC2\SOH\DC2\EOT\168\SOH\b\DC4\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC2\STX\DC2\EOT\168\SOH\SYN)\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC2\ETX\DC2\EOT\168\SOH4H\n\
    \\254\SOH\n\
    \\EOT\ACK\NUL\STX\DC3\DC2\ACK\176\SOH\EOT\177\SOH,\SUB\237\SOH\n\
    \SubscribeChannelEvents creates a uni-directional stream from the server to\n\
    \the client in which any updates relevant to the state of the channels are\n\
    \sent over. Events include new active channels, inactive channels, and closed\n\
    \channels.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC3\SOH\DC2\EOT\176\SOH\b\RS\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC3\STX\DC2\EOT\176\SOH 8\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC3\ACK\DC2\EOT\177\SOH\DC1\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC3\ETX\DC2\EOT\177\SOH\CAN*\n\
    \\140\SOH\n\
    \\EOT\ACK\NUL\STX\DC4\DC2\EOT\183\SOH\EOTP\SUB~ lncli: `closedchannels`\n\
    \ClosedChannels returns a description of all the closed channels that\n\
    \this node was a participant in.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC4\SOH\DC2\EOT\183\SOH\b\SYN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC4\STX\DC2\EOT\183\SOH\CAN-\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\DC4\ETX\DC2\EOT\183\SOH8N\n\
    \\249\SOH\n\
    \\EOT\ACK\NUL\STX\NAK\DC2\EOT\191\SOH\EOTD\SUB\234\SOH\n\
    \OpenChannelSync is a synchronous version of the OpenChannel RPC call. This\n\
    \call is meant to be consumed by clients to the REST proxy. As with all\n\
    \other sync calls, all byte slices are intended to be populated as hex\n\
    \encoded strings.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\NAK\SOH\DC2\EOT\191\SOH\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\NAK\STX\DC2\EOT\191\SOH\EM+\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\NAK\ETX\DC2\EOT\191\SOH6B\n\
    \\219\EOT\n\
    \\EOT\ACK\NUL\STX\SYN\DC2\EOT\203\SOH\EOTK\SUB\204\EOT lncli: `openchannel`\n\
    \OpenChannel attempts to open a singly funded channel specified in the\n\
    \request to a remote peer. Users are able to specify a target number of\n\
    \blocks that the funding transaction should be confirmed in, or a manual fee\n\
    \rate to us for the funding transaction. If neither are specified, then a\n\
    \lax block confirmation target is used. Each OpenStatusUpdate will return\n\
    \the pending channel ID of the in-progress channel. Depending on the\n\
    \arguments specified in the OpenChannelRequest, this pending channel ID can\n\
    \then be used to manually progress the channel funding flow.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SYN\SOH\DC2\EOT\203\SOH\b\DC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SYN\STX\DC2\EOT\203\SOH\NAK'\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SYN\ACK\DC2\EOT\203\SOH28\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SYN\ETX\DC2\EOT\203\SOH9I\n\
    \\240\STX\n\
    \\EOT\ACK\NUL\STX\ETB\DC2\ACK\212\SOH\EOT\213\SOH+\SUB\223\STX lncli: `batchopenchannel`\n\
    \BatchOpenChannel attempts to open multiple single-funded channels in a\n\
    \single transaction in an atomic way. This means either all channel open\n\
    \requests succeed at once or all attempts are aborted if any of them fail.\n\
    \This is the safer variant of using PSBTs to manually fund a batch of\n\
    \channels through the OpenChannel RPC.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\ETB\SOH\DC2\EOT\212\SOH\b\CAN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\ETB\STX\DC2\EOT\212\SOH\SUB1\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\ETB\ETX\DC2\EOT\213\SOH\DC1)\n\
    \\184\EOT\n\
    \\EOT\ACK\NUL\STX\CAN\DC2\EOT\225\SOH\EOTO\SUB\169\EOT\n\
    \FundingStateStep is an advanced funding related call that allows the caller\n\
    \to either execute some preparatory steps for a funding workflow, or\n\
    \manually progress a funding workflow. The primary way a funding flow is\n\
    \identified is via its pending channel ID. As an example, this method can be\n\
    \used to specify that we're expecting a funding flow for a particular\n\
    \pending channel ID, for which we need to use specific parameters.\n\
    \Alternatively, this can be used to interactively drive PSBT signing for\n\
    \funding for partially complete funding transactions.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\CAN\SOH\DC2\EOT\225\SOH\b\CAN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\CAN\STX\DC2\EOT\225\SOH\SUB.\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\CAN\ETX\DC2\EOT\225\SOH9M\n\
    \\221\STX\n\
    \\EOT\ACK\NUL\STX\EM\DC2\ACK\234\SOH\EOT\235\SOH.\SUB\204\STX\n\
    \ChannelAcceptor dispatches a bi-directional streaming RPC in which\n\
    \OpenChannel requests are sent to the client and the client responds with\n\
    \a boolean that tells LND whether or not to accept the channel. This allows\n\
    \node operators to specify their own criteria for accepting inbound channels\n\
    \through a single persistent connection.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\EM\SOH\DC2\EOT\234\SOH\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\EM\ENQ\DC2\EOT\234\SOH\EM\US\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\EM\STX\DC2\EOT\234\SOH 5\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\EM\ACK\DC2\EOT\235\SOH\DC1\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\EM\ETX\DC2\EOT\235\SOH\CAN,\n\
    \\155\EOT\n\
    \\EOT\ACK\NUL\STX\SUB\DC2\EOT\246\SOH\EOTN\SUB\140\EOT lncli: `closechannel`\n\
    \CloseChannel attempts to close an active channel identified by its channel\n\
    \outpoint (ChannelPoint). The actions of this method can additionally be\n\
    \augmented to attempt a force close after a timeout period in the case of an\n\
    \inactive peer. If a non-force close (cooperative closure) is requested,\n\
    \then the user can specify either a target number of blocks until the\n\
    \closure transaction is confirmed, or a manual fee rate. If neither are\n\
    \specified, then a default lax, block confirmation target is used.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SUB\SOH\DC2\EOT\246\SOH\b\DC4\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SUB\STX\DC2\EOT\246\SOH\SYN)\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SUB\ACK\DC2\EOT\246\SOH4:\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\SUB\ETX\DC2\EOT\246\SOH;L\n\
    \\164\ETX\n\
    \\EOT\ACK\NUL\STX\ESC\DC2\EOT\128\STX\EOTP\SUB\149\ETX lncli: `abandonchannel`\n\
    \AbandonChannel removes all channel state from the database except for a\n\
    \close summary. This method can be used to get rid of permanently unusable\n\
    \channels due to bugs fixed in newer versions of lnd. This method can also be\n\
    \used to remove externally funded channels where the funding transaction was\n\
    \never broadcast. Only available for non-externally funded channels in dev\n\
    \build.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\ESC\SOH\DC2\EOT\128\STX\b\SYN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\ESC\STX\DC2\EOT\128\STX\CAN-\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\ESC\ETX\DC2\EOT\128\STX8N\n\
    \\234\STX\n\
    \\EOT\ACK\NUL\STX\FS\DC2\ACK\137\STX\EOT\139\STX\ENQ\SUB\217\STX lncli: `sendpayment`\n\
    \Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a\n\
    \bi-directional streaming RPC for sending payments through the Lightning\n\
    \Network. A single RPC invocation creates a persistent bi-directional\n\
    \stream allowing clients to rapidly send payments through the Lightning\n\
    \Network with a single persistent connection.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\FS\SOH\DC2\EOT\137\STX\b\DC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\FS\ENQ\DC2\EOT\137\STX\NAK\ESC\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\FS\STX\DC2\EOT\137\STX\FS'\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\FS\ACK\DC2\EOT\137\STX28\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\FS\ETX\DC2\EOT\137\STX9E\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\FS\EOT\DC2\EOT\138\STX\b!\n\
    \\SO\n\
    \\ACK\ACK\NUL\STX\FS\EOT!\DC2\EOT\138\STX\b!\n\
    \\147\STX\n\
    \\EOT\ACK\NUL\STX\GS\DC2\EOT\147\STX\EOT=\SUB\132\STX\n\
    \SendPaymentSync is the synchronous non-streaming version of SendPayment.\n\
    \This RPC is intended to be consumed by clients of the REST proxy.\n\
    \Additionally, this RPC expects the destination's public key and the payment\n\
    \hash (if any) to be encoded as hex strings.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\GS\SOH\DC2\EOT\147\STX\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\GS\STX\DC2\EOT\147\STX\EM$\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\GS\ETX\DC2\EOT\147\STX/;\n\
    \\208\STX\n\
    \\EOT\ACK\NUL\STX\RS\DC2\ACK\156\STX\EOT\158\STX\ENQ\SUB\191\STX lncli: `sendtoroute`\n\
    \Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional\n\
    \streaming RPC for sending payment through the Lightning Network. This\n\
    \method differs from SendPayment in that it allows users to specify a full\n\
    \route manually. This can be used for things like rebalancing, and atomic\n\
    \swaps.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\RS\SOH\DC2\EOT\156\STX\b\DC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\RS\ENQ\DC2\EOT\156\STX\NAK\ESC\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\RS\STX\DC2\EOT\156\STX\FS.\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\RS\ACK\DC2\EOT\156\STX9?\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\RS\ETX\DC2\EOT\156\STX@L\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\RS\EOT\DC2\EOT\157\STX\b!\n\
    \\SO\n\
    \\ACK\ACK\NUL\STX\RS\EOT!\DC2\EOT\157\STX\b!\n\
    \\130\SOH\n\
    \\EOT\ACK\NUL\STX\US\DC2\EOT\164\STX\EOTD\SUBt\n\
    \SendToRouteSync is a synchronous version of SendToRoute. It Will block\n\
    \until the payment either fails or succeeds.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\US\SOH\DC2\EOT\164\STX\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\US\STX\DC2\EOT\164\STX\EM+\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\US\ETX\DC2\EOT\164\STX6B\n\
    \\202\SOH\n\
    \\EOT\ACK\NUL\STX \DC2\EOT\171\STX\EOT:\SUB\187\SOH lncli: `addinvoice`\n\
    \AddInvoice attempts to add a new invoice to the invoice database. Any\n\
    \duplicated invoices are rejected, therefore all invoices *must* have a\n\
    \unique payment preimage.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX \SOH\DC2\EOT\171\STX\b\DC2\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX \STX\DC2\EOT\171\STX\DC4\ESC\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX \ETX\DC2\EOT\171\STX&8\n\
    \\172\EOT\n\
    \\EOT\ACK\NUL\STX!\DC2\EOT\182\STX\EOTH\SUB\157\EOT lncli: `listinvoices`\n\
    \ListInvoices returns a list of all the invoices currently stored within the\n\
    \database. Any active debug invoices are ignored. It has full support for\n\
    \paginated responses, allowing users to query for specific invoices through\n\
    \their add_index. This can be done by using either the first_index_offset or\n\
    \last_index_offset fields included in the response as the index_offset of the\n\
    \next request. By default, the first 100 invoices created will be returned.\n\
    \Backwards pagination is also supported through the Reversed flag.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX!\SOH\DC2\EOT\182\STX\b\DC4\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX!\STX\DC2\EOT\182\STX\SYN(\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX!\ETX\DC2\EOT\182\STX3F\n\
    \\197\SOH\n\
    \\EOT\ACK\NUL\STX\"\DC2\EOT\189\STX\EOT6\SUB\182\SOH lncli: `lookupinvoice`\n\
    \LookupInvoice attempts to look up an invoice according to its payment hash.\n\
    \The passed payment hash *must* be exactly 32 bytes, if not, an error is\n\
    \returned.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\"\SOH\DC2\EOT\189\STX\b\NAK\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\"\STX\DC2\EOT\189\STX\ETB\"\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX\"\ETX\DC2\EOT\189\STX-4\n\
    \\247\EOT\n\
    \\EOT\ACK\NUL\STX#\DC2\EOT\202\STX\EOTI\SUB\232\EOT\n\
    \SubscribeInvoices returns a uni-directional stream (server -> client) for\n\
    \notifying the client of newly added/settled invoices. The caller can\n\
    \optionally specify the add_index and/or the settle_index. If the add_index\n\
    \is specified, then we'll first start by sending add invoice events for all\n\
    \invoices with an add_index greater than the specified value. If the\n\
    \settle_index is specified, the next, we'll send out all settle events for\n\
    \invoices with a settle_index greater than the specified value. One or both\n\
    \of these fields can be set. If no fields are set, then we'll only send out\n\
    \the latest add/settle events.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX#\SOH\DC2\EOT\202\STX\b\EM\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX#\STX\DC2\EOT\202\STX\ESC.\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX#\ACK\DC2\EOT\202\STX9?\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX#\ETX\DC2\EOT\202\STX@G\n\
    \\201\SOH\n\
    \\EOT\ACK\NUL\STX$\DC2\EOT\209\STX\EOT5\SUB\186\SOH lncli: `decodepayreq`\n\
    \DecodePayReq takes an encoded payment request string and attempts to decode\n\
    \it, returning a full description of the conditions encoded within the\n\
    \payment request.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX$\SOH\DC2\EOT\209\STX\b\DC4\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX$\STX\DC2\EOT\209\STX\SYN\"\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX$\ETX\DC2\EOT\209\STX-3\n\
    \[\n\
    \\EOT\ACK\NUL\STX%\DC2\EOT\214\STX\EOTJ\SUBM lncli: `listpayments`\n\
    \ListPayments returns a list of all outgoing payments.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX%\SOH\DC2\EOT\214\STX\b\DC4\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX%\STX\DC2\EOT\214\STX\SYN)\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX%\ETX\DC2\EOT\214\STX4H\n\
    \\157\SOH\n\
    \\EOT\ACK\NUL\STX&\DC2\EOT\220\STX\EOTM\SUB\142\SOH\n\
    \DeletePayment deletes an outgoing payment from DB. Note that it will not\n\
    \attempt to delete an In-Flight payment, since that would be unsafe.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX&\SOH\DC2\EOT\220\STX\b\NAK\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX&\STX\DC2\EOT\220\STX\ETB+\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX&\ETX\DC2\EOT\220\STX6K\n\
    \\163\SOH\n\
    \\EOT\ACK\NUL\STX'\DC2\ACK\226\STX\EOT\227\STX,\SUB\146\SOH\n\
    \DeleteAllPayments deletes all outgoing payments from DB. Note that it will\n\
    \not attempt to delete In-Flight payments, since that would be unsafe.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX'\SOH\DC2\EOT\226\STX\b\EM\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX'\STX\DC2\EOT\226\STX\ESC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX'\ETX\DC2\EOT\227\STX\DC1*\n\
    \\175\ETX\n\
    \\EOT\ACK\NUL\STX(\DC2\EOT\237\STX\EOTC\SUB\160\ETX lncli: `describegraph`\n\
    \DescribeGraph returns a description of the latest graph state from the\n\
    \point of view of the node. The graph information is partitioned into two\n\
    \components: all the nodes/vertexes, and all the edges that connect the\n\
    \vertexes themselves. As this is a directed graph, the edges also contain\n\
    \the node directional specific routing policy which includes: the time lock\n\
    \delta, fee information, etc.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX(\SOH\DC2\EOT\237\STX\b\NAK\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX(\STX\DC2\EOT\237\STX\ETB*\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX(\ETX\DC2\EOT\237\STX5A\n\
    \\186\SOH\n\
    \\EOT\ACK\NUL\STX)\DC2\EOT\243\STX\EOTJ\SUB\171\SOH lncli: `getnodemetrics`\n\
    \GetNodeMetrics returns node metrics calculated from the graph. Currently\n\
    \the only supported metric is betweenness centrality of individual nodes.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX)\SOH\DC2\EOT\243\STX\b\SYN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX)\STX\DC2\EOT\243\STX\CAN*\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX)\ETX\DC2\EOT\243\STX5H\n\
    \\139\STX\n\
    \\EOT\ACK\NUL\STX*\DC2\EOT\251\STX\EOT<\SUB\252\SOH lncli: `getchaninfo`\n\
    \GetChanInfo returns the latest authenticated network announcement for the\n\
    \given channel identified by its channel ID: an 8-byte integer which\n\
    \uniquely identifies the location of transaction's funding output within the\n\
    \blockchain.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX*\SOH\DC2\EOT\251\STX\b\DC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX*\STX\DC2\EOT\251\STX\NAK$\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX*\ETX\DC2\EOT\251\STX/:\n\
    \\183\SOH\n\
    \\EOT\ACK\NUL\STX+\DC2\EOT\129\ETX\EOT9\SUB\168\SOH lncli: `getnodeinfo`\n\
    \GetNodeInfo returns the latest advertised, aggregated, and authenticated\n\
    \channel information for the specified node identified by its public key.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX+\SOH\DC2\EOT\129\ETX\b\DC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX+\STX\DC2\EOT\129\ETX\NAK$\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX+\ETX\DC2\EOT\129\ETX/7\n\
    \\160\ENQ\n\
    \\EOT\ACK\NUL\STX,\DC2\EOT\143\ETX\EOTG\SUB\145\ENQ lncli: `queryroutes`\n\
    \QueryRoutes attempts to query the daemon's Channel Router for a possible\n\
    \route to a target destination capable of carrying a specific amount of\n\
    \satoshis. The returned route contains the full details required to craft and\n\
    \send an HTLC, also including the necessary information that should be\n\
    \present within the Sphinx packet encapsulated within the HTLC.\n\
    \\n\
    \When using REST, the `dest_custom_records` map type can be set by appending\n\
    \`&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`\n\
    \to the URL. Unfortunately this map type doesn't appear in the REST API\n\
    \documentation because of a bug in the grpc-gateway library.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX,\SOH\DC2\EOT\143\ETX\b\DC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX,\STX\DC2\EOT\143\ETX\NAK'\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX,\ETX\DC2\EOT\143\ETX2E\n\
    \\146\SOH\n\
    \\EOT\ACK\NUL\STX-\DC2\EOT\149\ETX\EOTB\SUB\131\SOH lncli: `getnetworkinfo`\n\
    \GetNetworkInfo returns some basic stats about the known channel graph from\n\
    \the point of view of the node.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX-\SOH\DC2\EOT\149\ETX\b\SYN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX-\STX\DC2\EOT\149\ETX\CAN*\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX-\ETX\DC2\EOT\149\ETX5@\n\
    \\141\SOH\n\
    \\EOT\ACK\NUL\STX.\DC2\EOT\155\ETX\EOT8\SUB\DEL lncli: `stop`\n\
    \StopDaemon will send a shutdown request to the interrupt handler, triggering\n\
    \a graceful shutdown of the daemon.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX.\SOH\DC2\EOT\155\ETX\b\DC2\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX.\STX\DC2\EOT\155\ETX\DC4\US\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX.\ETX\DC2\EOT\155\ETX*6\n\
    \\180\ETX\n\
    \\EOT\ACK\NUL\STX/\DC2\ACK\165\ETX\EOT\166\ETX-\SUB\163\ETX\n\
    \SubscribeChannelGraph launches a streaming RPC that allows the caller to\n\
    \receive notifications upon any changes to the channel graph topology from\n\
    \the point of view of the responding node. Events notified include: new\n\
    \nodes coming online, nodes updating their authenticated attributes, new\n\
    \channels being advertised, updates in the routing policy for a directional\n\
    \channel edge, and when channels are closed on-chain.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX/\SOH\DC2\EOT\165\ETX\b\GS\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX/\STX\DC2\EOT\165\ETX\US8\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX/\ACK\DC2\EOT\166\ETX\DC1\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX/\ETX\DC2\EOT\166\ETX\CAN+\n\
    \\139\STX\n\
    \\EOT\ACK\NUL\STX0\DC2\EOT\174\ETX\EOTD\SUB\252\SOH lncli: `debuglevel`\n\
    \DebugLevel allows a caller to programmatically set the logging verbosity of\n\
    \lnd. The logging can be targeted according to a coarse daemon-wide logging\n\
    \level, or in a granular fashion to specify the logging for a target\n\
    \sub-system.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX0\SOH\DC2\EOT\174\ETX\b\DC2\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX0\STX\DC2\EOT\174\ETX\DC4%\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX0\ETX\DC2\EOT\174\ETX0B\n\
    \\165\SOH\n\
    \\EOT\ACK\NUL\STX1\DC2\EOT\180\ETX\EOTA\SUB\150\SOH lncli: `feereport`\n\
    \FeeReport allows the caller to obtain a report detailing the current fee\n\
    \schedule enforced by the node globally for each channel.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX1\SOH\DC2\EOT\180\ETX\b\DC1\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX1\STX\DC2\EOT\180\ETX\DC3#\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX1\ETX\DC2\EOT\180\ETX.?\n\
    \\182\SOH\n\
    \\EOT\ACK\NUL\STX2\DC2\ACK\186\ETX\EOT\187\ETX'\SUB\165\SOH lncli: `updatechanpolicy`\n\
    \UpdateChannelPolicy allows the caller to update the fee schedule and\n\
    \channel policies for all channels globally, or a particular channel.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX2\SOH\DC2\EOT\186\ETX\b\ESC\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX2\STX\DC2\EOT\186\ETX\GS0\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX2\ETX\DC2\EOT\187\ETX\DC1%\n\
    \\133\ACK\n\
    \\EOT\ACK\NUL\STX3\DC2\ACK\202\ETX\EOT\203\ETX,\SUB\244\ENQ lncli: `fwdinghistory`\n\
    \ForwardingHistory allows the caller to query the htlcswitch for a record of\n\
    \all HTLCs forwarded within the target time range, and integer offset\n\
    \within that time range, for a maximum number of events. If no maximum number\n\
    \of events is specified, up to 100 events will be returned. If no time-range\n\
    \is specified, then events will be returned in the order that they occured.\n\
    \\n\
    \A list of forwarding events are returned. The size of each forwarding event\n\
    \is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.\n\
    \As a result each message can only contain 50k entries. Each response has\n\
    \the index offset of the last entry. The index offset can be provided to the\n\
    \request to allow the caller to skip a series of records.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX3\SOH\DC2\EOT\202\ETX\b\EM\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX3\STX\DC2\EOT\202\ETX\ESC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX3\ETX\DC2\EOT\203\ETX\DC1*\n\
    \\178\ETX\n\
    \\EOT\ACK\NUL\STX4\DC2\ACK\213\ETX\EOT\214\ETX \SUB\161\ETX lncli: `exportchanbackup`\n\
    \ExportChannelBackup attempts to return an encrypted static channel backup\n\
    \for the target channel identified by it channel point. The backup is\n\
    \encrypted with a key generated from the aezeed seed of the user. The\n\
    \returned backup can either be restored using the RestoreChannelBackup\n\
    \method once lnd is running, or via the InitWallet and UnlockWallet methods\n\
    \from the WalletUnlocker service.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX4\SOH\DC2\EOT\213\ETX\b\ESC\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX4\STX\DC2\EOT\213\ETX\GS7\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX4\ETX\DC2\EOT\214\ETX\DC1\RS\n\
    \\202\STX\n\
    \\EOT\ACK\NUL\STX5\DC2\ACK\223\ETX\EOT\224\ETX%\SUB\185\STX\n\
    \ExportAllChannelBackups returns static channel backups for all existing\n\
    \channels known to lnd. A set of regular singular static channel backups for\n\
    \each channel are returned. Additionally, a multi-channel backup is returned\n\
    \as well, which contains a single encrypted blob containing the backups of\n\
    \each channel.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX5\SOH\DC2\EOT\223\ETX\b\US\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX5\STX\DC2\EOT\223\ETX!8\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX5\ETX\DC2\EOT\224\ETX\DC1#\n\
    \\212\SOH\n\
    \\EOT\ACK\NUL\STX6\DC2\ACK\231\ETX\EOT\232\ETX+\SUB\195\SOH\n\
    \VerifyChanBackup allows a caller to verify the integrity of a channel backup\n\
    \snapshot. This method will accept either a packed Single or a packed Multi.\n\
    \Specifying both will result in an error.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX6\SOH\DC2\EOT\231\ETX\b\CAN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX6\STX\DC2\EOT\231\ETX\SUB,\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX6\ETX\DC2\EOT\232\ETX\DC1)\n\
    \\207\STX\n\
    \\EOT\ACK\NUL\STX7\DC2\ACK\240\ETX\EOT\241\ETX(\SUB\190\STX lncli: `restorechanbackup`\n\
    \RestoreChannelBackups accepts a set of singular channel backups, or a\n\
    \single encrypted multi-chan backup and attempts to recover any funds\n\
    \remaining within the channel. If we are able to unpack the backup, then the\n\
    \new channel will be shown under listchannels, as well as pending channels.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX7\SOH\DC2\EOT\240\ETX\b\GS\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX7\STX\DC2\EOT\240\ETX\US7\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX7\ETX\DC2\EOT\241\ETX\DC1&\n\
    \\223\ETX\n\
    \\EOT\ACK\NUL\STX8\DC2\ACK\252\ETX\EOT\253\ETX,\SUB\206\ETX\n\
    \SubscribeChannelBackups allows a client to sub-subscribe to the most up to\n\
    \date information concerning the state of all channel backups. Each time a\n\
    \new channel is added, we return the new set of channels, along with a\n\
    \multi-chan backup containing the backup info for all channels. Each time a\n\
    \channel is closed, we send a new update, which contains new new chan back\n\
    \ups, but the updated set of encrypted multi-chan backups with the closed\n\
    \channel(s) removed.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX8\SOH\DC2\EOT\252\ETX\b\US\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX8\STX\DC2\EOT\252\ETX!:\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX8\ACK\DC2\EOT\253\ETX\DC1\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX8\ETX\DC2\EOT\253\ETX\CAN*\n\
    \\194\SOH\n\
    \\EOT\ACK\NUL\STX9\DC2\EOT\132\EOT\EOTJ\SUB\179\SOH lncli: `bakemacaroon`\n\
    \BakeMacaroon allows the creation of a new macaroon with custom read and\n\
    \write permissions. No first-party caveats are added since this can be done\n\
    \offline.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX9\SOH\DC2\EOT\132\EOT\b\DC4\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX9\STX\DC2\EOT\132\EOT\SYN)\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX9\ETX\DC2\EOT\132\EOT4H\n\
    \d\n\
    \\EOT\ACK\NUL\STX:\DC2\ACK\137\EOT\EOT\138\EOT*\SUBT lncli: `listmacaroonids`\n\
    \ListMacaroonIDs returns all root key IDs that are in use.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX:\SOH\DC2\EOT\137\EOT\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX:\STX\DC2\EOT\137\EOT\EM/\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX:\ETX\DC2\EOT\138\EOT\DC1(\n\
    \\147\SOH\n\
    \\EOT\ACK\NUL\STX;\DC2\ACK\144\EOT\EOT\145\EOT+\SUB\130\SOH lncli: `deletemacaroonid`\n\
    \DeleteMacaroonID deletes the specified macaroon ID and invalidates all\n\
    \macaroons derived from that ID.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX;\SOH\DC2\EOT\144\EOT\b\CAN\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX;\STX\DC2\EOT\144\EOT\SUB1\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX;\ETX\DC2\EOT\145\EOT\DC1)\n\
    \\140\SOH\n\
    \\EOT\ACK\NUL\STX<\DC2\ACK\151\EOT\EOT\152\EOT*\SUB| lncli: `listpermissions`\n\
    \ListPermissions lists all RPC method URIs and their required macaroon\n\
    \permissions to access them.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX<\SOH\DC2\EOT\151\EOT\b\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX<\STX\DC2\EOT\151\EOT\EM/\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX<\ETX\DC2\EOT\152\EOT\DC1(\n\
    \\188\SOH\n\
    \\EOT\ACK\NUL\STX=\DC2\ACK\159\EOT\EOT\160\EOT'\SUB\171\SOH\n\
    \CheckMacaroonPermissions checks whether a request follows the constraints\n\
    \imposed on the macaroon and that the macaroon is authorized to follow the\n\
    \provided permissions.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX=\SOH\DC2\EOT\159\EOT\b \n\
    \\r\n\
    \\ENQ\ACK\NUL\STX=\STX\DC2\EOT\159\EOT\"5\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX=\ETX\DC2\EOT\160\EOT\DC1%\n\
    \\139\a\n\
    \\EOT\ACK\NUL\STX>\DC2\ACK\176\EOT\EOT\177\EOT.\SUB\250\ACK\n\
    \RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A\n\
    \gRPC middleware is software component external to lnd that aims to add\n\
    \additional business logic to lnd by observing/intercepting/validating\n\
    \incoming gRPC client requests and (if needed) replacing/overwriting outgoing\n\
    \messages before they're sent to the client. When registering the middleware\n\
    \must identify itself and indicate what custom macaroon caveats it wants to\n\
    \be responsible for. Only requests that contain a macaroon with that specific\n\
    \custom caveat are then sent to the middleware for inspection. The other\n\
    \option is to register for the read-only mode in which all requests/responses\n\
    \are forwarded for interception to the middleware but the middleware is not\n\
    \allowed to modify any responses. As a security measure, _no_ middleware can\n\
    \modify responses for requests made with _unencumbered_ macaroons!\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX>\SOH\DC2\EOT\176\EOT\b\GS\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX>\ENQ\DC2\EOT\176\EOT\US%\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX>\STX\DC2\EOT\176\EOT&;\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX>\ACK\DC2\EOT\177\EOT\DC1\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX>\ETX\DC2\EOT\177\EOT\CAN,\n\
    \T\n\
    \\EOT\ACK\NUL\STX?\DC2\ACK\182\EOT\EOT\183\EOT,\SUBD lncli: `sendcustom`\n\
    \SendCustomMessage sends a custom peer message.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX?\SOH\DC2\EOT\182\EOT\b\EM\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX?\STX\DC2\EOT\182\EOT\ESC3\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX?\ETX\DC2\EOT\183\EOT\DC1*\n\
    \{\n\
    \\EOT\ACK\NUL\STX@\DC2\ACK\189\EOT\EOT\190\EOT'\SUBk lncli: `subscribecustom`\n\
    \SubscribeCustomMessages subscribes to a stream of incoming custom peer\n\
    \messages.\n\
    \\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX@\SOH\DC2\EOT\189\EOT\b\US\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX@\STX\DC2\EOT\189\EOT!?\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX@\ACK\DC2\EOT\190\EOT\DC1\ETB\n\
    \\r\n\
    \\ENQ\ACK\NUL\STX@\ETX\DC2\EOT\190\EOT\CAN%\n\
    \\f\n\
    \\STX\EOT\NUL\DC2\ACK\193\EOT\NUL\194\EOT\SOH\n\
    \\v\n\
    \\ETX\EOT\NUL\SOH\DC2\EOT\193\EOT\b&\n\
    \\f\n\
    \\STX\EOT\SOH\DC2\ACK\196\EOT\NUL\205\EOT\SOH\n\
    \\v\n\
    \\ETX\EOT\SOH\SOH\DC2\EOT\196\EOT\b\NAK\n\
    \6\n\
    \\EOT\EOT\SOH\STX\NUL\DC2\EOT\198\EOT\EOT\DC3\SUB( Peer from which the message originates\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\NUL\ENQ\DC2\EOT\198\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\NUL\SOH\DC2\EOT\198\EOT\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\NUL\ETX\DC2\EOT\198\EOT\DC1\DC2\n\
    \P\n\
    \\EOT\EOT\SOH\STX\SOH\DC2\EOT\201\EOT\EOT\DC4\SUBB Message type. This value will be in the custom range (>= 32768).\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\SOH\ENQ\DC2\EOT\201\EOT\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\SOH\SOH\DC2\EOT\201\EOT\v\SI\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\SOH\ETX\DC2\EOT\201\EOT\DC2\DC3\n\
    \ \n\
    \\EOT\EOT\SOH\STX\STX\DC2\EOT\204\EOT\EOT\DC3\SUB\DC2 Raw message data\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\STX\ENQ\DC2\EOT\204\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\STX\SOH\DC2\EOT\204\EOT\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT\SOH\STX\STX\ETX\DC2\EOT\204\EOT\DC1\DC2\n\
    \\f\n\
    \\STX\EOT\STX\DC2\ACK\207\EOT\NUL\216\EOT\SOH\n\
    \\v\n\
    \\ETX\EOT\STX\SOH\DC2\EOT\207\EOT\b \n\
    \+\n\
    \\EOT\EOT\STX\STX\NUL\DC2\EOT\209\EOT\EOT\DC3\SUB\GS Peer to send the message to\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\NUL\ENQ\DC2\EOT\209\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\NUL\SOH\DC2\EOT\209\EOT\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\NUL\ETX\DC2\EOT\209\EOT\DC1\DC2\n\
    \T\n\
    \\EOT\EOT\STX\STX\SOH\DC2\EOT\212\EOT\EOT\DC4\SUBF Message type. This value needs to be in the custom range (>= 32768).\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\SOH\ENQ\DC2\EOT\212\EOT\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\SOH\SOH\DC2\EOT\212\EOT\v\SI\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\SOH\ETX\DC2\EOT\212\EOT\DC2\DC3\n\
    \!\n\
    \\EOT\EOT\STX\STX\STX\DC2\EOT\215\EOT\EOT\DC3\SUB\DC3 Raw message data.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\STX\ENQ\DC2\EOT\215\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\STX\SOH\DC2\EOT\215\EOT\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT\STX\STX\STX\ETX\DC2\EOT\215\EOT\DC1\DC2\n\
    \\f\n\
    \\STX\EOT\ETX\DC2\ACK\218\EOT\NUL\219\EOT\SOH\n\
    \\v\n\
    \\ETX\EOT\ETX\SOH\DC2\EOT\218\EOT\b!\n\
    \\f\n\
    \\STX\EOT\EOT\DC2\ACK\221\EOT\NUL\239\EOT\SOH\n\
    \\v\n\
    \\ETX\EOT\EOT\SOH\DC2\EOT\221\EOT\b\f\n\
    \#\n\
    \\EOT\EOT\EOT\STX\NUL\DC2\EOT\223\EOT\EOT!\SUB\NAK The type of address\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\NUL\ACK\DC2\EOT\223\EOT\EOT\SI\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\NUL\SOH\DC2\EOT\223\EOT\DLE\FS\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\NUL\ETX\DC2\EOT\223\EOT\US \n\
    \\ESC\n\
    \\EOT\EOT\EOT\STX\SOH\DC2\EOT\226\EOT\EOT\ETB\SUB\r The address\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\SOH\ENQ\DC2\EOT\226\EOT\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\SOH\SOH\DC2\EOT\226\EOT\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\SOH\ETX\DC2\EOT\226\EOT\NAK\SYN\n\
    \9\n\
    \\EOT\EOT\EOT\STX\STX\DC2\EOT\229\EOT\EOT\EM\SUB+ The value of the unspent coin in satoshis\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\STX\ENQ\DC2\EOT\229\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\STX\SOH\DC2\EOT\229\EOT\n\
    \\DC4\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\STX\ETX\DC2\EOT\229\EOT\ETB\CAN\n\
    \#\n\
    \\EOT\EOT\EOT\STX\ETX\DC2\EOT\232\EOT\EOT\EM\SUB\NAK The pkscript in hex\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\ETX\ENQ\DC2\EOT\232\EOT\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\ETX\SOH\DC2\EOT\232\EOT\v\DC4\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\ETX\ETX\DC2\EOT\232\EOT\ETB\CAN\n\
    \-\n\
    \\EOT\EOT\EOT\STX\EOT\DC2\EOT\235\EOT\EOT\SUB\SUB\US The outpoint in format txid:n\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\EOT\ACK\DC2\EOT\235\EOT\EOT\f\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\EOT\SOH\DC2\EOT\235\EOT\r\NAK\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\EOT\ETX\DC2\EOT\235\EOT\CAN\EM\n\
    \8\n\
    \\EOT\EOT\EOT\STX\ENQ\DC2\EOT\238\EOT\EOT\FS\SUB* The number of confirmations for the Utxo\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\ENQ\ENQ\DC2\EOT\238\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\ENQ\SOH\DC2\EOT\238\EOT\n\
    \\ETB\n\
    \\r\n\
    \\ENQ\EOT\EOT\STX\ENQ\ETX\DC2\EOT\238\EOT\SUB\ESC\n\
    \\f\n\
    \\STX\EOT\ENQ\DC2\ACK\241\EOT\NUL\143\ENQ\SOH\n\
    \\v\n\
    \\ETX\EOT\ENQ\SOH\DC2\EOT\241\EOT\b\DC3\n\
    \$\n\
    \\EOT\EOT\ENQ\STX\NUL\DC2\EOT\243\EOT\EOT\ETB\SUB\SYN The transaction hash\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\NUL\ENQ\DC2\EOT\243\EOT\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\NUL\SOH\DC2\EOT\243\EOT\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\NUL\ETX\DC2\EOT\243\EOT\NAK\SYN\n\
    \?\n\
    \\EOT\EOT\ENQ\STX\SOH\DC2\EOT\246\EOT\EOT\NAK\SUB1 The transaction amount, denominated in satoshis\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\SOH\ENQ\DC2\EOT\246\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\SOH\SOH\DC2\EOT\246\EOT\n\
    \\DLE\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\SOH\ETX\DC2\EOT\246\EOT\DC3\DC4\n\
    \+\n\
    \\EOT\EOT\ENQ\STX\STX\DC2\EOT\249\EOT\EOT \SUB\GS The number of confirmations\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\STX\ENQ\DC2\EOT\249\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\STX\SOH\DC2\EOT\249\EOT\n\
    \\ESC\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\STX\ETX\DC2\EOT\249\EOT\RS\US\n\
    \F\n\
    \\EOT\EOT\ENQ\STX\ETX\DC2\EOT\252\EOT\EOT\SUB\SUB8 The hash of the block this transaction was included in\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ETX\ENQ\DC2\EOT\252\EOT\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ETX\SOH\DC2\EOT\252\EOT\v\NAK\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ETX\ETX\DC2\EOT\252\EOT\CAN\EM\n\
    \H\n\
    \\EOT\EOT\ENQ\STX\EOT\DC2\EOT\255\EOT\EOT\ESC\SUB: The height of the block this transaction was included in\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\EOT\ENQ\DC2\EOT\255\EOT\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\EOT\SOH\DC2\EOT\255\EOT\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\EOT\ETX\DC2\EOT\255\EOT\EM\SUB\n\
    \-\n\
    \\EOT\EOT\ENQ\STX\ENQ\DC2\EOT\130\ENQ\EOT\EM\SUB\US Timestamp of this transaction\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ENQ\ENQ\DC2\EOT\130\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ENQ\SOH\DC2\EOT\130\ENQ\n\
    \\DC4\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ENQ\ETX\DC2\EOT\130\ENQ\ETB\CAN\n\
    \.\n\
    \\EOT\EOT\ENQ\STX\ACK\DC2\EOT\133\ENQ\EOT\EM\SUB  Fees paid for this transaction\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ACK\ENQ\DC2\EOT\133\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ACK\SOH\DC2\EOT\133\ENQ\n\
    \\DC4\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\ACK\ETX\DC2\EOT\133\ENQ\ETB\CAN\n\
    \B\n\
    \\EOT\EOT\ENQ\STX\a\DC2\EOT\136\ENQ\EOT'\SUB4 Addresses that received funds for this transaction\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\a\EOT\DC2\EOT\136\ENQ\EOT\f\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\a\ENQ\DC2\EOT\136\ENQ\r\DC3\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\a\SOH\DC2\EOT\136\ENQ\DC4\"\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\a\ETX\DC2\EOT\136\ENQ%&\n\
    \(\n\
    \\EOT\EOT\ENQ\STX\b\DC2\EOT\139\ENQ\EOT\SUB\SUB\SUB The raw transaction hex.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\b\ENQ\DC2\EOT\139\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\b\SOH\DC2\EOT\139\ENQ\v\NAK\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\b\ETX\DC2\EOT\139\ENQ\CAN\EM\n\
    \I\n\
    \\EOT\EOT\ENQ\STX\t\DC2\EOT\142\ENQ\EOT\SYN\SUB; A label that was optionally set on transaction broadcast.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\t\ENQ\DC2\EOT\142\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\t\SOH\DC2\EOT\142\ENQ\v\DLE\n\
    \\r\n\
    \\ENQ\EOT\ENQ\STX\t\ETX\DC2\EOT\142\ENQ\DC3\NAK\n\
    \\f\n\
    \\STX\EOT\ACK\DC2\ACK\144\ENQ\NUL\162\ENQ\SOH\n\
    \\v\n\
    \\ETX\EOT\ACK\SOH\DC2\EOT\144\ENQ\b\RS\n\
    \\151\SOH\n\
    \\EOT\EOT\ACK\STX\NUL\DC2\EOT\149\ENQ\EOT\ESC\SUB\136\SOH\n\
    \The height from which to list transactions, inclusive. If this value is\n\
    \greater than end_height, transactions will be read in reverse.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\NUL\ENQ\DC2\EOT\149\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\NUL\SOH\DC2\EOT\149\ENQ\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\NUL\ETX\DC2\EOT\149\ENQ\EM\SUB\n\
    \\188\STX\n\
    \\EOT\EOT\ACK\STX\SOH\DC2\EOT\158\ENQ\EOT\EM\SUB\173\STX\n\
    \The height until which to list transactions, inclusive. To include\n\
    \unconfirmed transactions, this value should be set to -1, which will\n\
    \return transactions from start_height until the current chain tip and\n\
    \unconfirmed transactions. If no end_height is provided, the call will\n\
    \default to this option.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\SOH\ENQ\DC2\EOT\158\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\SOH\SOH\DC2\EOT\158\ENQ\n\
    \\DC4\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\SOH\ETX\DC2\EOT\158\ENQ\ETB\CAN\n\
    \W\n\
    \\EOT\EOT\ACK\STX\STX\DC2\EOT\161\ENQ\EOT\ETB\SUBI An optional filter to only include transactions relevant to an account.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\STX\ENQ\DC2\EOT\161\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\STX\SOH\DC2\EOT\161\ENQ\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\ACK\STX\STX\ETX\DC2\EOT\161\ENQ\NAK\SYN\n\
    \\f\n\
    \\STX\EOT\a\DC2\ACK\164\ENQ\NUL\167\ENQ\SOH\n\
    \\v\n\
    \\ETX\EOT\a\SOH\DC2\EOT\164\ENQ\b\SUB\n\
    \@\n\
    \\EOT\EOT\a\STX\NUL\DC2\EOT\166\ENQ\EOT*\SUB2 The list of transactions relevant to the wallet.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\a\STX\NUL\EOT\DC2\EOT\166\ENQ\EOT\f\n\
    \\r\n\
    \\ENQ\EOT\a\STX\NUL\ACK\DC2\EOT\166\ENQ\r\CAN\n\
    \\r\n\
    \\ENQ\EOT\a\STX\NUL\SOH\DC2\EOT\166\ENQ\EM%\n\
    \\r\n\
    \\ENQ\EOT\a\STX\NUL\ETX\DC2\EOT\166\ENQ()\n\
    \\f\n\
    \\STX\EOT\b\DC2\ACK\169\ENQ\NUL\144\ACK\SOH\n\
    \\v\n\
    \\ETX\EOT\b\SOH\DC2\EOT\169\ENQ\b\DC3\n\
    \t\n\
    \\EOT\EOT\b\STX\NUL\DC2\EOT\174\ENQ\EOT\DC3\SUBf\n\
    \The identity pubkey of the payment recipient. When using REST, this field\n\
    \must be encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\NUL\ENQ\DC2\EOT\174\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\NUL\SOH\DC2\EOT\174\ENQ\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT\b\STX\NUL\ETX\DC2\EOT\174\ENQ\DC1\DC2\n\
    \\153\SOH\n\
    \\EOT\EOT\b\STX\SOH\DC2\EOT\180\ENQ\EOT/\SUB\138\SOH\n\
    \The hex-encoded identity pubkey of the payment recipient. Deprecated now\n\
    \that the REST gateway supports base64 encoding of bytes fields.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SOH\ENQ\DC2\EOT\180\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SOH\SOH\DC2\EOT\180\ENQ\v\SYN\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SOH\ETX\DC2\EOT\180\ENQ\EM\SUB\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SOH\b\DC2\EOT\180\ENQ\ESC.\n\
    \\SO\n\
    \\ACK\EOT\b\STX\SOH\b\ETX\DC2\EOT\180\ENQ\FS-\n\
    \n\n\
    \\EOT\EOT\b\STX\STX\DC2\EOT\187\ENQ\EOT\DC2\SUB`\n\
    \The amount to send expressed in satoshis.\n\
    \\n\
    \The fields amt and amt_msat are mutually exclusive.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\STX\ENQ\DC2\EOT\187\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\STX\SOH\DC2\EOT\187\ENQ\n\
    \\r\n\
    \\r\n\
    \\ENQ\EOT\b\STX\STX\ETX\DC2\EOT\187\ENQ\DLE\DC1\n\
    \s\n\
    \\EOT\EOT\b\STX\ETX\DC2\EOT\194\ENQ\EOT\CAN\SUBe\n\
    \The amount to send expressed in millisatoshis.\n\
    \\n\
    \The fields amt and amt_msat are mutually exclusive.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ETX\ENQ\DC2\EOT\194\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ETX\SOH\DC2\EOT\194\ENQ\n\
    \\DC2\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ETX\ETX\DC2\EOT\194\ENQ\NAK\ETB\n\
    \q\n\
    \\EOT\EOT\b\STX\EOT\DC2\EOT\200\ENQ\EOT\ESC\SUBc\n\
    \The hash to use within the payment's HTLC. When using REST, this field\n\
    \must be encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\EOT\ENQ\DC2\EOT\200\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\EOT\SOH\DC2\EOT\200\ENQ\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\b\STX\EOT\ETX\DC2\EOT\200\ENQ\EM\SUB\n\
    \\150\SOH\n\
    \\EOT\EOT\b\STX\ENQ\DC2\EOT\206\ENQ\EOT7\SUB\135\SOH\n\
    \The hex-encoded hash to use within the payment's HTLC. Deprecated now\n\
    \that the REST gateway supports base64 encoding of bytes fields.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ENQ\ENQ\DC2\EOT\206\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ENQ\SOH\DC2\EOT\206\ENQ\v\RS\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ENQ\ETX\DC2\EOT\206\ENQ!\"\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ENQ\b\DC2\EOT\206\ENQ#6\n\
    \\SO\n\
    \\ACK\EOT\b\STX\ENQ\b\ETX\DC2\EOT\206\ENQ$5\n\
    \\188\SOH\n\
    \\EOT\EOT\b\STX\ACK\DC2\EOT\213\ENQ\EOT\US\SUB\173\SOH\n\
    \A bare-bones invoice for a payment within the Lightning Network. With the\n\
    \details of the invoice, the sender has all the data necessary to send a\n\
    \payment to the recipient.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ACK\ENQ\DC2\EOT\213\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ACK\SOH\DC2\EOT\213\ENQ\v\SUB\n\
    \\r\n\
    \\ENQ\EOT\b\STX\ACK\ETX\DC2\EOT\213\ENQ\GS\RS\n\
    \q\n\
    \\EOT\EOT\b\STX\a\DC2\EOT\219\ENQ\EOT\US\SUBc\n\
    \The CLTV delta from the current height that should be used to set the\n\
    \timelock for the final hop.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\a\ENQ\DC2\EOT\219\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\a\SOH\DC2\EOT\219\ENQ\n\
    \\SUB\n\
    \\r\n\
    \\ENQ\EOT\b\STX\a\ETX\DC2\EOT\219\ENQ\GS\RS\n\
    \\130\STX\n\
    \\EOT\EOT\b\STX\b\DC2\EOT\227\ENQ\EOT\ESC\SUB\243\SOH\n\
    \The maximum number of satoshis that will be paid as a fee of the payment.\n\
    \This value can be represented either as a percentage of the amount being\n\
    \sent, or as a fixed amount of the maximum fee the user is willing the pay to\n\
    \send the payment.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\b\ACK\DC2\EOT\227\ENQ\EOT\f\n\
    \\r\n\
    \\ENQ\EOT\b\STX\b\SOH\DC2\EOT\227\ENQ\r\SYN\n\
    \\r\n\
    \\ENQ\EOT\b\STX\b\ETX\DC2\EOT\227\ENQ\EM\SUB\n\
    \t\n\
    \\EOT\EOT\b\STX\t\DC2\EOT\233\ENQ\EOT5\SUBf\n\
    \The channel id of the channel that must be taken to the first hop. If zero,\n\
    \any channel may be used.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\t\ENQ\DC2\EOT\233\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\t\SOH\DC2\EOT\233\ENQ\v\ESC\n\
    \\r\n\
    \\ENQ\EOT\b\STX\t\ETX\DC2\EOT\233\ENQ\RS\US\n\
    \\r\n\
    \\ENQ\EOT\b\STX\t\b\DC2\EOT\233\ENQ 4\n\
    \\SO\n\
    \\ACK\EOT\b\STX\t\b\ACK\DC2\EOT\233\ENQ!3\n\
    \W\n\
    \\EOT\EOT\b\STX\n\
    \\DC2\EOT\238\ENQ\EOT\US\SUBI\n\
    \The pubkey of the last hop of the route. If empty, any hop may be used.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\n\
    \\ENQ\DC2\EOT\238\ENQ\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\n\
    \\SOH\DC2\EOT\238\ENQ\n\
    \\EM\n\
    \\r\n\
    \\ENQ\EOT\b\STX\n\
    \\ETX\DC2\EOT\238\ENQ\FS\RS\n\
    \\185\SOH\n\
    \\EOT\EOT\b\STX\v\DC2\EOT\245\ENQ\EOT\ESC\SUB\170\SOH\n\
    \An optional maximum total time lock for the route. This should not exceed\n\
    \lnd's `--max-cltv-expiry` setting. If zero, then the value of\n\
    \`--max-cltv-expiry` is enforced.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\v\ENQ\DC2\EOT\245\ENQ\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\v\SOH\DC2\EOT\245\ENQ\v\NAK\n\
    \\r\n\
    \\ENQ\EOT\b\STX\v\ETX\DC2\EOT\245\ENQ\CAN\SUB\n\
    \\204\STX\n\
    \\EOT\EOT\b\STX\f\DC2\EOT\254\ENQ\EOT0\SUB\189\STX\n\
    \An optional field that can be used to pass an arbitrary set of TLV records\n\
    \to a peer which understands the new records. This can be used to pass\n\
    \application specific data during the payment attempt. Record types are\n\
    \required to be in the custom range >= 65536. When using REST, the values\n\
    \must be encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\f\ACK\DC2\EOT\254\ENQ\EOT\SYN\n\
    \\r\n\
    \\ENQ\EOT\b\STX\f\SOH\DC2\EOT\254\ENQ\ETB*\n\
    \\r\n\
    \\ENQ\EOT\b\STX\f\ETX\DC2\EOT\254\ENQ-/\n\
    \@\n\
    \\EOT\EOT\b\STX\r\DC2\EOT\129\ACK\EOT!\SUB2 If set, circular payments to self are permitted.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\r\ENQ\DC2\EOT\129\ACK\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\b\STX\r\SOH\DC2\EOT\129\ACK\t\ESC\n\
    \\r\n\
    \\ENQ\EOT\b\STX\r\ETX\DC2\EOT\129\ACK\RS \n\
    \\195\STX\n\
    \\EOT\EOT\b\STX\SO\DC2\EOT\138\ACK\EOT+\SUB\180\STX\n\
    \Features assumed to be supported by the final node. All transitive feature\n\
    \dependencies must also be set properly. For a given feature bit pair, either\n\
    \optional or remote may be set, but not both. If this field is nil or empty,\n\
    \the router will try to load destination features from the graph as a\n\
    \fallback.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SO\EOT\DC2\EOT\138\ACK\EOT\f\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SO\ACK\DC2\EOT\138\ACK\r\ETB\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SO\SOH\DC2\EOT\138\ACK\CAN%\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SO\ETX\DC2\EOT\138\ACK(*\n\
    \=\n\
    \\EOT\EOT\b\STX\SI\DC2\EOT\143\ACK\EOT\FS\SUB/\n\
    \The payment address of the generated invoice.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SI\ENQ\DC2\EOT\143\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SI\SOH\DC2\EOT\143\ACK\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\b\STX\SI\ETX\DC2\EOT\143\ACK\EM\ESC\n\
    \\f\n\
    \\STX\EOT\t\DC2\ACK\146\ACK\NUL\151\ACK\SOH\n\
    \\v\n\
    \\ETX\EOT\t\SOH\DC2\EOT\146\ACK\b\DC4\n\
    \\f\n\
    \\EOT\EOT\t\STX\NUL\DC2\EOT\147\ACK\EOT\GS\n\
    \\r\n\
    \\ENQ\EOT\t\STX\NUL\ENQ\DC2\EOT\147\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\t\STX\NUL\SOH\DC2\EOT\147\ACK\v\CAN\n\
    \\r\n\
    \\ENQ\EOT\t\STX\NUL\ETX\DC2\EOT\147\ACK\ESC\FS\n\
    \\f\n\
    \\EOT\EOT\t\STX\SOH\DC2\EOT\148\ACK\EOT\US\n\
    \\r\n\
    \\ENQ\EOT\t\STX\SOH\ENQ\DC2\EOT\148\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\t\STX\SOH\SOH\DC2\EOT\148\ACK\n\
    \\SUB\n\
    \\r\n\
    \\ENQ\EOT\t\STX\SOH\ETX\DC2\EOT\148\ACK\GS\RS\n\
    \\f\n\
    \\EOT\EOT\t\STX\STX\DC2\EOT\149\ACK\EOT\FS\n\
    \\r\n\
    \\ENQ\EOT\t\STX\STX\ACK\DC2\EOT\149\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\t\STX\STX\SOH\DC2\EOT\149\ACK\n\
    \\ETB\n\
    \\r\n\
    \\ENQ\EOT\t\STX\STX\ETX\DC2\EOT\149\ACK\SUB\ESC\n\
    \\f\n\
    \\EOT\EOT\t\STX\ETX\DC2\EOT\150\ACK\EOT\ESC\n\
    \\r\n\
    \\ENQ\EOT\t\STX\ETX\ENQ\DC2\EOT\150\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\t\STX\ETX\SOH\DC2\EOT\150\ACK\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\t\STX\ETX\ETX\DC2\EOT\150\ACK\EM\SUB\n\
    \\f\n\
    \\STX\EOT\n\
    \\DC2\ACK\153\ACK\NUL\170\ACK\SOH\n\
    \\v\n\
    \\ETX\EOT\n\
    \\SOH\DC2\EOT\153\ACK\b\SUB\n\
    \l\n\
    \\EOT\EOT\n\
    \\STX\NUL\DC2\EOT\158\ACK\EOT\ESC\SUB^\n\
    \The payment hash to use for the HTLC. When using REST, this field must be\n\
    \encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\NUL\ENQ\DC2\EOT\158\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\NUL\SOH\DC2\EOT\158\ACK\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\NUL\ETX\DC2\EOT\158\ACK\EM\SUB\n\
    \\157\SOH\n\
    \\EOT\EOT\n\
    \\STX\SOH\DC2\EOT\164\ACK\EOT7\SUB\142\SOH\n\
    \An optional hex-encoded payment hash to be used for the HTLC. Deprecated now\n\
    \that the REST gateway supports base64 encoding of bytes fields.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\SOH\ENQ\DC2\EOT\164\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\SOH\SOH\DC2\EOT\164\ACK\v\RS\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\SOH\ETX\DC2\EOT\164\ACK!\"\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\SOH\b\DC2\EOT\164\ACK#6\n\
    \\SO\n\
    \\ACK\EOT\n\
    \\STX\SOH\b\ETX\DC2\EOT\164\ACK$5\n\
    \\v\n\
    \\ETX\EOT\n\
    \\t\DC2\EOT\166\ACK\EOT\SI\n\
    \\f\n\
    \\EOT\EOT\n\
    \\t\NUL\DC2\EOT\166\ACK\r\SO\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\t\NUL\SOH\DC2\EOT\166\ACK\r\SO\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\t\NUL\STX\DC2\EOT\166\ACK\r\SO\n\
    \M\n\
    \\EOT\EOT\n\
    \\STX\STX\DC2\EOT\169\ACK\EOT\DC4\SUB? Route that should be used to attempt to complete the payment.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\STX\ACK\DC2\EOT\169\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\STX\SOH\DC2\EOT\169\ACK\n\
    \\SI\n\
    \\r\n\
    \\ENQ\EOT\n\
    \\STX\STX\ETX\DC2\EOT\169\ACK\DC2\DC3\n\
    \\f\n\
    \\STX\EOT\v\DC2\ACK\172\ACK\NUL\222\ACK\SOH\n\
    \\v\n\
    \\ETX\EOT\v\SOH\DC2\EOT\172\ACK\b\FS\n\
    \N\n\
    \\EOT\EOT\v\STX\NUL\DC2\EOT\174\ACK\EOT\SUB\SUB@ The pubkey of the node that wishes to open an inbound channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\NUL\ENQ\DC2\EOT\174\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\v\STX\NUL\SOH\DC2\EOT\174\ACK\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT\v\STX\NUL\ETX\DC2\EOT\174\ACK\CAN\EM\n\
    \S\n\
    \\EOT\EOT\v\STX\SOH\DC2\EOT\177\ACK\EOT\EM\SUBE The hash of the genesis block that the proposed channel resides in.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\SOH\ENQ\DC2\EOT\177\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\v\STX\SOH\SOH\DC2\EOT\177\ACK\n\
    \\DC4\n\
    \\r\n\
    \\ENQ\EOT\v\STX\SOH\ETX\DC2\EOT\177\ACK\ETB\CAN\n\
    \'\n\
    \\EOT\EOT\v\STX\STX\DC2\EOT\180\ACK\EOT\RS\SUB\EM The pending channel id.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\STX\ENQ\DC2\EOT\180\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\v\STX\STX\SOH\DC2\EOT\180\ACK\n\
    \\EM\n\
    \\r\n\
    \\ENQ\EOT\v\STX\STX\ETX\DC2\EOT\180\ACK\FS\GS\n\
    \\\\n\
    \\EOT\EOT\v\STX\ETX\DC2\EOT\184\ACK\EOT\ESC\SUBN The funding amount in satoshis that initiator wishes to use in the\n\
    \ channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ETX\ENQ\DC2\EOT\184\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ETX\SOH\DC2\EOT\184\ACK\v\SYN\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ETX\ETX\DC2\EOT\184\ACK\EM\SUB\n\
    \I\n\
    \\EOT\EOT\v\STX\EOT\DC2\EOT\187\ACK\EOT\CAN\SUB; The push amount of the proposed channel in millisatoshis.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\EOT\ENQ\DC2\EOT\187\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\EOT\SOH\DC2\EOT\187\ACK\v\DC3\n\
    \\r\n\
    \\ENQ\EOT\v\STX\EOT\ETX\DC2\EOT\187\ACK\SYN\ETB\n\
    \@\n\
    \\EOT\EOT\v\STX\ENQ\DC2\EOT\190\ACK\EOT\SUB\SUB2 The dust limit of the initiator's commitment tx.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ENQ\ENQ\DC2\EOT\190\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ENQ\SOH\DC2\EOT\190\ACK\v\NAK\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ENQ\ETX\DC2\EOT\190\ACK\CAN\EM\n\
    \b\n\
    \\EOT\EOT\v\STX\ACK\DC2\EOT\194\ACK\EOT#\SUBT The maximum amount of coins in millisatoshis that can be pending in this\n\
    \ channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ACK\ENQ\DC2\EOT\194\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ACK\SOH\DC2\EOT\194\ACK\v\RS\n\
    \\r\n\
    \\ENQ\EOT\v\STX\ACK\ETX\DC2\EOT\194\ACK!\"\n\
    \_\n\
    \\EOT\EOT\v\STX\a\DC2\EOT\198\ACK\EOT\US\SUBQ The minimum amount of satoshis the initiator requires us to have at all\n\
    \ times.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\a\ENQ\DC2\EOT\198\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\a\SOH\DC2\EOT\198\ACK\v\SUB\n\
    \\r\n\
    \\ENQ\EOT\v\STX\a\ETX\DC2\EOT\198\ACK\GS\RS\n\
    \R\n\
    \\EOT\EOT\v\STX\b\DC2\EOT\201\ACK\EOT\CAN\SUBD The smallest HTLC in millisatoshis that the initiator will accept.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\b\ENQ\DC2\EOT\201\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\b\SOH\DC2\EOT\201\ACK\v\DC3\n\
    \\r\n\
    \\ENQ\EOT\v\STX\b\ETX\DC2\EOT\201\ACK\SYN\ETB\n\
    \c\n\
    \\EOT\EOT\v\STX\t\DC2\EOT\205\ACK\EOT\ESC\SUBU The initial fee rate that the initiator suggests for both commitment\n\
    \ transactions.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\t\ENQ\DC2\EOT\205\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\t\SOH\DC2\EOT\205\ACK\v\NAK\n\
    \\r\n\
    \\ENQ\EOT\v\STX\t\ETX\DC2\EOT\205\ACK\CAN\SUB\n\
    \\129\SOH\n\
    \\EOT\EOT\v\STX\n\
    \\DC2\EOT\211\ACK\EOT\SUB\SUBs\n\
    \The number of blocks to use for the relative time lock in the pay-to-self\n\
    \output of both commitment transactions.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\n\
    \\ENQ\DC2\EOT\211\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\n\
    \\SOH\DC2\EOT\211\ACK\v\DC4\n\
    \\r\n\
    \\ENQ\EOT\v\STX\n\
    \\ETX\DC2\EOT\211\ACK\ETB\EM\n\
    \S\n\
    \\EOT\EOT\v\STX\v\DC2\EOT\214\ACK\EOT#\SUBE The total number of incoming HTLC's that the initiator will accept.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\v\ENQ\DC2\EOT\214\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\v\SOH\DC2\EOT\214\ACK\v\GS\n\
    \\r\n\
    \\ENQ\EOT\v\STX\v\ETX\DC2\EOT\214\ACK \"\n\
    \[\n\
    \\EOT\EOT\v\STX\f\DC2\EOT\218\ACK\EOT\RS\SUBM A bit-field which the initiator uses to specify proposed channel\n\
    \ behavior.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\f\ENQ\DC2\EOT\218\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\f\SOH\DC2\EOT\218\ACK\v\CAN\n\
    \\r\n\
    \\ENQ\EOT\v\STX\f\ETX\DC2\EOT\218\ACK\ESC\GS\n\
    \Y\n\
    \\EOT\EOT\v\STX\r\DC2\EOT\221\ACK\EOT(\SUBK The commitment type the initiator wishes to use for the proposed channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\v\STX\r\ACK\DC2\EOT\221\ACK\EOT\DC2\n\
    \\r\n\
    \\ENQ\EOT\v\STX\r\SOH\DC2\EOT\221\ACK\DC3\"\n\
    \\r\n\
    \\ENQ\EOT\v\STX\r\ETX\DC2\EOT\221\ACK%'\n\
    \\f\n\
    \\STX\EOT\f\DC2\ACK\224\ACK\NUL\154\a\SOH\n\
    \\v\n\
    \\ETX\EOT\f\SOH\DC2\EOT\224\ACK\b\GS\n\
    \>\n\
    \\EOT\EOT\f\STX\NUL\DC2\EOT\226\ACK\EOT\DC4\SUB0 Whether or not the client accepts the channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\NUL\ENQ\DC2\EOT\226\ACK\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\f\STX\NUL\SOH\DC2\EOT\226\ACK\t\SI\n\
    \\r\n\
    \\ENQ\EOT\f\STX\NUL\ETX\DC2\EOT\226\ACK\DC2\DC3\n\
    \F\n\
    \\EOT\EOT\f\STX\SOH\DC2\EOT\229\ACK\EOT\RS\SUB8 The pending channel id to which this response applies.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\SOH\ENQ\DC2\EOT\229\ACK\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\f\STX\SOH\SOH\DC2\EOT\229\ACK\n\
    \\EM\n\
    \\r\n\
    \\ENQ\EOT\f\STX\SOH\ETX\DC2\EOT\229\ACK\FS\GS\n\
    \\138\ETX\n\
    \\EOT\EOT\f\STX\STX\DC2\EOT\239\ACK\EOT\NAK\SUB\251\STX\n\
    \An optional error to send the initiating party to indicate why the channel\n\
    \was rejected. This field *should not* contain sensitive information, it will\n\
    \be sent to the initiating party. This field should only be set if accept is\n\
    \false, the channel will be rejected if an error is set with accept=true\n\
    \because the meaning of this response is ambiguous. Limited to 500\n\
    \characters.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\STX\ENQ\DC2\EOT\239\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\STX\SOH\DC2\EOT\239\ACK\v\DLE\n\
    \\r\n\
    \\ENQ\EOT\f\STX\STX\ETX\DC2\EOT\239\ACK\DC3\DC4\n\
    \\140\STX\n\
    \\EOT\EOT\f\STX\ETX\DC2\EOT\247\ACK\EOT \SUB\253\SOH\n\
    \The upfront shutdown address to use if the initiating peer supports option\n\
    \upfront shutdown script (see ListPeers for the features supported). Note\n\
    \that the channel open will fail if this value is set for a peer that does\n\
    \not support this feature bit.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ETX\ENQ\DC2\EOT\247\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ETX\SOH\DC2\EOT\247\ACK\v\ESC\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ETX\ETX\DC2\EOT\247\ACK\RS\US\n\
    \O\n\
    \\EOT\EOT\f\STX\EOT\DC2\EOT\252\ACK\EOT\EM\SUBA\n\
    \The csv delay (in blocks) that we require for the remote party.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\EOT\ENQ\DC2\EOT\252\ACK\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\EOT\SOH\DC2\EOT\252\ACK\v\DC4\n\
    \\r\n\
    \\ENQ\EOT\f\STX\EOT\ETX\DC2\EOT\252\ACK\ETB\CAN\n\
    \\187\STX\n\
    \\EOT\EOT\f\STX\ENQ\DC2\EOT\132\a\EOT\ESC\SUB\172\STX\n\
    \The reserve amount in satoshis that we require the remote peer to adhere to.\n\
    \We require that the remote peer always have some reserve amount allocated to\n\
    \them so that there is always a disincentive to broadcast old state (if they\n\
    \hold 0 sats on their side of the channel, there is nothing to lose).\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ENQ\ENQ\DC2\EOT\132\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ENQ\SOH\DC2\EOT\132\a\v\SYN\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ENQ\ETX\DC2\EOT\132\a\EM\SUB\n\
    \x\n\
    \\EOT\EOT\f\STX\ACK\DC2\EOT\138\a\EOT\"\SUBj\n\
    \The maximum amount of funds in millisatoshis that we allow the remote peer\n\
    \to have in outstanding htlcs.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ACK\ENQ\DC2\EOT\138\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ACK\SOH\DC2\EOT\138\a\v\GS\n\
    \\r\n\
    \\ENQ\EOT\f\STX\ACK\ETX\DC2\EOT\138\a !\n\
    \N\n\
    \\EOT\EOT\f\STX\a\DC2\EOT\143\a\EOT\RS\SUB@\n\
    \The maximum number of htlcs that the remote peer can offer us.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\a\ENQ\DC2\EOT\143\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\a\SOH\DC2\EOT\143\a\v\EM\n\
    \\r\n\
    \\ENQ\EOT\f\STX\a\ETX\DC2\EOT\143\a\FS\GS\n\
    \U\n\
    \\EOT\EOT\f\STX\b\DC2\EOT\148\a\EOT\ESC\SUBG\n\
    \The minimum value in millisatoshis for incoming htlcs on the channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\b\ENQ\DC2\EOT\148\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\b\SOH\DC2\EOT\148\a\v\SYN\n\
    \\r\n\
    \\ENQ\EOT\f\STX\b\ETX\DC2\EOT\148\a\EM\SUB\n\
    \[\n\
    \\EOT\EOT\f\STX\t\DC2\EOT\153\a\EOT!\SUBM\n\
    \The number of confirmations we require before we consider the channel open.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\t\ENQ\DC2\EOT\153\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\f\STX\t\SOH\DC2\EOT\153\a\v\ESC\n\
    \\r\n\
    \\ENQ\EOT\f\STX\t\ETX\DC2\EOT\153\a\RS \n\
    \\f\n\
    \\STX\EOT\r\DC2\ACK\156\a\NUL\163\a\SOH\n\
    \\v\n\
    \\ETX\EOT\r\SOH\DC2\EOT\156\a\b\CAN\n\
    \9\n\
    \\EOT\EOT\r\STX\NUL\DC2\EOT\158\a\EOT\SYN\SUB+ The identity pubkey of the Lightning node\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\r\STX\NUL\ENQ\DC2\EOT\158\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\r\STX\NUL\SOH\DC2\EOT\158\a\v\DC1\n\
    \\r\n\
    \\ENQ\EOT\r\STX\NUL\ETX\DC2\EOT\158\a\DC4\NAK\n\
    \i\n\
    \\EOT\EOT\r\STX\SOH\DC2\EOT\162\a\EOT\DC4\SUB[ The network location of the lightning node, e.g. `69.69.69.69:1337` or\n\
    \ `localhost:10011`\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\r\STX\SOH\ENQ\DC2\EOT\162\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\r\STX\SOH\SOH\DC2\EOT\162\a\v\SI\n\
    \\r\n\
    \\ENQ\EOT\r\STX\SOH\ETX\DC2\EOT\162\a\DC2\DC3\n\
    \\f\n\
    \\STX\EOT\SO\DC2\ACK\165\a\NUL\179\a\SOH\n\
    \\v\n\
    \\ETX\EOT\SO\SOH\DC2\EOT\165\a\b\SUB\n\
    \F\n\
    \\EOT\EOT\SO\STX\NUL\DC2\EOT\167\a\EOT(\SUB8 The map from addresses to amounts for the transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\NUL\ACK\DC2\EOT\167\a\EOT\SYN\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\NUL\SOH\DC2\EOT\167\a\ETB#\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\NUL\ETX\DC2\EOT\167\a&'\n\
    \Z\n\
    \\EOT\EOT\SO\STX\SOH\DC2\EOT\171\a\EOT\SUB\SUBL The target number of blocks that this transaction should be confirmed\n\
    \ by.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\SOH\ENQ\DC2\EOT\171\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\SOH\SOH\DC2\EOT\171\a\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\SOH\ETX\DC2\EOT\171\a\CAN\EM\n\
    \t\n\
    \\EOT\EOT\SO\STX\STX\DC2\EOT\175\a\EOT\CAN\SUBf The minimum number of confirmations each one of your outputs used for\n\
    \ the transaction must satisfy.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\STX\ENQ\DC2\EOT\175\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\STX\SOH\DC2\EOT\175\a\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\STX\ETX\DC2\EOT\175\a\SYN\ETB\n\
    \Y\n\
    \\EOT\EOT\SO\STX\ETX\DC2\EOT\178\a\EOT\US\SUBK Whether unconfirmed outputs should be used as inputs for the transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\ETX\ENQ\DC2\EOT\178\a\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\ETX\SOH\DC2\EOT\178\a\t\SUB\n\
    \\r\n\
    \\ENQ\EOT\SO\STX\ETX\ETX\DC2\EOT\178\a\GS\RS\n\
    \\f\n\
    \\STX\EOT\SI\DC2\ACK\181\a\NUL\191\a\SOH\n\
    \\v\n\
    \\ETX\EOT\SI\SOH\DC2\EOT\181\a\b\ESC\n\
    \*\n\
    \\EOT\EOT\SI\STX\NUL\DC2\EOT\183\a\EOT\SYN\SUB\FS The total fee in satoshis.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\NUL\ENQ\DC2\EOT\183\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\NUL\SOH\DC2\EOT\183\a\n\
    \\DC1\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\NUL\ETX\DC2\EOT\183\a\DC4\NAK\n\
    \N\n\
    \\EOT\EOT\SI\STX\SOH\DC2\EOT\187\a\EOT7\SUB@ Deprecated, use sat_per_vbyte.\n\
    \ The fee rate in satoshi/vbyte.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\SOH\ENQ\DC2\EOT\187\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\SOH\SOH\DC2\EOT\187\a\n\
    \\RS\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\SOH\ETX\DC2\EOT\187\a!\"\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\SOH\b\DC2\EOT\187\a#6\n\
    \\SO\n\
    \\ACK\EOT\SI\STX\SOH\b\ETX\DC2\EOT\187\a$5\n\
    \.\n\
    \\EOT\EOT\SI\STX\STX\DC2\EOT\190\a\EOT\GS\SUB  The fee rate in satoshi/vbyte.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\STX\ENQ\DC2\EOT\190\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\STX\SOH\DC2\EOT\190\a\v\CAN\n\
    \\r\n\
    \\ENQ\EOT\SI\STX\STX\ETX\DC2\EOT\190\a\ESC\FS\n\
    \\f\n\
    \\STX\EOT\DLE\DC2\ACK\193\a\NUL\219\a\SOH\n\
    \\v\n\
    \\ETX\EOT\DLE\SOH\DC2\EOT\193\a\b\ETB\n\
    \1\n\
    \\EOT\EOT\DLE\STX\NUL\DC2\EOT\195\a\EOT(\SUB# The map from addresses to amounts\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\NUL\ACK\DC2\EOT\195\a\EOT\SYN\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\NUL\SOH\DC2\EOT\195\a\ETB#\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\NUL\ETX\DC2\EOT\195\a&'\n\
    \Z\n\
    \\EOT\EOT\DLE\STX\SOH\DC2\EOT\199\a\EOT\SUB\SUBL The target number of blocks that this transaction should be confirmed\n\
    \ by.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\SOH\ENQ\DC2\EOT\199\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\SOH\SOH\DC2\EOT\199\a\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\SOH\ETX\DC2\EOT\199\a\CAN\EM\n\
    \f\n\
    \\EOT\EOT\DLE\STX\STX\DC2\EOT\203\a\EOT\GS\SUBX A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\STX\ENQ\DC2\EOT\203\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\STX\SOH\DC2\EOT\203\a\v\CAN\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\STX\ETX\DC2\EOT\203\a\ESC\FS\n\
    \\134\SOH\n\
    \\EOT\EOT\DLE\STX\ETX\DC2\EOT\208\a\EOT/\SUBx Deprecated, use sat_per_vbyte.\n\
    \ A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ETX\ENQ\DC2\EOT\208\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ETX\SOH\DC2\EOT\208\a\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ETX\ETX\DC2\EOT\208\a\EM\SUB\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ETX\b\DC2\EOT\208\a\ESC.\n\
    \\SO\n\
    \\ACK\EOT\DLE\STX\ETX\b\ETX\DC2\EOT\208\a\FS-\n\
    \Q\n\
    \\EOT\EOT\DLE\STX\EOT\DC2\EOT\211\a\EOT\NAK\SUBC An optional label for the transaction, limited to 500 characters.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\EOT\ENQ\DC2\EOT\211\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\EOT\SOH\DC2\EOT\211\a\v\DLE\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\EOT\ETX\DC2\EOT\211\a\DC3\DC4\n\
    \t\n\
    \\EOT\EOT\DLE\STX\ENQ\DC2\EOT\215\a\EOT\CAN\SUBf The minimum number of confirmations each one of your outputs used for\n\
    \ the transaction must satisfy.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ENQ\ENQ\DC2\EOT\215\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ENQ\SOH\DC2\EOT\215\a\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ENQ\ETX\DC2\EOT\215\a\SYN\ETB\n\
    \Y\n\
    \\EOT\EOT\DLE\STX\ACK\DC2\EOT\218\a\EOT\US\SUBK Whether unconfirmed outputs should be used as inputs for the transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ACK\ENQ\DC2\EOT\218\a\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ACK\SOH\DC2\EOT\218\a\t\SUB\n\
    \\r\n\
    \\ENQ\EOT\DLE\STX\ACK\ETX\DC2\EOT\218\a\GS\RS\n\
    \\f\n\
    \\STX\EOT\DC1\DC2\ACK\220\a\NUL\223\a\SOH\n\
    \\v\n\
    \\ETX\EOT\DC1\SOH\DC2\EOT\220\a\b\CAN\n\
    \)\n\
    \\EOT\EOT\DC1\STX\NUL\DC2\EOT\222\a\EOT\DC4\SUB\ESC The id of the transaction\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC1\STX\NUL\ENQ\DC2\EOT\222\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC1\STX\NUL\SOH\DC2\EOT\222\a\v\SI\n\
    \\r\n\
    \\ENQ\EOT\DC1\STX\NUL\ETX\DC2\EOT\222\a\DC2\DC3\n\
    \\f\n\
    \\STX\EOT\DC2\DC2\ACK\225\a\NUL\133\b\SOH\n\
    \\v\n\
    \\ETX\EOT\DC2\SOH\DC2\EOT\225\a\b\CAN\n\
    \,\n\
    \\EOT\EOT\DC2\STX\NUL\DC2\EOT\227\a\EOT\DC4\SUB\RS The address to send coins to\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\NUL\ENQ\DC2\EOT\227\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\NUL\SOH\DC2\EOT\227\a\v\SI\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\NUL\ETX\DC2\EOT\227\a\DC2\DC3\n\
    \.\n\
    \\EOT\EOT\DC2\STX\SOH\DC2\EOT\230\a\EOT\NAK\SUB  The amount in satoshis to send\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\SOH\ENQ\DC2\EOT\230\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\SOH\SOH\DC2\EOT\230\a\n\
    \\DLE\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\SOH\ETX\DC2\EOT\230\a\DC3\DC4\n\
    \Z\n\
    \\EOT\EOT\DC2\STX\STX\DC2\EOT\234\a\EOT\SUB\SUBL The target number of blocks that this transaction should be confirmed\n\
    \ by.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\STX\ENQ\DC2\EOT\234\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\STX\SOH\DC2\EOT\234\a\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\STX\ETX\DC2\EOT\234\a\CAN\EM\n\
    \f\n\
    \\EOT\EOT\DC2\STX\ETX\DC2\EOT\238\a\EOT\GS\SUBX A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ETX\ENQ\DC2\EOT\238\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ETX\SOH\DC2\EOT\238\a\v\CAN\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ETX\ETX\DC2\EOT\238\a\ESC\FS\n\
    \\134\SOH\n\
    \\EOT\EOT\DC2\STX\EOT\DC2\EOT\243\a\EOT/\SUBx Deprecated, use sat_per_vbyte.\n\
    \ A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\EOT\ENQ\DC2\EOT\243\a\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\EOT\SOH\DC2\EOT\243\a\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\EOT\ETX\DC2\EOT\243\a\EM\SUB\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\EOT\b\DC2\EOT\243\a\ESC.\n\
    \\SO\n\
    \\ACK\EOT\DC2\STX\EOT\b\ETX\DC2\EOT\243\a\FS-\n\
    \\169\SOH\n\
    \\EOT\EOT\DC2\STX\ENQ\DC2\EOT\250\a\EOT\SYN\SUB\154\SOH\n\
    \If set, then the amount field will be ignored, and lnd will attempt to\n\
    \send all the coins under control of the internal wallet to the specified\n\
    \address.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ENQ\ENQ\DC2\EOT\250\a\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ENQ\SOH\DC2\EOT\250\a\t\DC1\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ENQ\ETX\DC2\EOT\250\a\DC4\NAK\n\
    \Q\n\
    \\EOT\EOT\DC2\STX\ACK\DC2\EOT\253\a\EOT\NAK\SUBC An optional label for the transaction, limited to 500 characters.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ACK\ENQ\DC2\EOT\253\a\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ACK\SOH\DC2\EOT\253\a\v\DLE\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\ACK\ETX\DC2\EOT\253\a\DC3\DC4\n\
    \t\n\
    \\EOT\EOT\DC2\STX\a\DC2\EOT\129\b\EOT\CAN\SUBf The minimum number of confirmations each one of your outputs used for\n\
    \ the transaction must satisfy.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\a\ENQ\DC2\EOT\129\b\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\a\SOH\DC2\EOT\129\b\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\a\ETX\DC2\EOT\129\b\SYN\ETB\n\
    \Y\n\
    \\EOT\EOT\DC2\STX\b\DC2\EOT\132\b\EOT\US\SUBK Whether unconfirmed outputs should be used as inputs for the transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\b\ENQ\DC2\EOT\132\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\b\SOH\DC2\EOT\132\b\t\SUB\n\
    \\r\n\
    \\ENQ\EOT\DC2\STX\b\ETX\DC2\EOT\132\b\GS\RS\n\
    \\f\n\
    \\STX\EOT\DC3\DC2\ACK\134\b\NUL\137\b\SOH\n\
    \\v\n\
    \\ETX\EOT\DC3\SOH\DC2\EOT\134\b\b\EM\n\
    \5\n\
    \\EOT\EOT\DC3\STX\NUL\DC2\EOT\136\b\EOT\DC4\SUB' The transaction ID of the transaction\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC3\STX\NUL\ENQ\DC2\EOT\136\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC3\STX\NUL\SOH\DC2\EOT\136\b\v\SI\n\
    \\r\n\
    \\ENQ\EOT\DC3\STX\NUL\ETX\DC2\EOT\136\b\DC2\DC3\n\
    \\f\n\
    \\STX\EOT\DC4\DC2\ACK\139\b\NUL\148\b\SOH\n\
    \\v\n\
    \\ETX\EOT\DC4\SOH\DC2\EOT\139\b\b\SUB\n\
    \C\n\
    \\EOT\EOT\DC4\STX\NUL\DC2\EOT\141\b\EOT\CAN\SUB5 The minimum number of confirmations to be included.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\NUL\ENQ\DC2\EOT\141\b\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\NUL\SOH\DC2\EOT\141\b\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\NUL\ETX\DC2\EOT\141\b\SYN\ETB\n\
    \C\n\
    \\EOT\EOT\DC4\STX\SOH\DC2\EOT\144\b\EOT\CAN\SUB5 The maximum number of confirmations to be included.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\SOH\ENQ\DC2\EOT\144\b\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\SOH\SOH\DC2\EOT\144\b\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\SOH\ETX\DC2\EOT\144\b\SYN\ETB\n\
    \S\n\
    \\EOT\EOT\DC4\STX\STX\DC2\EOT\147\b\EOT\ETB\SUBE An optional filter to only include outputs belonging to an account.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\STX\ENQ\DC2\EOT\147\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\STX\SOH\DC2\EOT\147\b\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\DC4\STX\STX\ETX\DC2\EOT\147\b\NAK\SYN\n\
    \\f\n\
    \\STX\EOT\NAK\DC2\ACK\149\b\NUL\152\b\SOH\n\
    \\v\n\
    \\ETX\EOT\NAK\SOH\DC2\EOT\149\b\b\ESC\n\
    \\US\n\
    \\EOT\EOT\NAK\STX\NUL\DC2\EOT\151\b\EOT\FS\SUB\DC1 A list of utxos\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\NAK\STX\NUL\EOT\DC2\EOT\151\b\EOT\f\n\
    \\r\n\
    \\ENQ\EOT\NAK\STX\NUL\ACK\DC2\EOT\151\b\r\DC1\n\
    \\r\n\
    \\ENQ\EOT\NAK\STX\NUL\SOH\DC2\EOT\151\b\DC2\ETB\n\
    \\r\n\
    \\ENQ\EOT\NAK\STX\NUL\ETX\DC2\EOT\151\b\SUB\ESC\n\
    \\182\SOH\n\
    \\STX\ENQ\NUL\DC2\ACK\160\b\NUL\165\b\SOH\SUB\167\SOH\n\
    \`AddressType` has to be one of:\n\
    \\n\
    \- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)\n\
    \- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)\n\
    \\n\
    \\v\n\
    \\ETX\ENQ\NUL\SOH\DC2\EOT\160\b\ENQ\DLE\n\
    \\f\n\
    \\EOT\ENQ\NUL\STX\NUL\DC2\EOT\161\b\EOT\FS\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\NUL\SOH\DC2\EOT\161\b\EOT\ETB\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\NUL\STX\DC2\EOT\161\b\SUB\ESC\n\
    \\f\n\
    \\EOT\ENQ\NUL\STX\SOH\DC2\EOT\162\b\EOT\ESC\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\SOH\SOH\DC2\EOT\162\b\EOT\SYN\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\SOH\STX\DC2\EOT\162\b\EM\SUB\n\
    \\f\n\
    \\EOT\ENQ\NUL\STX\STX\DC2\EOT\163\b\EOT#\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\STX\SOH\DC2\EOT\163\b\EOT\RS\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\STX\STX\DC2\EOT\163\b!\"\n\
    \\f\n\
    \\EOT\ENQ\NUL\STX\ETX\DC2\EOT\164\b\EOT\"\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\ETX\SOH\DC2\EOT\164\b\EOT\GS\n\
    \\r\n\
    \\ENQ\ENQ\NUL\STX\ETX\STX\DC2\EOT\164\b !\n\
    \\f\n\
    \\STX\EOT\SYN\DC2\ACK\167\b\NUL\176\b\SOH\n\
    \\v\n\
    \\ETX\EOT\SYN\SOH\DC2\EOT\167\b\b\EM\n\
    \0\n\
    \\EOT\EOT\SYN\STX\NUL\DC2\EOT\169\b\EOT\EM\SUB\" The type of address to generate.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SYN\STX\NUL\ACK\DC2\EOT\169\b\EOT\SI\n\
    \\r\n\
    \\ENQ\EOT\SYN\STX\NUL\SOH\DC2\EOT\169\b\DLE\DC4\n\
    \\r\n\
    \\ENQ\EOT\SYN\STX\NUL\ETX\DC2\EOT\169\b\ETB\CAN\n\
    \t\n\
    \\EOT\EOT\SYN\STX\SOH\DC2\EOT\175\b\EOT\ETB\SUBf\n\
    \The name of the account to generate a new address for. If empty, the\n\
    \default wallet account is used.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SYN\STX\SOH\ENQ\DC2\EOT\175\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SYN\STX\SOH\SOH\DC2\EOT\175\b\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\SYN\STX\SOH\ETX\DC2\EOT\175\b\NAK\SYN\n\
    \\f\n\
    \\STX\EOT\ETB\DC2\ACK\177\b\NUL\180\b\SOH\n\
    \\v\n\
    \\ETX\EOT\ETB\SOH\DC2\EOT\177\b\b\SUB\n\
    \2\n\
    \\EOT\EOT\ETB\STX\NUL\DC2\EOT\179\b\EOT\ETB\SUB$ The newly generated wallet address\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ETB\STX\NUL\ENQ\DC2\EOT\179\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ETB\STX\NUL\SOH\DC2\EOT\179\b\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\ETB\STX\NUL\ETX\DC2\EOT\179\b\NAK\SYN\n\
    \\f\n\
    \\STX\EOT\CAN\DC2\ACK\182\b\NUL\194\b\SOH\n\
    \\v\n\
    \\ETX\EOT\CAN\SOH\DC2\EOT\182\b\b\SUB\n\
    \`\n\
    \\EOT\EOT\CAN\STX\NUL\DC2\EOT\187\b\EOT\DC2\SUBR\n\
    \The message to be signed. When using REST, this field must be encoded as\n\
    \base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\CAN\STX\NUL\ENQ\DC2\EOT\187\b\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\CAN\STX\NUL\SOH\DC2\EOT\187\b\n\
    \\r\n\
    \\r\n\
    \\ENQ\EOT\CAN\STX\NUL\ETX\DC2\EOT\187\b\DLE\DC1\n\
    \\130\SOH\n\
    \\EOT\EOT\CAN\STX\SOH\DC2\EOT\193\b\EOT\EM\SUBt\n\
    \Instead of the default double-SHA256 hashing of the message before signing,\n\
    \only use one round of hashing instead.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\CAN\STX\SOH\ENQ\DC2\EOT\193\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\CAN\STX\SOH\SOH\DC2\EOT\193\b\t\DC4\n\
    \\r\n\
    \\ENQ\EOT\CAN\STX\SOH\ETX\DC2\EOT\193\b\ETB\CAN\n\
    \\f\n\
    \\STX\EOT\EM\DC2\ACK\195\b\NUL\198\b\SOH\n\
    \\v\n\
    \\ETX\EOT\EM\SOH\DC2\EOT\195\b\b\ESC\n\
    \3\n\
    \\EOT\EOT\EM\STX\NUL\DC2\EOT\197\b\EOT\EM\SUB% The signature for the given message\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EM\STX\NUL\ENQ\DC2\EOT\197\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\EM\STX\NUL\SOH\DC2\EOT\197\b\v\DC4\n\
    \\r\n\
    \\ENQ\EOT\EM\STX\NUL\ETX\DC2\EOT\197\b\ETB\CAN\n\
    \\f\n\
    \\STX\EOT\SUB\DC2\ACK\200\b\NUL\209\b\SOH\n\
    \\v\n\
    \\ETX\EOT\SUB\SOH\DC2\EOT\200\b\b\FS\n\
    \~\n\
    \\EOT\EOT\SUB\STX\NUL\DC2\EOT\205\b\EOT\DC2\SUBp\n\
    \The message over which the signature is to be verified. When using REST,\n\
    \this field must be encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SUB\STX\NUL\ENQ\DC2\EOT\205\b\EOT\t\n\
    \\r\n\
    \\ENQ\EOT\SUB\STX\NUL\SOH\DC2\EOT\205\b\n\
    \\r\n\
    \\r\n\
    \\ENQ\EOT\SUB\STX\NUL\ETX\DC2\EOT\205\b\DLE\DC1\n\
    \C\n\
    \\EOT\EOT\SUB\STX\SOH\DC2\EOT\208\b\EOT\EM\SUB5 The signature to be verified over the given message\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SUB\STX\SOH\ENQ\DC2\EOT\208\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\SUB\STX\SOH\SOH\DC2\EOT\208\b\v\DC4\n\
    \\r\n\
    \\ENQ\EOT\SUB\STX\SOH\ETX\DC2\EOT\208\b\ETB\CAN\n\
    \\f\n\
    \\STX\EOT\ESC\DC2\ACK\210\b\NUL\216\b\SOH\n\
    \\v\n\
    \\ETX\EOT\ESC\SOH\DC2\EOT\210\b\b\GS\n\
    \F\n\
    \\EOT\EOT\ESC\STX\NUL\DC2\EOT\212\b\EOT\DC3\SUB8 Whether the signature was valid over the given message\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ESC\STX\NUL\ENQ\DC2\EOT\212\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\ESC\STX\NUL\SOH\DC2\EOT\212\b\t\SO\n\
    \\r\n\
    \\ENQ\EOT\ESC\STX\NUL\ETX\DC2\EOT\212\b\DC1\DC2\n\
    \7\n\
    \\EOT\EOT\ESC\STX\SOH\DC2\EOT\215\b\EOT\SYN\SUB) The pubkey recovered from the signature\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ESC\STX\SOH\ENQ\DC2\EOT\215\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\ESC\STX\SOH\SOH\DC2\EOT\215\b\v\DC1\n\
    \\r\n\
    \\ENQ\EOT\ESC\STX\SOH\ETX\DC2\EOT\215\b\DC4\NAK\n\
    \\f\n\
    \\STX\EOT\FS\DC2\ACK\218\b\NUL\231\b\SOH\n\
    \\v\n\
    \\ETX\EOT\FS\SOH\DC2\EOT\218\b\b\SUB\n\
    \L\n\
    \\EOT\EOT\FS\STX\NUL\DC2\EOT\220\b\EOT\RS\SUB> Lightning address of the peer, in the format `<pubkey>@host`\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\NUL\ACK\DC2\EOT\220\b\EOT\DC4\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\NUL\SOH\DC2\EOT\220\b\NAK\EM\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\NUL\ETX\DC2\EOT\220\b\FS\GS\n\
    \\133\SOH\n\
    \\EOT\EOT\FS\STX\SOH\DC2\EOT\224\b\EOT\DC2\SUBw If set, the daemon will attempt to persistently connect to the target\n\
    \ peer. Otherwise, the call will be synchronous. \n\
    \\r\n\
    \\ENQ\EOT\FS\STX\SOH\ENQ\DC2\EOT\224\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\SOH\SOH\DC2\EOT\224\b\t\r\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\SOH\ETX\DC2\EOT\224\b\DLE\DC1\n\
    \k\n\
    \\EOT\EOT\FS\STX\STX\DC2\EOT\230\b\EOT\ETB\SUB]\n\
    \The connection timeout value (in seconds) for this request. It won't affect\n\
    \other requests.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\STX\ENQ\DC2\EOT\230\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\STX\SOH\DC2\EOT\230\b\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\FS\STX\STX\ETX\DC2\EOT\230\b\NAK\SYN\n\
    \\f\n\
    \\STX\EOT\GS\DC2\ACK\232\b\NUL\233\b\SOH\n\
    \\v\n\
    \\ETX\EOT\GS\SOH\DC2\EOT\232\b\b\ESC\n\
    \\f\n\
    \\STX\EOT\RS\DC2\ACK\235\b\NUL\238\b\SOH\n\
    \\v\n\
    \\ETX\EOT\RS\SOH\DC2\EOT\235\b\b\GS\n\
    \9\n\
    \\EOT\EOT\RS\STX\NUL\DC2\EOT\237\b\EOT\ETB\SUB+ The pubkey of the node to disconnect from\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\RS\STX\NUL\ENQ\DC2\EOT\237\b\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT\RS\STX\NUL\SOH\DC2\EOT\237\b\v\DC2\n\
    \\r\n\
    \\ENQ\EOT\RS\STX\NUL\ETX\DC2\EOT\237\b\NAK\SYN\n\
    \\f\n\
    \\STX\EOT\US\DC2\ACK\239\b\NUL\240\b\SOH\n\
    \\v\n\
    \\ETX\EOT\US\SOH\DC2\EOT\239\b\b\RS\n\
    \\f\n\
    \\STX\EOT \DC2\ACK\242\b\NUL\253\b\SOH\n\
    \\v\n\
    \\ETX\EOT \SOH\DC2\EOT\242\b\b\ESC\n\
    \\f\n\
    \\EOT\EOT \STX\NUL\DC2\EOT\243\b\EOT\EM\n\
    \\r\n\
    \\ENQ\EOT \STX\NUL\ENQ\DC2\EOT\243\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT \STX\NUL\SOH\DC2\EOT\243\b\t\DC4\n\
    \\r\n\
    \\ENQ\EOT \STX\NUL\ETX\DC2\EOT\243\b\ETB\CAN\n\
    \\f\n\
    \\EOT\EOT \STX\SOH\DC2\EOT\244\b\EOT\ESC\n\
    \\r\n\
    \\ENQ\EOT \STX\SOH\ENQ\DC2\EOT\244\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT \STX\SOH\SOH\DC2\EOT\244\b\t\SYN\n\
    \\r\n\
    \\ENQ\EOT \STX\SOH\ETX\DC2\EOT\244\b\EM\SUB\n\
    \\f\n\
    \\EOT\EOT \STX\STX\DC2\EOT\245\b\EOT\EM\n\
    \\r\n\
    \\ENQ\EOT \STX\STX\ENQ\DC2\EOT\245\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT \STX\STX\SOH\DC2\EOT\245\b\t\DC4\n\
    \\r\n\
    \\ENQ\EOT \STX\STX\ETX\DC2\EOT\245\b\ETB\CAN\n\
    \\f\n\
    \\EOT\EOT \STX\ETX\DC2\EOT\246\b\EOT\SUB\n\
    \\r\n\
    \\ENQ\EOT \STX\ETX\ENQ\DC2\EOT\246\b\EOT\b\n\
    \\r\n\
    \\ENQ\EOT \STX\ETX\SOH\DC2\EOT\246\b\t\NAK\n\
    \\r\n\
    \\ENQ\EOT \STX\ETX\ETX\DC2\EOT\246\b\CAN\EM\n\
    \\DEL\n\
    \\EOT\EOT \STX\EOT\DC2\EOT\252\b\EOT\DC3\SUBq\n\
    \Filters the response for channels with a target peer's pubkey. If peer is\n\
    \empty, all channels will be returned.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT \STX\EOT\ENQ\DC2\EOT\252\b\EOT\t\n\
    \\r\n\
    \\ENQ\EOT \STX\EOT\SOH\DC2\EOT\252\b\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT \STX\EOT\ETX\DC2\EOT\252\b\DC1\DC2\n\
    \\f\n\
    \\STX\EOT!\DC2\ACK\254\b\NUL\129\t\SOH\n\
    \\v\n\
    \\ETX\EOT!\SOH\DC2\EOT\254\b\b\FS\n\
    \+\n\
    \\EOT\EOT!\STX\NUL\DC2\EOT\128\t\EOT#\SUB\GS The list of active channels\n\
    \\n\
    \\r\n\
    \\ENQ\EOT!\STX\NUL\EOT\DC2\EOT\128\t\EOT\f\n\
    \\r\n\
    \\ENQ\EOT!\STX\NUL\ACK\DC2\EOT\128\t\r\DC4\n\
    \\r\n\
    \\ENQ\EOT!\STX\NUL\SOH\DC2\EOT\128\t\NAK\GS\n\
    \\r\n\
    \\ENQ\EOT!\STX\NUL\ETX\DC2\EOT\128\t \"\n\
    \\f\n\
    \\STX\EOT\"\DC2\ACK\131\t\NUL\138\t\SOH\n\
    \\v\n\
    \\ETX\EOT\"\SOH\DC2\EOT\131\t\b\GS\n\
    \\f\n\
    \\EOT\EOT\"\STX\NUL\DC2\EOT\132\t\EOT\EM\n\
    \\r\n\
    \\ENQ\EOT\"\STX\NUL\ENQ\DC2\EOT\132\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\"\STX\NUL\SOH\DC2\EOT\132\t\t\DC4\n\
    \\r\n\
    \\ENQ\EOT\"\STX\NUL\ETX\DC2\EOT\132\t\ETB\CAN\n\
    \\f\n\
    \\EOT\EOT\"\STX\SOH\DC2\EOT\133\t\EOT\EM\n\
    \\r\n\
    \\ENQ\EOT\"\STX\SOH\ENQ\DC2\EOT\133\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\"\STX\SOH\SOH\DC2\EOT\133\t\t\DC4\n\
    \\r\n\
    \\ENQ\EOT\"\STX\SOH\ETX\DC2\EOT\133\t\ETB\CAN\n\
    \\f\n\
    \\EOT\EOT\"\STX\STX\DC2\EOT\134\t\EOT\SUB\n\
    \\r\n\
    \\ENQ\EOT\"\STX\STX\ENQ\DC2\EOT\134\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\"\STX\STX\SOH\DC2\EOT\134\t\t\NAK\n\
    \\r\n\
    \\ENQ\EOT\"\STX\STX\ETX\DC2\EOT\134\t\CAN\EM\n\
    \\f\n\
    \\EOT\EOT\"\STX\ETX\DC2\EOT\135\t\EOT\DC4\n\
    \\r\n\
    \\ENQ\EOT\"\STX\ETX\ENQ\DC2\EOT\135\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\"\STX\ETX\SOH\DC2\EOT\135\t\t\SI\n\
    \\r\n\
    \\ENQ\EOT\"\STX\ETX\ETX\DC2\EOT\135\t\DC2\DC3\n\
    \\f\n\
    \\EOT\EOT\"\STX\EOT\DC2\EOT\136\t\EOT\RS\n\
    \\r\n\
    \\ENQ\EOT\"\STX\EOT\ENQ\DC2\EOT\136\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\"\STX\EOT\SOH\DC2\EOT\136\t\t\EM\n\
    \\r\n\
    \\ENQ\EOT\"\STX\EOT\ETX\DC2\EOT\136\t\FS\GS\n\
    \\f\n\
    \\EOT\EOT\"\STX\ENQ\DC2\EOT\137\t\EOT\ETB\n\
    \\r\n\
    \\ENQ\EOT\"\STX\ENQ\ENQ\DC2\EOT\137\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT\"\STX\ENQ\SOH\DC2\EOT\137\t\t\DC2\n\
    \\r\n\
    \\ENQ\EOT\"\STX\ENQ\ETX\DC2\EOT\137\t\NAK\SYN\n\
    \\f\n\
    \\STX\EOT#\DC2\ACK\140\t\NUL\142\t\SOH\n\
    \\v\n\
    \\ETX\EOT#\SOH\DC2\EOT\140\t\b\RS\n\
    \\f\n\
    \\EOT\EOT#\STX\NUL\DC2\EOT\141\t\EOT.\n\
    \\r\n\
    \\ENQ\EOT#\STX\NUL\EOT\DC2\EOT\141\t\EOT\f\n\
    \\r\n\
    \\ENQ\EOT#\STX\NUL\ACK\DC2\EOT\141\t\r \n\
    \\r\n\
    \\ENQ\EOT#\STX\NUL\SOH\DC2\EOT\141\t!)\n\
    \\r\n\
    \\ENQ\EOT#\STX\NUL\ETX\DC2\EOT\141\t,-\n\
    \\f\n\
    \\STX\EOT$\DC2\ACK\144\t\NUL\224\t\SOH\n\
    \\v\n\
    \\ETX\EOT$\SOH\DC2\EOT\144\t\b\f\n\
    \/\n\
    \\EOT\EOT$\STX\NUL\DC2\EOT\146\t\EOT\ETB\SUB! The identity pubkey of the peer\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\NUL\ENQ\DC2\EOT\146\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\NUL\SOH\DC2\EOT\146\t\v\DC2\n\
    \\r\n\
    \\ENQ\EOT$\STX\NUL\ETX\DC2\EOT\146\t\NAK\SYN\n\
    \A\n\
    \\EOT\EOT$\STX\SOH\DC2\EOT\149\t\EOT\ETB\SUB3 Network address of the peer; eg `127.0.0.1:10011`\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\SOH\ENQ\DC2\EOT\149\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\SOH\SOH\DC2\EOT\149\t\v\DC2\n\
    \\r\n\
    \\ENQ\EOT$\STX\SOH\ETX\DC2\EOT\149\t\NAK\SYN\n\
    \6\n\
    \\EOT\EOT$\STX\STX\DC2\EOT\152\t\EOT\SUB\SUB( Bytes of data transmitted to this peer\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\STX\ENQ\DC2\EOT\152\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\STX\SOH\DC2\EOT\152\t\v\NAK\n\
    \\r\n\
    \\ENQ\EOT$\STX\STX\ETX\DC2\EOT\152\t\CAN\EM\n\
    \8\n\
    \\EOT\EOT$\STX\ETX\DC2\EOT\155\t\EOT\SUB\SUB* Bytes of data transmitted from this peer\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\ETX\ENQ\DC2\EOT\155\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\ETX\SOH\DC2\EOT\155\t\v\NAK\n\
    \\r\n\
    \\ENQ\EOT$\STX\ETX\ETX\DC2\EOT\155\t\CAN\EM\n\
    \*\n\
    \\EOT\EOT$\STX\EOT\DC2\EOT\158\t\EOT\ETB\SUB\FS Satoshis sent to this peer\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\EOT\ENQ\DC2\EOT\158\t\EOT\t\n\
    \\r\n\
    \\ENQ\EOT$\STX\EOT\SOH\DC2\EOT\158\t\n\
    \\DC2\n\
    \\r\n\
    \\ENQ\EOT$\STX\EOT\ETX\DC2\EOT\158\t\NAK\SYN\n\
    \0\n\
    \\EOT\EOT$\STX\ENQ\DC2\EOT\161\t\EOT\ETB\SUB\" Satoshis received from this peer\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\ENQ\ENQ\DC2\EOT\161\t\EOT\t\n\
    \\r\n\
    \\ENQ\EOT$\STX\ENQ\SOH\DC2\EOT\161\t\n\
    \\DC2\n\
    \\r\n\
    \\ENQ\EOT$\STX\ENQ\ETX\DC2\EOT\161\t\NAK\SYN\n\
    \N\n\
    \\EOT\EOT$\STX\ACK\DC2\EOT\164\t\EOT\NAK\SUB@ A channel is inbound if the counterparty initiated the channel\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\ACK\ENQ\DC2\EOT\164\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT$\STX\ACK\SOH\DC2\EOT\164\t\t\DLE\n\
    \\r\n\
    \\ENQ\EOT$\STX\ACK\ETX\DC2\EOT\164\t\DC3\DC4\n\
    \&\n\
    \\EOT\EOT$\STX\a\DC2\EOT\167\t\EOT\CAN\SUB\CAN Ping time to this peer\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\a\ENQ\DC2\EOT\167\t\EOT\t\n\
    \\r\n\
    \\ENQ\EOT$\STX\a\SOH\DC2\EOT\167\t\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT$\STX\a\ETX\DC2\EOT\167\t\SYN\ETB\n\
    \\SO\n\
    \\EOT\EOT$\EOT\NUL\DC2\ACK\169\t\EOT\189\t\ENQ\n\
    \\r\n\
    \\ENQ\EOT$\EOT\NUL\SOH\DC2\EOT\169\t\t\DC1\n\
    \P\n\
    \\ACK\EOT$\EOT\NUL\STX\NUL\DC2\EOT\173\t\b\EM\SUB@\n\
    \Denotes that we cannot determine the peer's current sync type.\n\
    \\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\NUL\SOH\DC2\EOT\173\t\b\DC4\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\NUL\STX\DC2\EOT\173\t\ETB\CAN\n\
    \Y\n\
    \\ACK\EOT$\EOT\NUL\STX\SOH\DC2\EOT\178\t\b\CAN\SUBI\n\
    \Denotes that we are actively receiving new graph updates from the peer.\n\
    \\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\SOH\SOH\DC2\EOT\178\t\b\DC3\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\SOH\STX\DC2\EOT\178\t\SYN\ETB\n\
    \T\n\
    \\ACK\EOT$\EOT\NUL\STX\STX\DC2\EOT\183\t\b\EM\SUBD\n\
    \Denotes that we are not receiving new graph updates from the peer.\n\
    \\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\STX\SOH\DC2\EOT\183\t\b\DC4\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\STX\STX\DC2\EOT\183\t\ETB\CAN\n\
    \G\n\
    \\ACK\EOT$\EOT\NUL\STX\ETX\DC2\EOT\188\t\b\CAN\SUB7\n\
    \Denotes that this peer is pinned into an active sync.\n\
    \\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\ETX\SOH\DC2\EOT\188\t\b\DC3\n\
    \\SI\n\
    \\a\EOT$\EOT\NUL\STX\ETX\STX\DC2\EOT\188\t\SYN\ETB\n\
    \L\n\
    \\EOT\EOT$\STX\b\DC2\EOT\192\t\EOT\FS\SUB> The type of sync we are currently performing with this peer.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\b\ACK\DC2\EOT\192\t\EOT\f\n\
    \\r\n\
    \\ENQ\EOT$\STX\b\SOH\DC2\EOT\192\t\r\SYN\n\
    \\r\n\
    \\ENQ\EOT$\STX\b\ETX\DC2\EOT\192\t\EM\ESC\n\
    \M\n\
    \\EOT\EOT$\STX\t\DC2\EOT\195\t\EOT'\SUB? Features advertised by the remote peer in their init message.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\t\ACK\DC2\EOT\195\t\EOT\CAN\n\
    \\r\n\
    \\ENQ\EOT$\STX\t\SOH\DC2\EOT\195\t\EM!\n\
    \\r\n\
    \\ENQ\EOT$\STX\t\ETX\DC2\EOT\195\t$&\n\
    \\217\STX\n\
    \\EOT\EOT$\STX\n\
    \\DC2\EOT\204\t\EOT*\SUB\202\STX\n\
    \The latest errors received from our peer with timestamps, limited to the 10\n\
    \most recent errors. These errors are tracked across peer connections, but\n\
    \are not persisted across lnd restarts. Note that these errors are only\n\
    \stored for peers that we have channels open with, to prevent peers from\n\
    \spamming us with errors at no cost.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\n\
    \\EOT\DC2\EOT\204\t\EOT\f\n\
    \\r\n\
    \\ENQ\EOT$\STX\n\
    \\ACK\DC2\EOT\204\t\r\GS\n\
    \\r\n\
    \\ENQ\EOT$\STX\n\
    \\SOH\DC2\EOT\204\t\RS$\n\
    \\r\n\
    \\ENQ\EOT$\STX\n\
    \\ETX\DC2\EOT\204\t')\n\
    \\140\STX\n\
    \\EOT\EOT$\STX\v\DC2\EOT\212\t\EOT\SUB\SUB\253\SOH\n\
    \The number of times we have recorded this peer going offline or coming\n\
    \online, recorded across restarts. Note that this value is decreased over\n\
    \time if the peer has not recently flapped, so that we can forgive peers\n\
    \with historically high flap counts.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\v\ENQ\DC2\EOT\212\t\EOT\t\n\
    \\r\n\
    \\ENQ\EOT$\STX\v\SOH\DC2\EOT\212\t\n\
    \\DC4\n\
    \\r\n\
    \\ENQ\EOT$\STX\v\ETX\DC2\EOT\212\t\ETB\EM\n\
    \\143\SOH\n\
    \\EOT\EOT$\STX\f\DC2\EOT\218\t\EOT\FS\SUB\128\SOH\n\
    \The timestamp of the last flap we observed for this peer. If this value is\n\
    \zero, we have not observed any flaps for this peer.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\f\ENQ\DC2\EOT\218\t\EOT\t\n\
    \\r\n\
    \\ENQ\EOT$\STX\f\SOH\DC2\EOT\218\t\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT$\STX\f\ETX\DC2\EOT\218\t\EM\ESC\n\
    \>\n\
    \\EOT\EOT$\STX\r\DC2\EOT\223\t\EOT!\SUB0\n\
    \The last ping payload the peer has sent to us.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT$\STX\r\ENQ\DC2\EOT\223\t\EOT\t\n\
    \\r\n\
    \\ENQ\EOT$\STX\r\SOH\DC2\EOT\223\t\n\
    \\ESC\n\
    \\r\n\
    \\ENQ\EOT$\STX\r\ETX\DC2\EOT\223\t\RS \n\
    \\f\n\
    \\STX\EOT%\DC2\ACK\226\t\NUL\232\t\SOH\n\
    \\v\n\
    \\ETX\EOT%\SOH\DC2\EOT\226\t\b\CAN\n\
    \F\n\
    \\EOT\EOT%\STX\NUL\DC2\EOT\228\t\EOT\EM\SUB8 The unix timestamp in seconds when the error occurred.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT%\STX\NUL\ENQ\DC2\EOT\228\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT%\STX\NUL\SOH\DC2\EOT\228\t\v\DC4\n\
    \\r\n\
    \\ENQ\EOT%\STX\NUL\ETX\DC2\EOT\228\t\ETB\CAN\n\
    \H\n\
    \\EOT\EOT%\STX\SOH\DC2\EOT\231\t\EOT\NAK\SUB: The string representation of the error sent by our peer.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT%\STX\SOH\ENQ\DC2\EOT\231\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT%\STX\SOH\SOH\DC2\EOT\231\t\v\DLE\n\
    \\r\n\
    \\ENQ\EOT%\STX\SOH\ETX\DC2\EOT\231\t\DC3\DC4\n\
    \\f\n\
    \\STX\EOT&\DC2\ACK\234\t\NUL\241\t\SOH\n\
    \\v\n\
    \\ETX\EOT&\SOH\DC2\EOT\234\t\b\CAN\n\
    \\173\SOH\n\
    \\EOT\EOT&\STX\NUL\DC2\EOT\240\t\EOT\SUB\SUB\158\SOH\n\
    \If true, only the last error that our peer sent us will be returned with\n\
    \the peer's information, rather than the full set of historic errors we have\n\
    \stored.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT&\STX\NUL\ENQ\DC2\EOT\240\t\EOT\b\n\
    \\r\n\
    \\ENQ\EOT&\STX\NUL\SOH\DC2\EOT\240\t\t\NAK\n\
    \\r\n\
    \\ENQ\EOT&\STX\NUL\ETX\DC2\EOT\240\t\CAN\EM\n\
    \\f\n\
    \\STX\EOT'\DC2\ACK\242\t\NUL\245\t\SOH\n\
    \\v\n\
    \\ETX\EOT'\SOH\DC2\EOT\242\t\b\EM\n\
    \5\n\
    \\EOT\EOT'\STX\NUL\DC2\EOT\244\t\EOT\FS\SUB' The list of currently connected peers\n\
    \\n\
    \\r\n\
    \\ENQ\EOT'\STX\NUL\EOT\DC2\EOT\244\t\EOT\f\n\
    \\r\n\
    \\ENQ\EOT'\STX\NUL\ACK\DC2\EOT\244\t\r\DC1\n\
    \\r\n\
    \\ENQ\EOT'\STX\NUL\SOH\DC2\EOT\244\t\DC2\ETB\n\
    \\r\n\
    \\ENQ\EOT'\STX\NUL\ETX\DC2\EOT\244\t\SUB\ESC\n\
    \\f\n\
    \\STX\EOT(\DC2\ACK\247\t\NUL\248\t\SOH\n\
    \\v\n\
    \\ETX\EOT(\SOH\DC2\EOT\247\t\b\GS\n\
    \\f\n\
    \\STX\EOT)\DC2\ACK\250\t\NUL\132\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT)\SOH\DC2\EOT\250\t\b\DC1\n\
    \0\n\
    \\EOT\EOT)\STX\NUL\DC2\EOT\252\t\EOT\ETB\SUB\" The identity pubkey of the peer.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT)\STX\NUL\ENQ\DC2\EOT\252\t\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT)\STX\NUL\SOH\DC2\EOT\252\t\v\DC2\n\
    \\r\n\
    \\ENQ\EOT)\STX\NUL\ETX\DC2\EOT\252\t\NAK\SYN\n\
    \\SO\n\
    \\EOT\EOT)\EOT\NUL\DC2\ACK\254\t\EOT\129\n\
    \\ENQ\n\
    \\r\n\
    \\ENQ\EOT)\EOT\NUL\SOH\DC2\EOT\254\t\t\DC2\n\
    \\SO\n\
    \\ACK\EOT)\EOT\NUL\STX\NUL\DC2\EOT\255\t\b\CAN\n\
    \\SI\n\
    \\a\EOT)\EOT\NUL\STX\NUL\SOH\DC2\EOT\255\t\b\DC3\n\
    \\SI\n\
    \\a\EOT)\EOT\NUL\STX\NUL\STX\DC2\EOT\255\t\SYN\ETB\n\
    \\SO\n\
    \\ACK\EOT)\EOT\NUL\STX\SOH\DC2\EOT\128\n\
    \\b\EM\n\
    \\SI\n\
    \\a\EOT)\EOT\NUL\STX\SOH\SOH\DC2\EOT\128\n\
    \\b\DC4\n\
    \\SI\n\
    \\a\EOT)\EOT\NUL\STX\SOH\STX\DC2\EOT\128\n\
    \\ETB\CAN\n\
    \\f\n\
    \\EOT\EOT)\STX\SOH\DC2\EOT\131\n\
    \\EOT\ETB\n\
    \\r\n\
    \\ENQ\EOT)\STX\SOH\ACK\DC2\EOT\131\n\
    \\EOT\r\n\
    \\r\n\
    \\ENQ\EOT)\STX\SOH\SOH\DC2\EOT\131\n\
    \\SO\DC2\n\
    \\r\n\
    \\ENQ\EOT)\STX\SOH\ETX\DC2\EOT\131\n\
    \\NAK\SYN\n\
    \\f\n\
    \\STX\EOT*\DC2\ACK\134\n\
    \\NUL\135\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT*\SOH\DC2\EOT\134\n\
    \\b\SYN\n\
    \\f\n\
    \\STX\EOT+\DC2\ACK\136\n\
    \\NUL\198\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT+\SOH\DC2\EOT\136\n\
    \\b\ETB\n\
    \I\n\
    \\EOT\EOT+\STX\NUL\DC2\EOT\138\n\
    \\EOT\CAN\SUB; The version of the LND software that the node is running.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\NUL\ENQ\DC2\EOT\138\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\NUL\SOH\DC2\EOT\138\n\
    \\v\DC2\n\
    \\r\n\
    \\ENQ\EOT+\STX\NUL\ETX\DC2\EOT\138\n\
    \\NAK\ETB\n\
    \F\n\
    \\EOT\EOT+\STX\SOH\DC2\EOT\141\n\
    \\EOT\FS\SUB8 The SHA1 commit hash that the daemon is compiled with.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\SOH\ENQ\DC2\EOT\141\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\SOH\SOH\DC2\EOT\141\n\
    \\v\SYN\n\
    \\r\n\
    \\ENQ\EOT+\STX\SOH\ETX\DC2\EOT\141\n\
    \\EM\ESC\n\
    \8\n\
    \\EOT\EOT+\STX\STX\DC2\EOT\144\n\
    \\EOT\US\SUB* The identity pubkey of the current node.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\STX\ENQ\DC2\EOT\144\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\STX\SOH\DC2\EOT\144\n\
    \\v\SUB\n\
    \\r\n\
    \\ENQ\EOT+\STX\STX\ETX\DC2\EOT\144\n\
    \\GS\RS\n\
    \H\n\
    \\EOT\EOT+\STX\ETX\DC2\EOT\147\n\
    \\EOT\NAK\SUB: If applicable, the alias of the current node, e.g. \"bob\"\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\ETX\ENQ\DC2\EOT\147\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\ETX\SOH\DC2\EOT\147\n\
    \\v\DLE\n\
    \\r\n\
    \\ENQ\EOT+\STX\ETX\ETX\DC2\EOT\147\n\
    \\DC3\DC4\n\
    \@\n\
    \\EOT\EOT+\STX\EOT\DC2\EOT\150\n\
    \\EOT\SYN\SUB2 The color of the current node in hex code format\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\EOT\ENQ\DC2\EOT\150\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\EOT\SOH\DC2\EOT\150\n\
    \\v\DLE\n\
    \\r\n\
    \\ENQ\EOT+\STX\EOT\ETX\DC2\EOT\150\n\
    \\DC3\NAK\n\
    \*\n\
    \\EOT\EOT+\STX\ENQ\DC2\EOT\153\n\
    \\EOT$\SUB\FS Number of pending channels\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\ENQ\ENQ\DC2\EOT\153\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\ENQ\SOH\DC2\EOT\153\n\
    \\v\US\n\
    \\r\n\
    \\ENQ\EOT+\STX\ENQ\ETX\DC2\EOT\153\n\
    \\"#\n\
    \)\n\
    \\EOT\EOT+\STX\ACK\DC2\EOT\156\n\
    \\EOT#\SUB\ESC Number of active channels\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\ACK\ENQ\DC2\EOT\156\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\ACK\SOH\DC2\EOT\156\n\
    \\v\RS\n\
    \\r\n\
    \\ENQ\EOT+\STX\ACK\ETX\DC2\EOT\156\n\
    \!\"\n\
    \+\n\
    \\EOT\EOT+\STX\a\DC2\EOT\159\n\
    \\EOT&\SUB\GS Number of inactive channels\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\a\ENQ\DC2\EOT\159\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\a\SOH\DC2\EOT\159\n\
    \\v \n\
    \\r\n\
    \\ENQ\EOT+\STX\a\ETX\DC2\EOT\159\n\
    \#%\n\
    \\US\n\
    \\EOT\EOT+\STX\b\DC2\EOT\162\n\
    \\EOT\EM\SUB\DC1 Number of peers\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\b\ENQ\DC2\EOT\162\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\b\SOH\DC2\EOT\162\n\
    \\v\DC4\n\
    \\r\n\
    \\ENQ\EOT+\STX\b\ETX\DC2\EOT\162\n\
    \\ETB\CAN\n\
    \G\n\
    \\EOT\EOT+\STX\t\DC2\EOT\165\n\
    \\EOT\FS\SUB9 The node's current view of the height of the best block\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\t\ENQ\DC2\EOT\165\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\t\SOH\DC2\EOT\165\n\
    \\v\ETB\n\
    \\r\n\
    \\ENQ\EOT+\STX\t\ETX\DC2\EOT\165\n\
    \\SUB\ESC\n\
    \E\n\
    \\EOT\EOT+\STX\n\
    \\DC2\EOT\168\n\
    \\EOT\SUB\SUB7 The node's current view of the hash of the best block\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\n\
    \\ENQ\DC2\EOT\168\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\n\
    \\SOH\DC2\EOT\168\n\
    \\v\NAK\n\
    \\r\n\
    \\ENQ\EOT+\STX\n\
    \\ETX\DC2\EOT\168\n\
    \\CAN\EM\n\
    \?\n\
    \\EOT\EOT+\STX\v\DC2\EOT\171\n\
    \\EOT%\SUB1 Timestamp of the block best known to the wallet\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\v\ENQ\DC2\EOT\171\n\
    \\EOT\t\n\
    \\r\n\
    \\ENQ\EOT+\STX\v\SOH\DC2\EOT\171\n\
    \\n\
    \\US\n\
    \\r\n\
    \\ENQ\EOT+\STX\v\ETX\DC2\EOT\171\n\
    \\"$\n\
    \E\n\
    \\EOT\EOT+\STX\f\DC2\EOT\174\n\
    \\EOT\GS\SUB7 Whether the wallet's view is synced to the main chain\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\f\ENQ\DC2\EOT\174\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT+\STX\f\SOH\DC2\EOT\174\n\
    \\t\CAN\n\
    \\r\n\
    \\ENQ\EOT+\STX\f\ETX\DC2\EOT\174\n\
    \\ESC\FS\n\
    \S\n\
    \\EOT\EOT+\STX\r\DC2\EOT\177\n\
    \\EOT\RS\SUBE Whether we consider ourselves synced with the public channel graph.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\r\ENQ\DC2\EOT\177\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT+\STX\r\SOH\DC2\EOT\177\n\
    \\t\CAN\n\
    \\r\n\
    \\ENQ\EOT+\STX\r\ETX\DC2\EOT\177\n\
    \\ESC\GS\n\
    \\135\SOH\n\
    \\EOT\EOT+\STX\SO\DC2\EOT\183\n\
    \\EOT*\SUBy\n\
    \Whether the current node is connected to testnet. This field is\n\
    \deprecated and the network field should be used instead\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\SO\ENQ\DC2\EOT\183\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT+\STX\SO\SOH\DC2\EOT\183\n\
    \\t\DLE\n\
    \\r\n\
    \\ENQ\EOT+\STX\SO\ETX\DC2\EOT\183\n\
    \\DC3\NAK\n\
    \\r\n\
    \\ENQ\EOT+\STX\SO\b\DC2\EOT\183\n\
    \\SYN)\n\
    \\SO\n\
    \\ACK\EOT+\STX\SO\b\ETX\DC2\EOT\183\n\
    \\ETB(\n\
    \\v\n\
    \\ETX\EOT+\t\DC2\EOT\185\n\
    \\EOT\DLE\n\
    \\f\n\
    \\EOT\EOT+\t\NUL\DC2\EOT\185\n\
    \\r\SI\n\
    \\r\n\
    \\ENQ\EOT+\t\NUL\SOH\DC2\EOT\185\n\
    \\r\SI\n\
    \\r\n\
    \\ENQ\EOT+\t\NUL\STX\DC2\EOT\185\n\
    \\r\SI\n\
    \@\n\
    \\EOT\EOT+\STX\SI\DC2\EOT\188\n\
    \\EOT\US\SUB2 A list of active chains the node is connected to\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\SI\EOT\DC2\EOT\188\n\
    \\EOT\f\n\
    \\r\n\
    \\ENQ\EOT+\STX\SI\ACK\DC2\EOT\188\n\
    \\r\DC2\n\
    \\r\n\
    \\ENQ\EOT+\STX\SI\SOH\DC2\EOT\188\n\
    \\DC3\EM\n\
    \\r\n\
    \\ENQ\EOT+\STX\SI\ETX\DC2\EOT\188\n\
    \\FS\RS\n\
    \-\n\
    \\EOT\EOT+\STX\DLE\DC2\EOT\191\n\
    \\EOT\RS\SUB\US The URIs of the current node.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\DLE\EOT\DC2\EOT\191\n\
    \\EOT\f\n\
    \\r\n\
    \\ENQ\EOT+\STX\DLE\ENQ\DC2\EOT\191\n\
    \\r\DC3\n\
    \\r\n\
    \\ENQ\EOT+\STX\DLE\SOH\DC2\EOT\191\n\
    \\DC4\CAN\n\
    \\r\n\
    \\ENQ\EOT+\STX\DLE\ETX\DC2\EOT\191\n\
    \\ESC\GS\n\
    \k\n\
    \\EOT\EOT+\STX\DC1\DC2\EOT\197\n\
    \\EOT'\SUB]\n\
    \Features that our node has advertised in our init message, node\n\
    \announcements and invoices.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT+\STX\DC1\ACK\DC2\EOT\197\n\
    \\EOT\CAN\n\
    \\r\n\
    \\ENQ\EOT+\STX\DC1\SOH\DC2\EOT\197\n\
    \\EM!\n\
    \\r\n\
    \\ENQ\EOT+\STX\DC1\ETX\DC2\EOT\197\n\
    \$&\n\
    \\f\n\
    \\STX\EOT,\DC2\ACK\200\n\
    \\NUL\201\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT,\SOH\DC2\EOT\200\n\
    \\b\RS\n\
    \\f\n\
    \\STX\EOT-\DC2\ACK\202\n\
    \\NUL\211\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT-\SOH\DC2\EOT\202\n\
    \\b\US\n\
    \6\n\
    \\EOT\EOT-\STX\NUL\DC2\EOT\204\n\
    \\EOT\ESC\SUB( Whether the wallet is in recovery mode\n\
    \\n\
    \\r\n\
    \\ENQ\EOT-\STX\NUL\ENQ\DC2\EOT\204\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT-\STX\NUL\SOH\DC2\EOT\204\n\
    \\t\SYN\n\
    \\r\n\
    \\ENQ\EOT-\STX\NUL\ETX\DC2\EOT\204\n\
    \\EM\SUB\n\
    \@\n\
    \\EOT\EOT-\STX\SOH\DC2\EOT\207\n\
    \\EOT\US\SUB2 Whether the wallet recovery progress is finished\n\
    \\n\
    \\r\n\
    \\ENQ\EOT-\STX\SOH\ENQ\DC2\EOT\207\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT-\STX\SOH\SOH\DC2\EOT\207\n\
    \\t\SUB\n\
    \\r\n\
    \\ENQ\EOT-\STX\SOH\ETX\DC2\EOT\207\n\
    \\GS\RS\n\
    \;\n\
    \\EOT\EOT-\STX\STX\DC2\EOT\210\n\
    \\EOT\CAN\SUB- The recovery progress, ranging from 0 to 1.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT-\STX\STX\ENQ\DC2\EOT\210\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT-\STX\STX\SOH\DC2\EOT\210\n\
    \\v\DC3\n\
    \\r\n\
    \\ENQ\EOT-\STX\STX\ETX\DC2\EOT\210\n\
    \\SYN\ETB\n\
    \\f\n\
    \\STX\EOT.\DC2\ACK\213\n\
    \\NUL\219\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT.\SOH\DC2\EOT\213\n\
    \\b\r\n\
    \D\n\
    \\EOT\EOT.\STX\NUL\DC2\EOT\215\n\
    \\EOT\NAK\SUB6 The blockchain the node is on (eg bitcoin, litecoin)\n\
    \\n\
    \\r\n\
    \\ENQ\EOT.\STX\NUL\ENQ\DC2\EOT\215\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT.\STX\NUL\SOH\DC2\EOT\215\n\
    \\v\DLE\n\
    \\r\n\
    \\ENQ\EOT.\STX\NUL\ETX\DC2\EOT\215\n\
    \\DC3\DC4\n\
    \I\n\
    \\EOT\EOT.\STX\SOH\DC2\EOT\218\n\
    \\EOT\ETB\SUB; The network the node is on (eg regtest, testnet, mainnet)\n\
    \\n\
    \\r\n\
    \\ENQ\EOT.\STX\SOH\ENQ\DC2\EOT\218\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT.\STX\SOH\SOH\DC2\EOT\218\n\
    \\v\DC2\n\
    \\r\n\
    \\ENQ\EOT.\STX\SOH\ETX\DC2\EOT\218\n\
    \\NAK\SYN\n\
    \\f\n\
    \\STX\EOT/\DC2\ACK\221\n\
    \\NUL\226\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT/\SOH\DC2\EOT\221\n\
    \\b\SUB\n\
    \\f\n\
    \\EOT\EOT/\STX\NUL\DC2\EOT\222\n\
    \\EOT\CAN\n\
    \\r\n\
    \\ENQ\EOT/\STX\NUL\ENQ\DC2\EOT\222\n\
    \\EOT\t\n\
    \\r\n\
    \\ENQ\EOT/\STX\NUL\SOH\DC2\EOT\222\n\
    \\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT/\STX\NUL\ETX\DC2\EOT\222\n\
    \\SYN\ETB\n\
    \\f\n\
    \\EOT\EOT/\STX\SOH\DC2\EOT\223\n\
    \\EOT\ESC\n\
    \\r\n\
    \\ENQ\EOT/\STX\SOH\ENQ\DC2\EOT\223\n\
    \\EOT\t\n\
    \\r\n\
    \\ENQ\EOT/\STX\SOH\SOH\DC2\EOT\223\n\
    \\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT/\STX\SOH\ETX\DC2\EOT\223\n\
    \\EM\SUB\n\
    \\f\n\
    \\EOT\EOT/\STX\STX\DC2\EOT\225\n\
    \\EOT\RS\n\
    \\r\n\
    \\ENQ\EOT/\STX\STX\ENQ\DC2\EOT\225\n\
    \\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT/\STX\STX\SOH\DC2\EOT\225\n\
    \\v\EM\n\
    \\r\n\
    \\ENQ\EOT/\STX\STX\ETX\DC2\EOT\225\n\
    \\FS\GS\n\
    \\f\n\
    \\STX\EOT0\DC2\ACK\228\n\
    \\NUL\230\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT0\SOH\DC2\EOT\228\n\
    \\b\EM\n\
    \\f\n\
    \\EOT\EOT0\STX\NUL\DC2\EOT\229\n\
    \\EOT#\n\
    \\r\n\
    \\ENQ\EOT0\STX\NUL\ACK\DC2\EOT\229\n\
    \\EOT\DLE\n\
    \\r\n\
    \\ENQ\EOT0\STX\NUL\SOH\DC2\EOT\229\n\
    \\DC1\RS\n\
    \\r\n\
    \\ENQ\EOT0\STX\NUL\ETX\DC2\EOT\229\n\
    \!\"\n\
    \\f\n\
    \\STX\EOT1\DC2\ACK\232\n\
    \\NUL\236\n\
    \\SOH\n\
    \\v\n\
    \\ETX\EOT1\SOH\DC2\EOT\232\n\
    \\b\SUB\n\
    \\f\n\
    \\EOT\EOT1\STX\NUL\DC2\EOT\233\n\
    \\EOT\ESC\n\
    \\r\n\
    \\ENQ\EOT1\STX\NUL\ENQ\DC2\EOT\233\n\
    \\EOT\t\n\
    \\r\n\
    \\ENQ\EOT1\STX\NUL\SOH\DC2\EOT\233\n\
    \\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT1\STX\NUL\ETX\DC2\EOT\233\n\
    \\EM\SUB\n\
    \\f\n\
    \\EOT\EOT1\STX\SOH\DC2\EOT\235\n\
    \\EOT\NAK\n\
    \\r\n\
    \\ENQ\EOT1\STX\SOH\ENQ\DC2\EOT\235\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT1\STX\SOH\SOH\DC2\EOT\235\n\
    \\t\DLE\n\
    \\r\n\
    \\ENQ\EOT1\STX\SOH\ETX\DC2\EOT\235\n\
    \\DC3\DC4\n\
    \\f\n\
    \\STX\EOT2\DC2\ACK\238\n\
    \\NUL\142\v\SOH\n\
    \\v\n\
    \\ETX\EOT2\SOH\DC2\EOT\238\n\
    \\b\ESC\n\
    \\179\SOH\n\
    \\EOT\EOT2\STX\NUL\DC2\EOT\244\n\
    \\EOT#\SUB\164\SOH\n\
    \The outpoint (txid:index) of the funding transaction. With this value, Bob\n\
    \will be able to generate a signature for Alice's version of the commitment\n\
    \transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\NUL\ACK\DC2\EOT\244\n\
    \\EOT\DLE\n\
    \\r\n\
    \\ENQ\EOT2\STX\NUL\SOH\DC2\EOT\244\n\
    \\DC1\RS\n\
    \\r\n\
    \\ENQ\EOT2\STX\NUL\ETX\DC2\EOT\244\n\
    \!\"\n\
    \\144\SOH\n\
    \\EOT\EOT2\STX\SOH\DC2\EOT\248\n\
    \\EOT\DC3\SUB\129\SOH If true, then the channel will be closed forcibly. This means the\n\
    \ current commitment transaction will be signed and broadcast.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\SOH\ENQ\DC2\EOT\248\n\
    \\EOT\b\n\
    \\r\n\
    \\ENQ\EOT2\STX\SOH\SOH\DC2\EOT\248\n\
    \\t\SO\n\
    \\r\n\
    \\ENQ\EOT2\STX\SOH\ETX\DC2\EOT\248\n\
    \\DC1\DC2\n\
    \a\n\
    \\EOT\EOT2\STX\STX\DC2\EOT\252\n\
    \\EOT\SUB\SUBS The target number of blocks that the closure transaction should be\n\
    \ confirmed by.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\STX\ENQ\DC2\EOT\252\n\
    \\EOT\t\n\
    \\r\n\
    \\ENQ\EOT2\STX\STX\SOH\DC2\EOT\252\n\
    \\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT2\STX\STX\ETX\DC2\EOT\252\n\
    \\CAN\EM\n\
    \\143\SOH\n\
    \\EOT\EOT2\STX\ETX\DC2\EOT\129\v\EOT/\SUB\128\SOH Deprecated, use sat_per_vbyte.\n\
    \ A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ closure transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\ETX\ENQ\DC2\EOT\129\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT2\STX\ETX\SOH\DC2\EOT\129\v\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT2\STX\ETX\ETX\DC2\EOT\129\v\EM\SUB\n\
    \\r\n\
    \\ENQ\EOT2\STX\ETX\b\DC2\EOT\129\v\ESC.\n\
    \\SO\n\
    \\ACK\EOT2\STX\ETX\b\ETX\DC2\EOT\129\v\FS-\n\
    \\140\STX\n\
    \\EOT\EOT2\STX\EOT\DC2\EOT\137\v\EOT \SUB\253\SOH\n\
    \An optional address to send funds to in the case of a cooperative close.\n\
    \If the channel was opened with an upfront shutdown script and this field\n\
    \is set, the request to close will fail because the channel must pay out\n\
    \to the upfront shutdown addresss.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\EOT\ENQ\DC2\EOT\137\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\EOT\SOH\DC2\EOT\137\v\v\ESC\n\
    \\r\n\
    \\ENQ\EOT2\STX\EOT\ETX\DC2\EOT\137\v\RS\US\n\
    \n\n\
    \\EOT\EOT2\STX\ENQ\DC2\EOT\141\v\EOT\GS\SUB` A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ closure transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\ENQ\ENQ\DC2\EOT\141\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT2\STX\ENQ\SOH\DC2\EOT\141\v\v\CAN\n\
    \\r\n\
    \\ENQ\EOT2\STX\ENQ\ETX\DC2\EOT\141\v\ESC\FS\n\
    \\f\n\
    \\STX\EOT3\DC2\ACK\144\v\NUL\149\v\SOH\n\
    \\v\n\
    \\ETX\EOT3\SOH\DC2\EOT\144\v\b\EM\n\
    \\SO\n\
    \\EOT\EOT3\b\NUL\DC2\ACK\145\v\EOT\148\v\ENQ\n\
    \\r\n\
    \\ENQ\EOT3\b\NUL\SOH\DC2\EOT\145\v\n\
    \\DLE\n\
    \\f\n\
    \\EOT\EOT3\STX\NUL\DC2\EOT\146\v\b(\n\
    \\r\n\
    \\ENQ\EOT3\STX\NUL\ACK\DC2\EOT\146\v\b\NAK\n\
    \\r\n\
    \\ENQ\EOT3\STX\NUL\SOH\DC2\EOT\146\v\SYN#\n\
    \\r\n\
    \\ENQ\EOT3\STX\NUL\ETX\DC2\EOT\146\v&'\n\
    \\f\n\
    \\EOT\EOT3\STX\SOH\DC2\EOT\147\v\b*\n\
    \\r\n\
    \\ENQ\EOT3\STX\SOH\ACK\DC2\EOT\147\v\b\SUB\n\
    \\r\n\
    \\ENQ\EOT3\STX\SOH\SOH\DC2\EOT\147\v\ESC%\n\
    \\r\n\
    \\ENQ\EOT3\STX\SOH\ETX\DC2\EOT\147\v()\n\
    \\f\n\
    \\STX\EOT4\DC2\ACK\151\v\NUL\171\v\SOH\n\
    \\v\n\
    \\ETX\EOT4\SOH\DC2\EOT\151\v\b\ESC\n\
    \\138\SOH\n\
    \\EOT\EOT4\STX\NUL\DC2\EOT\156\v\EOT\US\SUB|\n\
    \The P2WSH address of the channel funding multisig address that the below\n\
    \specified amount in satoshis needs to be sent to.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT4\STX\NUL\ENQ\DC2\EOT\156\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT4\STX\NUL\SOH\DC2\EOT\156\v\v\SUB\n\
    \\r\n\
    \\ENQ\EOT4\STX\NUL\ETX\DC2\EOT\156\v\GS\RS\n\
    \t\n\
    \\EOT\EOT4\STX\SOH\DC2\EOT\162\v\EOT\GS\SUBf\n\
    \The exact amount in satoshis that needs to be sent to the above address to\n\
    \fund the pending channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT4\STX\SOH\ENQ\DC2\EOT\162\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT4\STX\SOH\SOH\DC2\EOT\162\v\n\
    \\CAN\n\
    \\r\n\
    \\ENQ\EOT4\STX\SOH\ETX\DC2\EOT\162\v\ESC\FS\n\
    \\252\SOH\n\
    \\EOT\EOT4\STX\STX\DC2\EOT\170\v\EOT\DC3\SUB\237\SOH\n\
    \A raw PSBT that contains the pending channel output. If a base PSBT was\n\
    \provided in the PsbtShim, this is the base PSBT with one additional output.\n\
    \If no base PSBT was specified, this is an otherwise empty PSBT with exactly\n\
    \one output.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT4\STX\STX\ENQ\DC2\EOT\170\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT4\STX\STX\SOH\DC2\EOT\170\v\n\
    \\SO\n\
    \\r\n\
    \\ENQ\EOT4\STX\STX\ETX\DC2\EOT\170\v\DC1\DC2\n\
    \\f\n\
    \\STX\EOT5\DC2\ACK\173\v\NUL\195\v\SOH\n\
    \\v\n\
    \\ETX\EOT5\SOH\DC2\EOT\173\v\b\US\n\
    \-\n\
    \\EOT\EOT5\STX\NUL\DC2\EOT\175\v\EOT+\SUB\US The list of channels to open.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\NUL\EOT\DC2\EOT\175\v\EOT\f\n\
    \\r\n\
    \\ENQ\EOT5\STX\NUL\ACK\DC2\EOT\175\v\r\GS\n\
    \\r\n\
    \\ENQ\EOT5\STX\NUL\SOH\DC2\EOT\175\v\RS&\n\
    \\r\n\
    \\ENQ\EOT5\STX\NUL\ETX\DC2\EOT\175\v)*\n\
    \a\n\
    \\EOT\EOT5\STX\SOH\DC2\EOT\179\v\EOT\SUB\SUBS The target number of blocks that the funding transaction should be\n\
    \ confirmed by.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\SOH\ENQ\DC2\EOT\179\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT5\STX\SOH\SOH\DC2\EOT\179\v\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT5\STX\SOH\ETX\DC2\EOT\179\v\CAN\EM\n\
    \n\n\
    \\EOT\EOT5\STX\STX\DC2\EOT\183\v\EOT\FS\SUB` A manual fee rate set in sat/vByte that should be used when crafting the\n\
    \ funding transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\STX\ENQ\DC2\EOT\183\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT5\STX\STX\SOH\DC2\EOT\183\v\n\
    \\ETB\n\
    \\r\n\
    \\ENQ\EOT5\STX\STX\ETX\DC2\EOT\183\v\SUB\ESC\n\
    \|\n\
    \\EOT\EOT5\STX\ETX\DC2\EOT\187\v\EOT\CAN\SUBn The minimum number of confirmations each one of your outputs used for\n\
    \ the funding transaction must satisfy.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\ETX\ENQ\DC2\EOT\187\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT5\STX\ETX\SOH\DC2\EOT\187\v\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT5\STX\ETX\ETX\DC2\EOT\187\v\SYN\ETB\n\
    \b\n\
    \\EOT\EOT5\STX\EOT\DC2\EOT\191\v\EOT\US\SUBT Whether unconfirmed outputs should be used as inputs for the funding\n\
    \ transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\EOT\ENQ\DC2\EOT\191\v\EOT\b\n\
    \\r\n\
    \\ENQ\EOT5\STX\EOT\SOH\DC2\EOT\191\v\t\SUB\n\
    \\r\n\
    \\ENQ\EOT5\STX\EOT\ETX\DC2\EOT\191\v\GS\RS\n\
    \W\n\
    \\EOT\EOT5\STX\ENQ\DC2\EOT\194\v\EOT\NAK\SUBI An optional label for the batch transaction, limited to 500 characters.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\ENQ\ENQ\DC2\EOT\194\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT5\STX\ENQ\SOH\DC2\EOT\194\v\v\DLE\n\
    \\r\n\
    \\ENQ\EOT5\STX\ENQ\ETX\DC2\EOT\194\v\DC3\DC4\n\
    \\f\n\
    \\STX\EOT6\DC2\ACK\197\v\NUL\245\v\SOH\n\
    \\v\n\
    \\ETX\EOT6\SOH\DC2\EOT\197\v\b\CAN\n\
    \v\n\
    \\EOT\EOT6\STX\NUL\DC2\EOT\200\v\EOT\SUB\SUBh The pubkey of the node to open a channel with. When using REST, this\n\
    \ field must be encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\NUL\ENQ\DC2\EOT\200\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT6\STX\NUL\SOH\DC2\EOT\200\v\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT6\STX\NUL\ETX\DC2\EOT\200\v\CAN\EM\n\
    \O\n\
    \\EOT\EOT6\STX\SOH\DC2\EOT\203\v\EOT#\SUBA The number of satoshis the wallet should commit to the channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\SOH\ENQ\DC2\EOT\203\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT6\STX\SOH\SOH\DC2\EOT\203\v\n\
    \\RS\n\
    \\r\n\
    \\ENQ\EOT6\STX\SOH\ETX\DC2\EOT\203\v!\"\n\
    \k\n\
    \\EOT\EOT6\STX\STX\DC2\EOT\207\v\EOT\ETB\SUB] The number of satoshis to push to the remote side as part of the initial\n\
    \ commitment state.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\STX\ENQ\DC2\EOT\207\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT6\STX\STX\SOH\DC2\EOT\207\v\n\
    \\DC2\n\
    \\r\n\
    \\ENQ\EOT6\STX\STX\ETX\DC2\EOT\207\v\NAK\SYN\n\
    \^\n\
    \\EOT\EOT6\STX\ETX\DC2\EOT\211\v\EOT\NAK\SUBP Whether this channel should be private, not announced to the greater\n\
    \ network.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\ETX\ENQ\DC2\EOT\211\v\EOT\b\n\
    \\r\n\
    \\ENQ\EOT6\STX\ETX\SOH\DC2\EOT\211\v\t\DLE\n\
    \\r\n\
    \\ENQ\EOT6\STX\ETX\ETX\DC2\EOT\211\v\DC3\DC4\n\
    \e\n\
    \\EOT\EOT6\STX\EOT\DC2\EOT\215\v\EOT\FS\SUBW The minimum value in millisatoshi we will require for incoming HTLCs on\n\
    \ the channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\EOT\ENQ\DC2\EOT\215\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT6\STX\EOT\SOH\DC2\EOT\215\v\n\
    \\ETB\n\
    \\r\n\
    \\ENQ\EOT6\STX\EOT\ETX\DC2\EOT\215\v\SUB\ESC\n\
    \\153\SOH\n\
    \\EOT\EOT6\STX\ENQ\DC2\EOT\219\v\EOT \SUB\138\SOH The delay we require on the remote's commitment transaction. If this is\n\
    \ not set, it will be scaled automatically with the channel size.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\ENQ\ENQ\DC2\EOT\219\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\ENQ\SOH\DC2\EOT\219\v\v\ESC\n\
    \\r\n\
    \\ENQ\EOT6\STX\ENQ\ETX\DC2\EOT\219\v\RS\US\n\
    \\197\ETX\n\
    \\EOT\EOT6\STX\ACK\DC2\EOT\231\v\EOT\GS\SUB\182\ETX\n\
    \Close address is an optional address which specifies the address to which\n\
    \funds should be paid out to upon cooperative close. This field may only be\n\
    \set if the peer supports the option upfront feature bit (call listpeers\n\
    \to check). The remote peer will only accept cooperative closes to this\n\
    \address if it is set.\n\
    \\n\
    \Note: If this value is set on channel creation, you will *not* be able to\n\
    \cooperatively close out to a different address.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\ACK\ENQ\DC2\EOT\231\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\ACK\SOH\DC2\EOT\231\v\v\CAN\n\
    \\r\n\
    \\ENQ\EOT6\STX\ACK\ETX\DC2\EOT\231\v\ESC\FS\n\
    \\172\SOH\n\
    \\EOT\EOT6\STX\a\DC2\EOT\238\v\EOT\RS\SUB\157\SOH\n\
    \An optional, unique identifier of 32 random bytes that will be used as the\n\
    \pending channel ID to identify the channel while it is in the pre-pending\n\
    \state.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\a\ENQ\DC2\EOT\238\v\EOT\t\n\
    \\r\n\
    \\ENQ\EOT6\STX\a\SOH\DC2\EOT\238\v\n\
    \\EM\n\
    \\r\n\
    \\ENQ\EOT6\STX\a\ETX\DC2\EOT\238\v\FS\GS\n\
    \\145\SOH\n\
    \\EOT\EOT6\STX\b\DC2\EOT\244\v\EOT'\SUB\130\SOH\n\
    \The explicit commitment type to use. Note this field will only be used if\n\
    \the remote peer supports explicit channel negotiation.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT6\STX\b\ACK\DC2\EOT\244\v\EOT\DC2\n\
    \\r\n\
    \\ENQ\EOT6\STX\b\SOH\DC2\EOT\244\v\DC3\"\n\
    \\r\n\
    \\ENQ\EOT6\STX\b\ETX\DC2\EOT\244\v%&\n\
    \\f\n\
    \\STX\EOT7\DC2\ACK\247\v\NUL\249\v\SOH\n\
    \\v\n\
    \\ETX\EOT7\SOH\DC2\EOT\247\v\b \n\
    \\f\n\
    \\EOT\EOT7\STX\NUL\DC2\EOT\248\v\EOT0\n\
    \\r\n\
    \\ENQ\EOT7\STX\NUL\EOT\DC2\EOT\248\v\EOT\f\n\
    \\r\n\
    \\ENQ\EOT7\STX\NUL\ACK\DC2\EOT\248\v\r\SUB\n\
    \\r\n\
    \\ENQ\EOT7\STX\NUL\SOH\DC2\EOT\248\v\ESC+\n\
    \\r\n\
    \\ENQ\EOT7\STX\NUL\ETX\DC2\EOT\248\v./\n\
    \\f\n\
    \\STX\EOT8\DC2\ACK\251\v\NUL\220\f\SOH\n\
    \\v\n\
    \\ETX\EOT8\SOH\DC2\EOT\251\v\b\SUB\n\
    \n\n\
    \\EOT\EOT8\STX\NUL\DC2\EOT\254\v\EOT\GS\SUB` A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ funding transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\NUL\ENQ\DC2\EOT\254\v\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\NUL\SOH\DC2\EOT\254\v\v\CAN\n\
    \\r\n\
    \\ENQ\EOT8\STX\NUL\ETX\DC2\EOT\254\v\ESC\FS\n\
    \u\n\
    \\EOT\EOT8\STX\SOH\DC2\EOT\132\f\EOT\SUB\SUBg\n\
    \The pubkey of the node to open a channel with. When using REST, this field\n\
    \must be encoded as base64.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\SOH\ENQ\DC2\EOT\132\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\SOH\SOH\DC2\EOT\132\f\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT8\STX\SOH\ETX\DC2\EOT\132\f\CAN\EM\n\
    \\154\SOH\n\
    \\EOT\EOT8\STX\STX\DC2\EOT\138\f\EOT6\SUB\139\SOH\n\
    \The hex encoded pubkey of the node to open a channel with. Deprecated now\n\
    \that the REST gateway supports base64 encoding of bytes fields.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\STX\ENQ\DC2\EOT\138\f\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\STX\SOH\DC2\EOT\138\f\v\GS\n\
    \\r\n\
    \\ENQ\EOT8\STX\STX\ETX\DC2\EOT\138\f !\n\
    \\r\n\
    \\ENQ\EOT8\STX\STX\b\DC2\EOT\138\f\"5\n\
    \\SO\n\
    \\ACK\EOT8\STX\STX\b\ETX\DC2\EOT\138\f#4\n\
    \N\n\
    \\EOT\EOT8\STX\ETX\DC2\EOT\141\f\EOT#\SUB@ The number of satoshis the wallet should commit to the channel\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\ETX\ENQ\DC2\EOT\141\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\ETX\SOH\DC2\EOT\141\f\n\
    \\RS\n\
    \\r\n\
    \\ENQ\EOT8\STX\ETX\ETX\DC2\EOT\141\f!\"\n\
    \j\n\
    \\EOT\EOT8\STX\EOT\DC2\EOT\145\f\EOT\ETB\SUB\\ The number of satoshis to push to the remote side as part of the initial\n\
    \ commitment state\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\EOT\ENQ\DC2\EOT\145\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\EOT\SOH\DC2\EOT\145\f\n\
    \\DC2\n\
    \\r\n\
    \\ENQ\EOT8\STX\EOT\ETX\DC2\EOT\145\f\NAK\SYN\n\
    \a\n\
    \\EOT\EOT8\STX\ENQ\DC2\EOT\149\f\EOT\SUB\SUBS The target number of blocks that the funding transaction should be\n\
    \ confirmed by.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\ENQ\ENQ\DC2\EOT\149\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\ENQ\SOH\DC2\EOT\149\f\n\
    \\NAK\n\
    \\r\n\
    \\ENQ\EOT8\STX\ENQ\ETX\DC2\EOT\149\f\CAN\EM\n\
    \\143\SOH\n\
    \\EOT\EOT8\STX\ACK\DC2\EOT\154\f\EOT/\SUB\128\SOH Deprecated, use sat_per_vbyte.\n\
    \ A manual fee rate set in sat/vbyte that should be used when crafting the\n\
    \ funding transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\ACK\ENQ\DC2\EOT\154\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\ACK\SOH\DC2\EOT\154\f\n\
    \\SYN\n\
    \\r\n\
    \\ENQ\EOT8\STX\ACK\ETX\DC2\EOT\154\f\EM\SUB\n\
    \\r\n\
    \\ENQ\EOT8\STX\ACK\b\DC2\EOT\154\f\ESC.\n\
    \\SO\n\
    \\ACK\EOT8\STX\ACK\b\ETX\DC2\EOT\154\f\FS-\n\
    \^\n\
    \\EOT\EOT8\STX\a\DC2\EOT\158\f\EOT\NAK\SUBP Whether this channel should be private, not announced to the greater\n\
    \ network.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\a\ENQ\DC2\EOT\158\f\EOT\b\n\
    \\r\n\
    \\ENQ\EOT8\STX\a\SOH\DC2\EOT\158\f\t\DLE\n\
    \\r\n\
    \\ENQ\EOT8\STX\a\ETX\DC2\EOT\158\f\DC3\DC4\n\
    \e\n\
    \\EOT\EOT8\STX\b\DC2\EOT\162\f\EOT\FS\SUBW The minimum value in millisatoshi we will require for incoming HTLCs on\n\
    \ the channel.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\b\ENQ\DC2\EOT\162\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\b\SOH\DC2\EOT\162\f\n\
    \\ETB\n\
    \\r\n\
    \\ENQ\EOT8\STX\b\ETX\DC2\EOT\162\f\SUB\ESC\n\
    \\153\SOH\n\
    \\EOT\EOT8\STX\t\DC2\EOT\166\f\EOT!\SUB\138\SOH The delay we require on the remote's commitment transaction. If this is\n\
    \ not set, it will be scaled automatically with the channel size.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\t\ENQ\DC2\EOT\166\f\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\t\SOH\DC2\EOT\166\f\v\ESC\n\
    \\r\n\
    \\ENQ\EOT8\STX\t\ETX\DC2\EOT\166\f\RS \n\
    \|\n\
    \\EOT\EOT8\STX\n\
    \\DC2\EOT\170\f\EOT\EM\SUBn The minimum number of confirmations each one of your outputs used for\n\
    \ the funding transaction must satisfy.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\n\
    \\ENQ\DC2\EOT\170\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT8\STX\n\
    \\SOH\DC2\EOT\170\f\n\
    \\DC3\n\
    \\r\n\
    \\ENQ\EOT8\STX\n\
    \\ETX\DC2\EOT\170\f\SYN\CAN\n\
    \b\n\
    \\EOT\EOT8\STX\v\DC2\EOT\174\f\EOT \SUBT Whether unconfirmed outputs should be used as inputs for the funding\n\
    \ transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\v\ENQ\DC2\EOT\174\f\EOT\b\n\
    \\r\n\
    \\ENQ\EOT8\STX\v\SOH\DC2\EOT\174\f\t\SUB\n\
    \\r\n\
    \\ENQ\EOT8\STX\v\ETX\DC2\EOT\174\f\GS\US\n\
    \\197\ETX\n\
    \\EOT\EOT8\STX\f\DC2\EOT\186\f\EOT\RS\SUB\182\ETX\n\
    \Close address is an optional address which specifies the address to which\n\
    \funds should be paid out to upon cooperative close. This field may only be\n\
    \set if the peer supports the option upfront feature bit (call listpeers\n\
    \to check). The remote peer will only accept cooperative closes to this\n\
    \address if it is set.\n\
    \\n\
    \Note: If this value is set on channel creation, you will *not* be able to\n\
    \cooperatively close out to a different address.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\f\ENQ\DC2\EOT\186\f\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\f\SOH\DC2\EOT\186\f\v\CAN\n\
    \\r\n\
    \\ENQ\EOT8\STX\f\ETX\DC2\EOT\186\f\ESC\GS\n\
    \\236\STX\n\
    \\EOT\EOT8\STX\r\DC2\EOT\195\f\EOT\"\SUB\221\STX\n\
    \Funding shims are an optional argument that allow the caller to intercept\n\
    \certain funding functionality. For example, a shim can be provided to use a\n\
    \particular key for the commitment key (ideally cold) rather than use one\n\
    \that is generated by the wallet as normal, or signal that signing will be\n\
    \carried out in an interactive manner (PSBT based).\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\r\ACK\DC2\EOT\195\f\EOT\SI\n\
    \\r\n\
    \\ENQ\EOT8\STX\r\SOH\DC2\EOT\195\f\DLE\FS\n\
    \\r\n\
    \\ENQ\EOT8\STX\r\ETX\DC2\EOT\195\f\US!\n\
    \\136\SOH\n\
    \\EOT\EOT8\STX\SO\DC2\EOT\201\f\EOT0\SUBz\n\
    \The maximum amount of coins in millisatoshi that can be pending within\n\
    \the channel. It only applies to the remote party.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\SO\ENQ\DC2\EOT\201\f\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\SO\SOH\DC2\EOT\201\f\v*\n\
    \\r\n\
    \\ENQ\EOT8\STX\SO\ETX\DC2\EOT\201\f-/\n\
    \{\n\
    \\EOT\EOT8\STX\SI\DC2\EOT\207\f\EOT!\SUBm\n\
    \The maximum number of concurrent HTLCs we will allow the remote party to add\n\
    \to the commitment transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\SI\ENQ\DC2\EOT\207\f\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\SI\SOH\DC2\EOT\207\f\v\ESC\n\
    \\r\n\
    \\ENQ\EOT8\STX\SI\ETX\DC2\EOT\207\f\RS \n\
    \h\n\
    \\EOT\EOT8\STX\DLE\DC2\EOT\213\f\EOT\RS\SUBZ\n\
    \Max local csv is the maximum csv delay we will allow for our own commitment\n\
    \transaction.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\DLE\ENQ\DC2\EOT\213\f\EOT\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\DLE\SOH\DC2\EOT\213\f\v\CAN\n\
    \\r\n\
    \\ENQ\EOT8\STX\DLE\ETX\DC2\EOT\213\f\ESC\GS\n\
    \\145\SOH\n\
    \\EOT\EOT8\STX\DC1\DC2\EOT\219\f\EOT(\SUB\130\SOH\n\
    \The explicit commitment type to use. Note this field will only be used if\n\
    \the remote peer supports explicit channel negotiation.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT8\STX\DC1\ACK\DC2\EOT\219\f\EOT\DC2\n\
    \\r\n\
    \\ENQ\EOT8\STX\DC1\SOH\DC2\EOT\219\f\DC3\"\n\
    \\r\n\
    \\ENQ\EOT8\STX\DC1\ETX\DC2\EOT\219\f%'\n\
    \\f\n\
    \\STX\EOT9\DC2\ACK\221\f\NUL\247\f\SOH\n\
    \\v\n\
    \\ETX\EOT9\SOH\DC2\EOT\221\f\b\CAN\n\
    \\SO\n\
    \\EOT\EOT9\b\NUL\DC2\ACK\222\f\EOT\240\f\ENQ\n\
    \\r\n\
    \\ENQ\EOT9\b\NUL\SOH\DC2\EOT\222\f\n\
    \\DLE\n\
    \g\n\
    \\EOT\EOT9\STX\NUL\DC2\EOT\227\f\b'\SUBY\n\
    \Signals that the channel is now fully negotiated and the funding\n\
    \transaction published.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT9\STX\NUL\ACK\DC2\EOT\227\f\b\NAK\n\
    \\r\n\
    \\ENQ\EOT9\STX\NUL\SOH\DC2\EOT\227\f\SYN\"\n\
    \\r\n\
    \\ENQ\EOT9\STX\NUL\ETX\DC2\EOT\227\f%&\n\
    \\141\SOH\n\
    \\EOT\EOT9\STX\SOH\DC2\EOT\233\f\b(\SUB\DEL\n\
    \Signals that the channel's funding transaction has now reached the\n\
    \required number of confirmations on chain and can be used.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT9\STX\SOH\ACK\DC2\EOT\233\f\b\EM\n\
    \\r\n\
    \\ENQ\EOT9\STX\SOH\SOH\DC2\EOT\233\f\SUB#\n\
    \\r\n\
    \\ENQ\EOT9\STX\SOH\ETX\DC2\EOT\233\f&'\n\
    \\149\SOH\n\
    \\EOT\EOT9\STX\STX\DC2\EOT\239\f\b*\SUB\134\SOH\n\
    \Signals that the funding process has been suspended and the construction\n\
    \of a PSBT that funds the channel PK script is now required.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT9\STX\STX\ACK\DC2\EOT\239\f\b\ESC\n\
    \\r\n\
    \\ENQ\EOT9\STX\STX\SOH\DC2\EOT\239\f\FS%\n\
    \\r\n\
    \\ENQ\EOT9\STX\STX\ETX\DC2\EOT\239\f()\n\
    \\156\SOH\n\
    \\EOT\EOT9\STX\ETX\DC2\EOT\246\f\EOT\RS\SUB\141\SOH\n\
    \The pending channel ID of the created channel. This value may be used to\n\
    \further the funding flow manually via the FundingStateStep method.\n\
    \\n\
    \\r\n\
    \\ENQ\EOT9\STX\ETX\ENQ\DC2\EOT\246\f\EOT\t\n\
    \\r\n\
    \\ENQ\EOT9\STX\ETX\SOH\DC2\EOT\246\f\n\
    \\EM\n\
    \\r\n\
    \\ENQ\EOT9\STX\ETX\ETX\DC2\EOT\246\f\FS\GSb\ACKproto3"