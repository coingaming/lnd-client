syntax = "proto3";

package lnrpc;

option go_package = "github.com/lightningnetwork/lnd/lnrpc";

//
// LowLevel stuff
//

message Feature {
    string name = 2;
    bool is_required = 3;
    bool is_known = 4;
}

enum FeatureBit {
    DATALOSS_PROTECT_REQ = 0;
    DATALOSS_PROTECT_OPT = 1;
    INITIAL_ROUING_SYNC = 3;
    UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;
    UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;
    GOSSIP_QUERIES_REQ = 6;
    GOSSIP_QUERIES_OPT = 7;
    TLV_ONION_REQ = 8;
    TLV_ONION_OPT = 9;
    EXT_GOSSIP_QUERIES_REQ = 10;
    EXT_GOSSIP_QUERIES_OPT = 11;
    STATIC_REMOTE_KEY_REQ = 12;
    STATIC_REMOTE_KEY_OPT = 13;
    PAYMENT_ADDR_REQ = 14;
    PAYMENT_ADDR_OPT = 15;
    MPP_REQ = 16;
    MPP_OPT = 17;
    WUMBO_CHANNELS_REQ = 18;
    WUMBO_CHANNELS_OPT = 19;
    ANCHORS_REQ = 20;
    ANCHORS_OPT = 21;
    ANCHORS_ZERO_FEE_HTLC_REQ = 22;
    ANCHORS_ZERO_FEE_HTLC_OPT = 23;
    AMP_REQ = 30;
    AMP_OPT = 31;
}

message RouteHint {
    /*
    A list of hop hints that when chained together can assist in reaching a
    specific destination.
    */
    repeated HopHint hop_hints = 1;
}

message HopHint {
    // The public key of the node at the start of the channel.
    string node_id = 1;

    // The unique identifier of the channel.
    uint64 chan_id = 2 [jstype = JS_STRING];

    // The base fee of the channel denominated in millisatoshis.
    uint32 fee_base_msat = 3;

    /*
    The fee rate of the channel for sending one satoshi across it denominated in
    millionths of a satoshi.
    */
    uint32 fee_proportional_millionths = 4;

    // The time-lock delta of the channel.
    uint32 cltv_expiry_delta = 5;
}

message ChannelPoint {
    oneof funding_txid {
        /*
        Txid of the funding transaction. When using REST, this field must be
        encoded as base64.
        */
        bytes funding_txid_bytes = 1;

        /*
        Hex-encoded string representing the byte-reversed hash of the funding
        transaction.
        */
        string funding_txid_str = 2;
    }

    // The index of the output of the funding transaction
    uint32 output_index = 3;
}

message OutPoint {
    // Raw bytes representing the transaction id.
    bytes txid_bytes = 1;

    // Reversed, hex-encoded string representing the transaction id.
    string txid_str = 2;

    // The index of the output on the transaction.
    uint32 output_index = 3;
}

enum Initiator {
    INITIATOR_UNKNOWN = 0;
    INITIATOR_LOCAL = 1;
    INITIATOR_REMOTE = 2;
    INITIATOR_BOTH = 3;
}

enum CommitmentType {
    /*
    Returned when the commitment type isn't known or unavailable.
    */
    UNKNOWN_COMMITMENT_TYPE = 0;

    /*
    A channel using the legacy commitment format having tweaked to_remote
    keys.
    */
    LEGACY = 1;

    /*
    A channel that uses the modern commitment format where the key in the
    output of the remote party does not change each state. This makes back
    up and recovery easier as when the channel is closed, the funds go
    directly to that key.
    */
    STATIC_REMOTE_KEY = 2;

    /*
    A channel that uses a commitment format that has anchor outputs on the
    commitments, allowing fee bumping after a force close transaction has
    been broadcast.
    */
    ANCHORS = 3;

    /*
    A channel that uses a commitment type that builds upon the anchors
    commitment format, but in addition requires a CLTV clause to spend outputs
    paying to the channel initiator. This is intended for use on leased channels
    to guarantee that the channel initiator has no incentives to close a leased
    channel before its maturity date.
    */
    SCRIPT_ENFORCED_LEASE = 4;
}

message ChannelConstraints {
    /*
    The CSV delay expressed in relative blocks. If the channel is force closed,
    we will need to wait for this many blocks before we can regain our funds.
    */
    uint32 csv_delay = 1;

    // The minimum satoshis this node is required to reserve in its balance.
    uint64 chan_reserve_sat = 2;

    // The dust limit (in satoshis) of the initiator's commitment tx.
    uint64 dust_limit_sat = 3;

    // The maximum amount of coins in millisatoshis that can be pending in this
    // channel.
    uint64 max_pending_amt_msat = 4;

    // The smallest HTLC in millisatoshis that the initiator will accept.
    uint64 min_htlc_msat = 5;

    // The total number of incoming HTLC's that the initiator will accept.
    uint32 max_accepted_htlcs = 6;
}

message Channel {
    // Whether this channel is active or not
    bool active = 1;

    // The identity pubkey of the remote node
    string remote_pubkey = 2;

    /*
    The outpoint (txid:index) of the funding transaction. With this value, Bob
    will be able to generate a signature for Alice's version of the commitment
    transaction.
    */
    string channel_point = 3;

    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 4 [jstype = JS_STRING];

    // The total amount of funds held in this channel
    int64 capacity = 5;

    // This node's current balance in this channel
    int64 local_balance = 6;

    // The counterparty's current balance in this channel
    int64 remote_balance = 7;

    /*
    The amount calculated to be paid in fees for the current set of commitment
    transactions. The fee amount is persisted with the channel in order to
    allow the fee amount to be removed and recalculated with each channel state
    update, including updates that happen after a system restart.
    */
    int64 commit_fee = 8;

    // The weight of the commitment transaction
    int64 commit_weight = 9;

    /*
    The required number of satoshis per kilo-weight that the requester will pay
    at all times, for both the funding transaction and commitment transaction.
    This value can later be updated once the channel is open.
    */
    int64 fee_per_kw = 10;

    // The unsettled balance in this channel
    int64 unsettled_balance = 11;

    /*
    The total number of satoshis we've sent within this channel.
    */
    int64 total_satoshis_sent = 12;

    /*
    The total number of satoshis we've received within this channel.
    */
    int64 total_satoshis_received = 13;

    /*
    The total number of updates conducted within this channel.
    */
    uint64 num_updates = 14;

    /*
    The list of active, uncleared HTLCs currently pending within the channel.
    */
    repeated HTLC pending_htlcs = 15;

    /*
    Deprecated. The CSV delay expressed in relative blocks. If the channel is
    force closed, we will need to wait for this many blocks before we can regain
    our funds.
    */
    uint32 csv_delay = 16 [deprecated = true];

    // Whether this channel is advertised to the network or not.
    bool private = 17;

    // True if we were the ones that created the channel.
    bool initiator = 18;

    // A set of flags showing the current state of the channel.
    string chan_status_flags = 19;

    // Deprecated. The minimum satoshis this node is required to reserve in its
    // balance.
    int64 local_chan_reserve_sat = 20 [deprecated = true];

    /*
    Deprecated. The minimum satoshis the other node is required to reserve in
    its balance.
    */
    int64 remote_chan_reserve_sat = 21 [deprecated = true];

    // Deprecated. Use commitment_type.
    bool static_remote_key = 22 [deprecated = true];

    // The commitment type used by this channel.
    CommitmentType commitment_type = 26;

    /*
    The number of seconds that the channel has been monitored by the channel
    scoring system. Scores are currently not persisted, so this value may be
    less than the lifetime of the channel [EXPERIMENTAL].
    */
    int64 lifetime = 23;

    /*
    The number of seconds that the remote peer has been observed as being online
    by the channel scoring system over the lifetime of the channel
    [EXPERIMENTAL].
    */
    int64 uptime = 24;

    /*
    Close address is the address that we will enforce payout to on cooperative
    close if the channel was opened utilizing option upfront shutdown. This
    value can be set on channel open by setting close_address in an open channel
    request. If this value is not set, you can still choose a payout address by
    cooperatively closing with the delivery_address field set.
    */
    string close_address = 25;

    /*
    The amount that the initiator of the channel optionally pushed to the remote
    party on channel open. This amount will be zero if the channel initiator did
    not push any funds to the remote peer. If the initiator field is true, we
    pushed this amount to our peer, if it is false, the remote peer pushed this
    amount to us.
    */
    uint64 push_amount_sat = 27;

    /*
    This uint32 indicates if this channel is to be considered 'frozen'. A
    frozen channel doest not allow a cooperative channel close by the
    initiator. The thaw_height is the height that this restriction stops
    applying to the channel. This field is optional, not setting it or using a
    value of zero will mean the channel has no additional restrictions. The
    height can be interpreted in two ways: as a relative height if the value is
    less than 500,000, or as an absolute height otherwise.
    */
    uint32 thaw_height = 28;

    // List constraints for the local node.
    ChannelConstraints local_constraints = 29;

    // List constraints for the remote node.
    ChannelConstraints remote_constraints = 30;
}

message ChannelCloseSummary {
    // The outpoint (txid:index) of the funding transaction.
    string channel_point = 1;

    //  The unique channel ID for the channel.
    uint64 chan_id = 2 [jstype = JS_STRING];

    // The hash of the genesis block that this channel resides within.
    string chain_hash = 3;

    // The txid of the transaction which ultimately closed this channel.
    string closing_tx_hash = 4;

    // Public key of the remote peer that we formerly had a channel with.
    string remote_pubkey = 5;

    // Total capacity of the channel.
    int64 capacity = 6;

    // Height at which the funding transaction was spent.
    uint32 close_height = 7;

    // Settled balance at the time of channel closure
    int64 settled_balance = 8;

    // The sum of all the time-locked outputs at the time of channel closure
    int64 time_locked_balance = 9;

    enum ClosureType {
        COOPERATIVE_CLOSE = 0;
        LOCAL_FORCE_CLOSE = 1;
        REMOTE_FORCE_CLOSE = 2;
        BREACH_CLOSE = 3;
        FUNDING_CANCELED = 4;
        ABANDONED = 5;
    }

    // Details on how the channel was closed.
    ClosureType close_type = 10;

    /*
    Open initiator is the party that initiated opening the channel. Note that
    this value may be unknown if the channel was closed before we migrated to
    store open channel information after close.
    */
    Initiator open_initiator = 11;

    /*
    Close initiator indicates which party initiated the close. This value will
    be unknown for channels that were cooperatively closed before we started
    tracking cooperative close initiators. Note that this indicates which party
    initiated a close, and it is possible for both to initiate cooperative or
    force closes, although only one party's close will be confirmed on chain.
    */
    Initiator close_initiator = 12;

    repeated Resolution resolutions = 13;
}

message PendingUpdate {
    bytes txid = 1;
    uint32 output_index = 2;
}

enum ResolutionType {
    TYPE_UNKNOWN = 0;

    // We resolved an anchor output.
    ANCHOR = 1;

    /*
    We are resolving an incoming htlc on chain. This if this htlc is
    claimed, we swept the incoming htlc with the preimage. If it is timed
    out, our peer swept the timeout path.
    */
    INCOMING_HTLC = 2;

    /*
    We are resolving an outgoing htlc on chain. If this htlc is claimed,
    the remote party swept the htlc with the preimage. If it is timed out,
    we swept it with the timeout path.
    */
    OUTGOING_HTLC = 3;

    // We force closed and need to sweep our time locked commitment output.
    COMMIT = 4;
}

enum ResolutionOutcome {
    // Outcome unknown.
    OUTCOME_UNKNOWN = 0;

    // An output was claimed on chain.
    CLAIMED = 1;

    // An output was left unclaimed on chain.
    UNCLAIMED = 2;

    /*
    ResolverOutcomeAbandoned indicates that an output that we did not
    claim on chain, for example an anchor that we did not sweep and a
    third party claimed on chain, or a htlc that we could not decode
    so left unclaimed.
    */
    ABANDONED = 3;

    /*
    If we force closed our channel, our htlcs need to be claimed in two
    stages. This outcome represents the broadcast of a timeout or success
    transaction for this two stage htlc claim.
    */
    FIRST_STAGE = 4;

    // A htlc was timed out on chain.
    TIMEOUT = 5;
}

message Resolution {
    // The type of output we are resolving.
    ResolutionType resolution_type = 1;

    // The outcome of our on chain action that resolved the outpoint.
    ResolutionOutcome outcome = 2;

    // The outpoint that was spent by the resolution.
    OutPoint outpoint = 3;

    // The amount that was claimed by the resolution.
    uint64 amount_sat = 4;

    // The hex-encoded transaction ID of the sweep transaction that spent the
    // output.
    string sweep_txid = 5;
}

message FeeLimit {
    oneof limit {
        /*
        The fee limit expressed as a fixed amount of satoshis.

        The fields fixed and fixed_msat are mutually exclusive.
        */
        int64 fixed = 1;

        /*
        The fee limit expressed as a fixed amount of millisatoshis.

        The fields fixed and fixed_msat are mutually exclusive.
        */
        int64 fixed_msat = 3;

        // The fee limit expressed as a percentage of the payment amount.
        int64 percent = 2;
    }
}

message HTLC {
    bool incoming = 1;
    int64 amount = 2;
    bytes hash_lock = 3;
    uint32 expiration_height = 4;

    // Index identifying the htlc on the channel.
    uint64 htlc_index = 5;

    // If this HTLC is involved in a forwarding operation, this field indicates
    // the forwarding channel. For an outgoing htlc, it is the incoming channel.
    // For an incoming htlc, it is the outgoing channel. When the htlc
    // originates from this node or this node is the final destination,
    // forwarding_channel will be zero. The forwarding channel will also be zero
    // for htlcs that need to be forwarded but don't have a forwarding decision
    // persisted yet.
    uint64 forwarding_channel = 6;

    // Index identifying the htlc on the forwarding channel.
    uint64 forwarding_htlc_index = 7;
}

//
// HighLevel stuff
//

message KeyLocator {
    // The family of key being identified.
    int32 key_family = 1;

    // The precise index of the key being identified.
    int32 key_index = 2;
}

message KeyDescriptor {
    /*
    The raw bytes of the key being identified.
    */
    bytes raw_key_bytes = 1;

    /*
    The key locator that identifies which key to use for signing.
    */
    KeyLocator key_loc = 2;
}

message ChanPointShim {
    /*
    The size of the pre-crafted output to be used as the channel point for this
    channel funding.
    */
    int64 amt = 1;

    // The target channel point to refrence in created commitment transactions.
    ChannelPoint chan_point = 2;

    // Our local key to use when creating the multi-sig output.
    KeyDescriptor local_key = 3;

    // The key of the remote party to use when creating the multi-sig output.
    bytes remote_key = 4;

    /*
    If non-zero, then this will be used as the pending channel ID on the wire
    protocol to initate the funding request. This is an optional field, and
    should only be set if the responder is already expecting a specific pending
    channel ID.
    */
    bytes pending_chan_id = 5;

    /*
    This uint32 indicates if this channel is to be considered 'frozen'. A frozen
    channel does not allow a cooperative channel close by the initiator. The
    thaw_height is the height that this restriction stops applying to the
    channel. The height can be interpreted in two ways: as a relative height if
    the value is less than 500,000, or as an absolute height otherwise.
    */
    uint32 thaw_height = 6;
}

message PsbtShim {
    /*
    A unique identifier of 32 random bytes that will be used as the pending
    channel ID to identify the PSBT state machine when interacting with it and
    on the wire protocol to initiate the funding request.
    */
    bytes pending_chan_id = 1;

    /*
    An optional base PSBT the new channel output will be added to. If this is
    non-empty, it must be a binary serialized PSBT.
    */
    bytes base_psbt = 2;

    /*
    If a channel should be part of a batch (multiple channel openings in one
    transaction), it can be dangerous if the whole batch transaction is
    published too early before all channel opening negotiations are completed.
    This flag prevents this particular channel from broadcasting the transaction
    after the negotiation with the remote peer. In a batch of channel openings
    this flag should be set to true for every channel but the very last.
    */
    bool no_publish = 3;
}

message FundingShim {
    oneof shim {
        /*
        A channel shim where the channel point was fully constructed outside
        of lnd's wallet and the transaction might already be published.
        */
        ChanPointShim chan_point_shim = 1;

        /*
        A channel shim that uses a PSBT to fund and sign the channel funding
        transaction.
        */
        PsbtShim psbt_shim = 2;
    }
}

message FundingShimCancel {
    // The pending channel ID of the channel to cancel the funding shim for.
    bytes pending_chan_id = 1;
}

message FundingPsbtVerify {
    /*
    The funded but not yet signed PSBT that sends the exact channel capacity
    amount to the PK script returned in the open channel message in a previous
    step.
    */
    bytes funded_psbt = 1;

    // The pending channel ID of the channel to get the PSBT for.
    bytes pending_chan_id = 2;

    /*
    Can only be used if the no_publish flag was set to true in the OpenChannel
    call meaning that the caller is solely responsible for publishing the final
    funding transaction. If skip_finalize is set to true then lnd will not wait
    for a FundingPsbtFinalize state step and instead assumes that a transaction
    with the same TXID as the passed in PSBT will eventually confirm.
    IT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is
    eventually published does have the _same TXID_ as the verified PSBT. That
    means no inputs or outputs can change, only signatures can be added. If the
    TXID changes between this call and the publish step then the channel will
    never be created and the funds will be in limbo.
    */
    bool skip_finalize = 3;
}

message FundingPsbtFinalize {
    /*
    The funded PSBT that contains all witness data to send the exact channel
    capacity amount to the PK script returned in the open channel message in a
    previous step. Cannot be set at the same time as final_raw_tx.
    */
    bytes signed_psbt = 1;

    // The pending channel ID of the channel to get the PSBT for.
    bytes pending_chan_id = 2;

    /*
    As an alternative to the signed PSBT with all witness data, the final raw
    wire format transaction can also be specified directly. Cannot be set at the
    same time as signed_psbt.
    */
    bytes final_raw_tx = 3;
}

message FundingTransitionMsg {
    oneof trigger {
        /*
        The funding shim to register. This should be used before any
        channel funding has began by the remote party, as it is intended as a
        preparatory step for the full channel funding.
        */
        FundingShim shim_register = 1;

        // Used to cancel an existing registered funding shim.
        FundingShimCancel shim_cancel = 2;

        /*
        Used to continue a funding flow that was initiated to be executed
        through a PSBT. This step verifies that the PSBT contains the correct
        outputs to fund the channel.
        */
        FundingPsbtVerify psbt_verify = 3;

        /*
        Used to continue a funding flow that was initiated to be executed
        through a PSBT. This step finalizes the funded and signed PSBT, finishes
        negotiation with the peer and finally publishes the resulting funding
        transaction.
        */
        FundingPsbtFinalize psbt_finalize = 4;
    }
}

message FundingStateStepResp {
}

message PendingHTLC {
    // The direction within the channel that the htlc was sent
    bool incoming = 1;

    // The total value of the htlc
    int64 amount = 2;

    // The final output to be swept back to the user's wallet
    string outpoint = 3;

    // The next block height at which we can spend the current stage
    uint32 maturity_height = 4;

    /*
       The number of blocks remaining until the current stage can be swept.
       Negative values indicate how many blocks have passed since becoming
       mature.
    */
    int32 blocks_til_maturity = 5;

    // Indicates whether the htlc is in its first or second stage of recovery
    uint32 stage = 6;
}

message PendingChannelsRequest {
}
message PendingChannelsResponse {
    message PendingChannel {
        string remote_node_pub = 1;
        string channel_point = 2;

        int64 capacity = 3;

        int64 local_balance = 4;
        int64 remote_balance = 5;

        // The minimum satoshis this node is required to reserve in its
        // balance.
        int64 local_chan_reserve_sat = 6;

        /*
        The minimum satoshis the other node is required to reserve in its
        balance.
        */
        int64 remote_chan_reserve_sat = 7;

        // The party that initiated opening the channel.
        Initiator initiator = 8;

        // The commitment type used by this channel.
        CommitmentType commitment_type = 9;

        // Total number of forwarding packages created in this channel.
        int64 num_forwarding_packages = 10;
    }

    message PendingOpenChannel {
        // The pending channel
        PendingChannel channel = 1;

        // The height at which this channel will be confirmed
        uint32 confirmation_height = 2;

        /*
        The amount calculated to be paid in fees for the current set of
        commitment transactions. The fee amount is persisted with the channel
        in order to allow the fee amount to be removed and recalculated with
        each channel state update, including updates that happen after a system
        restart.
        */
        int64 commit_fee = 4;

        // The weight of the commitment transaction
        int64 commit_weight = 5;

        /*
        The required number of satoshis per kilo-weight that the requester will
        pay at all times, for both the funding transaction and commitment
        transaction. This value can later be updated once the channel is open.
        */
        int64 fee_per_kw = 6;
    }

    message WaitingCloseChannel {
        // The pending channel waiting for closing tx to confirm
        PendingChannel channel = 1;

        // The balance in satoshis encumbered in this channel
        int64 limbo_balance = 2;

        /*
        A list of valid commitment transactions. Any of these can confirm at
        this point.
        */
        Commitments commitments = 3;
    }

    message Commitments {
        // Hash of the local version of the commitment tx.
        string local_txid = 1;

        // Hash of the remote version of the commitment tx.
        string remote_txid = 2;

        // Hash of the remote pending version of the commitment tx.
        string remote_pending_txid = 3;

        /*
        The amount in satoshis calculated to be paid in fees for the local
        commitment.
        */
        uint64 local_commit_fee_sat = 4;

        /*
        The amount in satoshis calculated to be paid in fees for the remote
        commitment.
        */
        uint64 remote_commit_fee_sat = 5;

        /*
        The amount in satoshis calculated to be paid in fees for the remote
        pending commitment.
        */
        uint64 remote_pending_commit_fee_sat = 6;
    }

    message ClosedChannel {
        // The pending channel to be closed
        PendingChannel channel = 1;

        // The transaction id of the closing transaction
        string closing_txid = 2;
    }

    message ForceClosedChannel {
        // The pending channel to be force closed
        PendingChannel channel = 1;

        // The transaction id of the closing transaction
        string closing_txid = 2;

        // The balance in satoshis encumbered in this pending channel
        int64 limbo_balance = 3;

        // The height at which funds can be swept into the wallet
        uint32 maturity_height = 4;

        /*
          Remaining # of blocks until the commitment output can be swept.
          Negative values indicate how many blocks have passed since becoming
          mature.
        */
        int32 blocks_til_maturity = 5;

        // The total value of funds successfully recovered from this channel
        int64 recovered_balance = 6;

        repeated PendingHTLC pending_htlcs = 8;

        enum AnchorState {
            LIMBO = 0;
            RECOVERED = 1;
            LOST = 2;
        }

        AnchorState anchor = 9;
    }

    // The balance in satoshis encumbered in pending channels
    int64 total_limbo_balance = 1;

    // Channels pending opening
    repeated PendingOpenChannel pending_open_channels = 2;

    /*
    Deprecated: Channels pending closing previously contained cooperatively
    closed channels with a single confirmation. These channels are now
    considered closed from the time we see them on chain.
    */
    repeated ClosedChannel pending_closing_channels = 3 [deprecated = true];

    // Channels pending force closing
    repeated ForceClosedChannel pending_force_closing_channels = 4;

    // Channels waiting for closing tx to confirm
    repeated WaitingCloseChannel waiting_close_channels = 5;
}

message ChannelEventSubscription {
}

message ChannelEventUpdate {
    oneof channel {
        Channel open_channel = 1;
        ChannelCloseSummary closed_channel = 2;
        ChannelPoint active_channel = 3;
        ChannelPoint inactive_channel = 4;
        PendingUpdate pending_open_channel = 6;
        ChannelPoint fully_resolved_channel = 7;
    }

    enum UpdateType {
        OPEN_CHANNEL = 0;
        CLOSED_CHANNEL = 1;
        ACTIVE_CHANNEL = 2;
        INACTIVE_CHANNEL = 3;
        PENDING_OPEN_CHANNEL = 4;
        FULLY_RESOLVED_CHANNEL = 5;
    }

    UpdateType type = 5;
}

message WalletAccountBalance {
    // The confirmed balance of the account (with >= 1 confirmations).
    int64 confirmed_balance = 1;

    // The unconfirmed balance of the account (with 0 confirmations).
    int64 unconfirmed_balance = 2;
}

message WalletBalanceRequest {
}

message WalletBalanceResponse {
    // The balance of the wallet
    int64 total_balance = 1;

    // The confirmed balance of a wallet(with >= 1 confirmations)
    int64 confirmed_balance = 2;

    // The unconfirmed balance of a wallet(with 0 confirmations)
    int64 unconfirmed_balance = 3;

    // A mapping of each wallet account's name to its balance.
    map<string, WalletAccountBalance> account_balance = 4;
}

message Amount {
    // Value denominated in satoshis.
    uint64 sat = 1;

    // Value denominated in milli-satoshis.
    uint64 msat = 2;
}

message ChannelBalanceRequest {
}
message ChannelBalanceResponse {
    // Deprecated. Sum of channels balances denominated in satoshis
    int64 balance = 1 [deprecated = true];

    // Deprecated. Sum of channels pending balances denominated in satoshis
    int64 pending_open_balance = 2 [deprecated = true];

    // Sum of channels local balances.
    Amount local_balance = 3;

    // Sum of channels remote balances.
    Amount remote_balance = 4;

    // Sum of channels local unsettled balances.
    Amount unsettled_local_balance = 5;

    // Sum of channels remote unsettled balances.
    Amount unsettled_remote_balance = 6;

    // Sum of channels pending local balances.
    Amount pending_open_local_balance = 7;

    // Sum of channels pending remote balances.
    Amount pending_open_remote_balance = 8;
}

message QueryRoutesRequest {
    // The 33-byte hex-encoded public key for the payment destination
    string pub_key = 1;

    /*
    The amount to send expressed in satoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt = 2;

    /*
    The amount to send expressed in millisatoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt_msat = 12;

    reserved 3;

    /*
    An optional CLTV delta from the current height that should be used for the
    timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
    not add any additional block padding on top of final_ctlv_delta. This
    padding of a few blocks needs to be added manually or otherwise failures may
    happen when a block comes in while the payment is in flight.
    */
    int32 final_cltv_delta = 4;

    /*
    The maximum number of satoshis that will be paid as a fee of the payment.
    This value can be represented either as a percentage of the amount being
    sent, or as a fixed amount of the maximum fee the user is willing the pay to
    send the payment.
    */
    FeeLimit fee_limit = 5;

    /*
    A list of nodes to ignore during path finding. When using REST, these fields
    must be encoded as base64.
    */
    repeated bytes ignored_nodes = 6;

    /*
    Deprecated. A list of edges to ignore during path finding.
    */
    repeated EdgeLocator ignored_edges = 7 [deprecated = true];

    /*
    The source node where the request route should originated from. If empty,
    self is assumed.
    */
    string source_pub_key = 8;

    /*
    If set to true, edge probabilities from mission control will be used to get
    the optimal route.
    */
    bool use_mission_control = 9;

    /*
    A list of directed node pairs that will be ignored during path finding.
    */
    repeated NodePair ignored_pairs = 10;

    /*
    An optional maximum total time lock for the route. If the source is empty or
    ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
    zero, then the value of `--max-cltv-expiry` is used as the limit.
    */
    uint32 cltv_limit = 11;

    /*
    An optional field that can be used to pass an arbitrary set of TLV records
    to a peer which understands the new records. This can be used to pass
    application specific data during the payment attempt. If the destination
    does not support the specified records, an error will be returned.
    Record types are required to be in the custom range >= 65536. When using
    REST, the values must be encoded as base64.
    */
    map<uint64, bytes> dest_custom_records = 13;

    /*
    The channel id of the channel that must be taken to the first hop. If zero,
    any channel may be used.
    */
    uint64 outgoing_chan_id = 14 [jstype = JS_STRING];

    /*
    The pubkey of the last hop of the route. If empty, any hop may be used.
    */
    bytes last_hop_pubkey = 15;

    /*
    Optional route hints to reach the destination through private channels.
    */
    repeated lnrpc.RouteHint route_hints = 16;

    /*
    Features assumed to be supported by the final node. All transitive feature
    dependencies must also be set properly. For a given feature bit pair, either
    optional or remote may be set, but not both. If this field is nil or empty,
    the router will try to load destination features from the graph as a
    fallback.
    */
    repeated lnrpc.FeatureBit dest_features = 17;
}

message NodePair {
    /*
    The sending node of the pair. When using REST, this field must be encoded as
    base64.
    */
    bytes from = 1;

    /*
    The receiving node of the pair. When using REST, this field must be encoded
    as base64.
    */
    bytes to = 2;
}

message EdgeLocator {
    // The short channel id of this edge.
    uint64 channel_id = 1 [jstype = JS_STRING];

    /*
    The direction of this edge. If direction_reverse is false, the direction
    of this edge is from the channel endpoint with the lexicographically smaller
    pub key to the endpoint with the larger pub key. If direction_reverse is
    is true, the edge goes the other way.
    */
    bool direction_reverse = 2;
}

message QueryRoutesResponse {
    /*
    The route that results from the path finding operation. This is still a
    repeated field to retain backwards compatibility.
    */
    repeated Route routes = 1;

    /*
    The success probability of the returned route based on the current mission
    control state. [EXPERIMENTAL]
    */
    double success_prob = 2;
}

message Hop {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 1 [jstype = JS_STRING];
    int64 chan_capacity = 2 [deprecated = true];
    int64 amt_to_forward = 3 [deprecated = true];
    int64 fee = 4 [deprecated = true];
    uint32 expiry = 5;
    int64 amt_to_forward_msat = 6;
    int64 fee_msat = 7;

    /*
    An optional public key of the hop. If the public key is given, the payment
    can be executed without relying on a copy of the channel graph.
    */
    string pub_key = 8;

    /*
    If set to true, then this hop will be encoded using the new variable length
    TLV format. Note that if any custom tlv_records below are specified, then
    this field MUST be set to true for them to be encoded properly.
    */
    bool tlv_payload = 9;

    /*
    An optional TLV record that signals the use of an MPP payment. If present,
    the receiver will enforce that the same mpp_record is included in the final
    hop payload of all non-zero payments in the HTLC set. If empty, a regular
    single-shot payment is or was attempted.
    */
    MPPRecord mpp_record = 10;

    /*
    An optional TLV record that signals the use of an AMP payment. If present,
    the receiver will treat all received payments including the same
    (payment_addr, set_id) pair  as being part of one logical payment. The
    payment will be settled by XORing the root_share's together and deriving the
    child hashes and preimages according to BOLT XX. Must be used in conjunction
    with mpp_record.
    */
    AMPRecord amp_record = 12;

    /*
    An optional set of key-value TLV records. This is useful within the context
    of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
    to drop off at each hop within the onion.
    */
    map<uint64, bytes> custom_records = 11;
}

message MPPRecord {
    /*
    A unique, random identifier used to authenticate the sender as the intended
    payer of a multi-path payment. The payment_addr must be the same for all
    subpayments, and match the payment_addr provided in the receiver's invoice.
    The same payment_addr must be used on all subpayments.
    */
    bytes payment_addr = 11;

    /*
    The total amount in milli-satoshis being sent as part of a larger multi-path
    payment. The caller is responsible for ensuring subpayments to the same node
    and payment_hash sum exactly to total_amt_msat. The same
    total_amt_msat must be used on all subpayments.
    */
    int64 total_amt_msat = 10;
}

message AMPRecord {
    bytes root_share = 1;

    bytes set_id = 2;

    uint32 child_index = 3;
}

/*
A path through the channel graph which runs over one or more channels in
succession. This struct carries all the information required to craft the
Sphinx onion packet, and send the payment along the first hop in the path. A
route is only selected as valid if all the channels have sufficient capacity to
carry the initial payment amount after fees are accounted for.
*/
message Route {
    /*
    The cumulative (final) time lock across the entire route. This is the CLTV
    value that should be extended to the first hop in the route. All other hops
    will decrement the time-lock as advertised, leaving enough time for all
    hops to wait for or present the payment preimage to complete the payment.
    */
    uint32 total_time_lock = 1;

    /*
    The sum of the fees paid at each hop within the final route. In the case
    of a one-hop payment, this value will be zero as we don't need to pay a fee
    to ourselves.
    */
    int64 total_fees = 2 [deprecated = true];

    /*
    The total amount of funds required to complete a payment over this route.
    This value includes the cumulative fees at each hop. As a result, the HTLC
    extended to the first-hop in the route will need to have at least this many
    satoshis, otherwise the route will fail at an intermediate node due to an
    insufficient amount of fees.
    */
    int64 total_amt = 3 [deprecated = true];

    /*
    Contains details concerning the specific forwarding details at each hop.
    */
    repeated Hop hops = 4;

    /*
    The total fees in millisatoshis.
    */
    int64 total_fees_msat = 5;

    /*
    The total amount in millisatoshis.
    */
    int64 total_amt_msat = 6;
}

message NodeInfoRequest {
    // The 33-byte hex-encoded compressed public of the target node
    string pub_key = 1;

    // If true, will include all known channels associated with the node.
    bool include_channels = 2;
}

message NodeInfo {
    /*
    An individual vertex/node within the channel graph. A node is
    connected to other nodes by one or more channel edges emanating from it. As
    the graph is directed, a node will also have an incoming edge attached to
    it for each outgoing edge.
    */
    LightningNode node = 1;

    // The total number of channels for the node.
    uint32 num_channels = 2;

    // The sum of all channels capacity for the node, denominated in satoshis.
    int64 total_capacity = 3;

    // A list of all public channels for the node.
    repeated ChannelEdge channels = 4;
}

/*
An individual vertex/node within the channel graph. A node is
connected to other nodes by one or more channel edges emanating from it. As the
graph is directed, a node will also have an incoming edge attached to it for
each outgoing edge.
*/
message LightningNode {
    uint32 last_update = 1;
    string pub_key = 2;
    string alias = 3;
    repeated NodeAddress addresses = 4;
    string color = 5;
    map<uint32, Feature> features = 6;
}

message NodeAddress {
    string network = 1;
    string addr = 2;
}

message RoutingPolicy {
    uint32 time_lock_delta = 1;
    int64 min_htlc = 2;
    int64 fee_base_msat = 3;
    int64 fee_rate_milli_msat = 4;
    bool disabled = 5;
    uint64 max_htlc_msat = 6;
    uint32 last_update = 7;
}

/*
A fully authenticated channel along with all its unique attributes.
Once an authenticated channel announcement has been processed on the network,
then an instance of ChannelEdgeInfo encapsulating the channels attributes is
stored. The other portions relevant to routing policy of a channel are stored
within a ChannelEdgePolicy for each direction of the channel.
*/
message ChannelEdge {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 channel_id = 1 [jstype = JS_STRING];
    string chan_point = 2;

    uint32 last_update = 3 [deprecated = true];

    string node1_pub = 4;
    string node2_pub = 5;

    int64 capacity = 6;

    RoutingPolicy node1_policy = 7;
    RoutingPolicy node2_policy = 8;
}

message ChannelGraphRequest {
    /*
    Whether unannounced channels are included in the response or not. If set,
    unannounced channels are included. Unannounced channels are both private
    channels, and public channels that are not yet announced to the network.
    */
    bool include_unannounced = 1;
}

// Returns a new instance of the directed channel graph.
message ChannelGraph {
    // The list of `LightningNode`s in this channel graph
    repeated LightningNode nodes = 1;

    // The list of `ChannelEdge`s in this channel graph
    repeated ChannelEdge edges = 2;
}

enum NodeMetricType {
    UNKNOWN = 0;
    BETWEENNESS_CENTRALITY = 1;
}

message NodeMetricsRequest {
    // The requested node metrics.
    repeated NodeMetricType types = 1;
}

message NodeMetricsResponse {
    /*
    Betweenness centrality is the sum of the ratio of shortest paths that pass
    through the node for each pair of nodes in the graph (not counting paths
    starting or ending at this node).
    Map of node pubkey to betweenness centrality of the node. Normalized
    values are in the [0,1] closed interval.
    */
    map<string, FloatMetric> betweenness_centrality = 1;
}

message FloatMetric {
    // Arbitrary float value.
    double value = 1;

    // The value normalized to [0,1] or [-1,1].
    double normalized_value = 2;
}

message ChanInfoRequest {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 1 [jstype = JS_STRING];
}

message NetworkInfoRequest {
}
message NetworkInfo {
    uint32 graph_diameter = 1;
    double avg_out_degree = 2;
    uint32 max_out_degree = 3;

    uint32 num_nodes = 4;
    uint32 num_channels = 5;

    int64 total_network_capacity = 6;

    double avg_channel_size = 7;
    int64 min_channel_size = 8;
    int64 max_channel_size = 9;
    int64 median_channel_size_sat = 10;

    // The number of edges marked as zombies.
    uint64 num_zombie_chans = 11;

    // TODO(roasbeef): fee rate info, expiry
    //  * also additional RPC for tracking fee info once in
}

message StopRequest {
}
message StopResponse {
}

message GraphTopologySubscription {
}
message GraphTopologyUpdate {
    repeated NodeUpdate node_updates = 1;
    repeated ChannelEdgeUpdate channel_updates = 2;
    repeated ClosedChannelUpdate closed_chans = 3;
}
message NodeUpdate {
    /*
    Deprecated, use node_addresses.
    */
    repeated string addresses = 1 [deprecated = true];

    string identity_key = 2;

    /*
    Deprecated, use features.
    */
    bytes global_features = 3 [deprecated = true];

    string alias = 4;
    string color = 5;
    repeated NodeAddress node_addresses = 7;

    /*
    Features that the node has advertised in the init message, node
    announcements and invoices.
    */
    map<uint32, Feature> features = 6;
}
message ChannelEdgeUpdate {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 1 [jstype = JS_STRING];

    ChannelPoint chan_point = 2;

    int64 capacity = 3;

    RoutingPolicy routing_policy = 4;

    string advertising_node = 5;
    string connecting_node = 6;
}
message ClosedChannelUpdate {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 1 [jstype = JS_STRING];
    int64 capacity = 2;
    uint32 closed_height = 3;
    ChannelPoint chan_point = 4;
}
