syntax = "proto3";

import "lnrpc/ln0.proto";
import "lnrpc/ln1.proto";

package lnrpc;

option go_package = "github.com/lightningnetwork/lnd/lnrpc";

/*
 * Comments in this file will be directly parsed into the API
 * Documentation as descriptions of the associated method, message, or field.
 * These descriptions should go right above the definition of the object, and
 * can be in either block or // comment format.
 *
 * An RPC method can be matched to an lncli command by placing a line in the
 * beginning of the description in exactly the following format:
 * lncli: `methodname`
 *
 * Failure to specify the exact name of the command will cause documentation
 * generation to fail.
 *
 * More information on how exactly the gRPC documentation is generated from
 * this proto file can be found here:
 * https://github.com/lightninglabs/lightning-api
 */

// Lightning is the main RPC server of the daemon.
service Lightning {
    /* lncli: `walletbalance`
    WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
    confirmed unspent outputs and all unconfirmed unspent outputs under control
    of the wallet.
    */
    rpc WalletBalance (WalletBalanceRequest) returns (WalletBalanceResponse);

    /* lncli: `channelbalance`
    ChannelBalance returns a report on the total funds across all open channels,
    categorized in local/remote, pending local/remote and unsettled local/remote
    balances.
    */
    rpc ChannelBalance (ChannelBalanceRequest) returns (ChannelBalanceResponse);

    /* lncli: `listchaintxns`
    GetTransactions returns a list describing all the known transactions
    relevant to the wallet.
    */
    rpc GetTransactions (GetTransactionsRequest) returns (TransactionDetails);

    /* lncli: `estimatefee`
    EstimateFee asks the chain backend to estimate the fee rate and total fees
    for a transaction that pays to multiple specified outputs.

    When using REST, the `AddrToAmount` map type can be set by appending
    `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
    map type doesn't appear in the REST API documentation because of a bug in
    the grpc-gateway library.
    */
    rpc EstimateFee (EstimateFeeRequest) returns (EstimateFeeResponse);

    /* lncli: `sendcoins`
    SendCoins executes a request to send coins to a particular address. Unlike
    SendMany, this RPC call only allows creating a single output at a time. If
    neither target_conf, or sat_per_vbyte are set, then the internal wallet will
    consult its fee model to determine a fee for the default confirmation
    target.
    */
    rpc SendCoins (SendCoinsRequest) returns (SendCoinsResponse);

    /* lncli: `listunspent`
    Deprecated, use walletrpc.ListUnspent instead.

    ListUnspent returns a list of all utxos spendable by the wallet with a
    number of confirmations between the specified minimum and maximum.
    */
    rpc ListUnspent (ListUnspentRequest) returns (ListUnspentResponse);

    /*
    SubscribeTransactions creates a uni-directional stream from the server to
    the client in which any newly discovered transactions relevant to the
    wallet are sent over.
    */
    rpc SubscribeTransactions (GetTransactionsRequest)
        returns (stream Transaction);

    /* lncli: `sendmany`
    SendMany handles a request for a transaction that creates multiple specified
    outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
    the internal wallet will consult its fee model to determine a fee for the
    default confirmation target.
    */
    rpc SendMany (SendManyRequest) returns (SendManyResponse);

    /* lncli: `newaddress`
    NewAddress creates a new address under control of the local wallet.
    */
    rpc NewAddress (NewAddressRequest) returns (NewAddressResponse);

    /* lncli: `signmessage`
    SignMessage signs a message with this node's private key. The returned
    signature string is `zbase32` encoded and pubkey recoverable, meaning that
    only the message digest and signature are needed for verification.
    */
    rpc SignMessage (SignMessageRequest) returns (SignMessageResponse);

    /* lncli: `verifymessage`
    VerifyMessage verifies a signature over a msg. The signature must be
    zbase32 encoded and signed by an active node in the resident node's
    channel database. In addition to returning the validity of the signature,
    VerifyMessage also returns the recovered pubkey from the signature.
    */
    rpc VerifyMessage (VerifyMessageRequest) returns (VerifyMessageResponse);

    /* lncli: `connect`
    ConnectPeer attempts to establish a connection to a remote peer. This is at
    the networking level, and is used for communication between nodes. This is
    distinct from establishing a channel with a peer.
    */
    rpc ConnectPeer (ConnectPeerRequest) returns (ConnectPeerResponse);

    /* lncli: `disconnect`
    DisconnectPeer attempts to disconnect one peer from another identified by a
    given pubKey. In the case that we currently have a pending or active channel
    with the target peer, then this action will be not be allowed.
    */
    rpc DisconnectPeer (DisconnectPeerRequest) returns (DisconnectPeerResponse);

    /* lncli: `listpeers`
    ListPeers returns a verbose listing of all currently active peers.
    */
    rpc ListPeers (ListPeersRequest) returns (ListPeersResponse);

    /*
    SubscribePeerEvents creates a uni-directional stream from the server to
    the client in which any events relevant to the state of peers are sent
    over. Events include peers going online and offline.
    */
    rpc SubscribePeerEvents (PeerEventSubscription) returns (stream PeerEvent);

    /* lncli: `getinfo`
    GetInfo returns general information concerning the lightning node including
    it's identity pubkey, alias, the chains it is connected to, and information
    concerning the number of open+pending channels.
    */
    rpc GetInfo (GetInfoRequest) returns (GetInfoResponse);

    /** lncli: `getrecoveryinfo`
    GetRecoveryInfo returns information concerning the recovery mode including
    whether it's in a recovery mode, whether the recovery is finished, and the
    progress made so far.
    */
    rpc GetRecoveryInfo (GetRecoveryInfoRequest)
        returns (GetRecoveryInfoResponse);

    // TODO(roasbeef): merge with below with bool?
    /* lncli: `pendingchannels`
    PendingChannels returns a list of all the channels that are currently
    considered "pending". A channel is pending if it has finished the funding
    workflow and is waiting for confirmations for the funding txn, or is in the
    process of closure, either initiated cooperatively or non-cooperatively.
    */
    rpc PendingChannels (PendingChannelsRequest)
        returns (PendingChannelsResponse);

    /* lncli: `listchannels`
    ListChannels returns a description of all the open channels that this node
    is a participant in.
    */
    rpc ListChannels (ListChannelsRequest) returns (ListChannelsResponse);

    /*
    SubscribeChannelEvents creates a uni-directional stream from the server to
    the client in which any updates relevant to the state of the channels are
    sent over. Events include new active channels, inactive channels, and closed
    channels.
    */
    rpc SubscribeChannelEvents (ChannelEventSubscription)
        returns (stream ChannelEventUpdate);

    /* lncli: `closedchannels`
    ClosedChannels returns a description of all the closed channels that
    this node was a participant in.
    */
    rpc ClosedChannels (ClosedChannelsRequest) returns (ClosedChannelsResponse);

    /*
    OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
    call is meant to be consumed by clients to the REST proxy. As with all
    other sync calls, all byte slices are intended to be populated as hex
    encoded strings.
    */
    rpc OpenChannelSync (OpenChannelRequest) returns (ChannelPoint);

    /* lncli: `openchannel`
    OpenChannel attempts to open a singly funded channel specified in the
    request to a remote peer. Users are able to specify a target number of
    blocks that the funding transaction should be confirmed in, or a manual fee
    rate to us for the funding transaction. If neither are specified, then a
    lax block confirmation target is used. Each OpenStatusUpdate will return
    the pending channel ID of the in-progress channel. Depending on the
    arguments specified in the OpenChannelRequest, this pending channel ID can
    then be used to manually progress the channel funding flow.
    */
    rpc OpenChannel (OpenChannelRequest) returns (stream OpenStatusUpdate);

    /* lncli: `batchopenchannel`
    BatchOpenChannel attempts to open multiple single-funded channels in a
    single transaction in an atomic way. This means either all channel open
    requests succeed at once or all attempts are aborted if any of them fail.
    This is the safer variant of using PSBTs to manually fund a batch of
    channels through the OpenChannel RPC.
    */
    rpc BatchOpenChannel (BatchOpenChannelRequest)
        returns (BatchOpenChannelResponse);

    /*
    FundingStateStep is an advanced funding related call that allows the caller
    to either execute some preparatory steps for a funding workflow, or
    manually progress a funding workflow. The primary way a funding flow is
    identified is via its pending channel ID. As an example, this method can be
    used to specify that we're expecting a funding flow for a particular
    pending channel ID, for which we need to use specific parameters.
    Alternatively, this can be used to interactively drive PSBT signing for
    funding for partially complete funding transactions.
    */
    rpc FundingStateStep (FundingTransitionMsg) returns (FundingStateStepResp);

    /*
    ChannelAcceptor dispatches a bi-directional streaming RPC in which
    OpenChannel requests are sent to the client and the client responds with
    a boolean that tells LND whether or not to accept the channel. This allows
    node operators to specify their own criteria for accepting inbound channels
    through a single persistent connection.
    */
    rpc ChannelAcceptor (stream ChannelAcceptResponse)
        returns (stream ChannelAcceptRequest);

    /* lncli: `closechannel`
    CloseChannel attempts to close an active channel identified by its channel
    outpoint (ChannelPoint). The actions of this method can additionally be
    augmented to attempt a force close after a timeout period in the case of an
    inactive peer. If a non-force close (cooperative closure) is requested,
    then the user can specify either a target number of blocks until the
    closure transaction is confirmed, or a manual fee rate. If neither are
    specified, then a default lax, block confirmation target is used.
    */
    rpc CloseChannel (CloseChannelRequest) returns (stream CloseStatusUpdate);

    /* lncli: `abandonchannel`
    AbandonChannel removes all channel state from the database except for a
    close summary. This method can be used to get rid of permanently unusable
    channels due to bugs fixed in newer versions of lnd. This method can also be
    used to remove externally funded channels where the funding transaction was
    never broadcast. Only available for non-externally funded channels in dev
    build.
    */
    rpc AbandonChannel (AbandonChannelRequest) returns (AbandonChannelResponse);

    /* lncli: `sendpayment`
    Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
    bi-directional streaming RPC for sending payments through the Lightning
    Network. A single RPC invocation creates a persistent bi-directional
    stream allowing clients to rapidly send payments through the Lightning
    Network with a single persistent connection.
    */
    rpc SendPayment (stream SendRequest) returns (stream SendResponse) {
        option deprecated = true;
    }

    /*
    SendPaymentSync is the synchronous non-streaming version of SendPayment.
    This RPC is intended to be consumed by clients of the REST proxy.
    Additionally, this RPC expects the destination's public key and the payment
    hash (if any) to be encoded as hex strings.
    */
    rpc SendPaymentSync (SendRequest) returns (SendResponse);

    /* lncli: `sendtoroute`
    Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
    streaming RPC for sending payment through the Lightning Network. This
    method differs from SendPayment in that it allows users to specify a full
    route manually. This can be used for things like rebalancing, and atomic
    swaps.
    */
    rpc SendToRoute (stream SendToRouteRequest) returns (stream SendResponse) {
        option deprecated = true;
    }

    /*
    SendToRouteSync is a synchronous version of SendToRoute. It Will block
    until the payment either fails or succeeds.
    */
    rpc SendToRouteSync (SendToRouteRequest) returns (SendResponse);

    /* lncli: `addinvoice`
    AddInvoice attempts to add a new invoice to the invoice database. Any
    duplicated invoices are rejected, therefore all invoices *must* have a
    unique payment preimage.
    */
    rpc AddInvoice (Invoice) returns (AddInvoiceResponse);

    /* lncli: `listinvoices`
    ListInvoices returns a list of all the invoices currently stored within the
    database. Any active debug invoices are ignored. It has full support for
    paginated responses, allowing users to query for specific invoices through
    their add_index. This can be done by using either the first_index_offset or
    last_index_offset fields included in the response as the index_offset of the
    next request. By default, the first 100 invoices created will be returned.
    Backwards pagination is also supported through the Reversed flag.
    */
    rpc ListInvoices (ListInvoiceRequest) returns (ListInvoiceResponse);

    /* lncli: `lookupinvoice`
    LookupInvoice attempts to look up an invoice according to its payment hash.
    The passed payment hash *must* be exactly 32 bytes, if not, an error is
    returned.
    */
    rpc LookupInvoice (PaymentHash) returns (Invoice);

    /*
    SubscribeInvoices returns a uni-directional stream (server -> client) for
    notifying the client of newly added/settled invoices. The caller can
    optionally specify the add_index and/or the settle_index. If the add_index
    is specified, then we'll first start by sending add invoice events for all
    invoices with an add_index greater than the specified value. If the
    settle_index is specified, the next, we'll send out all settle events for
    invoices with a settle_index greater than the specified value. One or both
    of these fields can be set. If no fields are set, then we'll only send out
    the latest add/settle events.
    */
    rpc SubscribeInvoices (InvoiceSubscription) returns (stream Invoice);

    /* lncli: `decodepayreq`
    DecodePayReq takes an encoded payment request string and attempts to decode
    it, returning a full description of the conditions encoded within the
    payment request.
    */
    rpc DecodePayReq (PayReqString) returns (PayReq);

    /* lncli: `listpayments`
    ListPayments returns a list of all outgoing payments.
    */
    rpc ListPayments (ListPaymentsRequest) returns (ListPaymentsResponse);

    /*
    DeletePayment deletes an outgoing payment from DB. Note that it will not
    attempt to delete an In-Flight payment, since that would be unsafe.
    */
    rpc DeletePayment (DeletePaymentRequest) returns (DeletePaymentResponse);

    /*
    DeleteAllPayments deletes all outgoing payments from DB. Note that it will
    not attempt to delete In-Flight payments, since that would be unsafe.
    */
    rpc DeleteAllPayments (DeleteAllPaymentsRequest)
        returns (DeleteAllPaymentsResponse);

    /* lncli: `describegraph`
    DescribeGraph returns a description of the latest graph state from the
    point of view of the node. The graph information is partitioned into two
    components: all the nodes/vertexes, and all the edges that connect the
    vertexes themselves. As this is a directed graph, the edges also contain
    the node directional specific routing policy which includes: the time lock
    delta, fee information, etc.
    */
    rpc DescribeGraph (ChannelGraphRequest) returns (ChannelGraph);

    /* lncli: `getnodemetrics`
    GetNodeMetrics returns node metrics calculated from the graph. Currently
    the only supported metric is betweenness centrality of individual nodes.
    */
    rpc GetNodeMetrics (NodeMetricsRequest) returns (NodeMetricsResponse);

    /* lncli: `getchaninfo`
    GetChanInfo returns the latest authenticated network announcement for the
    given channel identified by its channel ID: an 8-byte integer which
    uniquely identifies the location of transaction's funding output within the
    blockchain.
    */
    rpc GetChanInfo (ChanInfoRequest) returns (ChannelEdge);

    /* lncli: `getnodeinfo`
    GetNodeInfo returns the latest advertised, aggregated, and authenticated
    channel information for the specified node identified by its public key.
    */
    rpc GetNodeInfo (NodeInfoRequest) returns (NodeInfo);

    /* lncli: `queryroutes`
    QueryRoutes attempts to query the daemon's Channel Router for a possible
    route to a target destination capable of carrying a specific amount of
    satoshis. The returned route contains the full details required to craft and
    send an HTLC, also including the necessary information that should be
    present within the Sphinx packet encapsulated within the HTLC.

    When using REST, the `dest_custom_records` map type can be set by appending
    `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
    to the URL. Unfortunately this map type doesn't appear in the REST API
    documentation because of a bug in the grpc-gateway library.
    */
    rpc QueryRoutes (QueryRoutesRequest) returns (QueryRoutesResponse);

    /* lncli: `getnetworkinfo`
    GetNetworkInfo returns some basic stats about the known channel graph from
    the point of view of the node.
    */
    rpc GetNetworkInfo (NetworkInfoRequest) returns (NetworkInfo);

    /* lncli: `stop`
    StopDaemon will send a shutdown request to the interrupt handler, triggering
    a graceful shutdown of the daemon.
    */
    rpc StopDaemon (StopRequest) returns (StopResponse);

    /*
    SubscribeChannelGraph launches a streaming RPC that allows the caller to
    receive notifications upon any changes to the channel graph topology from
    the point of view of the responding node. Events notified include: new
    nodes coming online, nodes updating their authenticated attributes, new
    channels being advertised, updates in the routing policy for a directional
    channel edge, and when channels are closed on-chain.
    */
    rpc SubscribeChannelGraph (GraphTopologySubscription)
        returns (stream GraphTopologyUpdate);

    /* lncli: `debuglevel`
    DebugLevel allows a caller to programmatically set the logging verbosity of
    lnd. The logging can be targeted according to a coarse daemon-wide logging
    level, or in a granular fashion to specify the logging for a target
    sub-system.
    */
    rpc DebugLevel (DebugLevelRequest) returns (DebugLevelResponse);

    /* lncli: `feereport`
    FeeReport allows the caller to obtain a report detailing the current fee
    schedule enforced by the node globally for each channel.
    */
    rpc FeeReport (FeeReportRequest) returns (FeeReportResponse);

    /* lncli: `updatechanpolicy`
    UpdateChannelPolicy allows the caller to update the fee schedule and
    channel policies for all channels globally, or a particular channel.
    */
    rpc UpdateChannelPolicy (PolicyUpdateRequest)
        returns (PolicyUpdateResponse);

    /* lncli: `fwdinghistory`
    ForwardingHistory allows the caller to query the htlcswitch for a record of
    all HTLCs forwarded within the target time range, and integer offset
    within that time range, for a maximum number of events. If no maximum number
    of events is specified, up to 100 events will be returned. If no time-range
    is specified, then events will be returned in the order that they occured.

    A list of forwarding events are returned. The size of each forwarding event
    is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
    As a result each message can only contain 50k entries. Each response has
    the index offset of the last entry. The index offset can be provided to the
    request to allow the caller to skip a series of records.
    */
    rpc ForwardingHistory (ForwardingHistoryRequest)
        returns (ForwardingHistoryResponse);

    /* lncli: `exportchanbackup`
    ExportChannelBackup attempts to return an encrypted static channel backup
    for the target channel identified by it channel point. The backup is
    encrypted with a key generated from the aezeed seed of the user. The
    returned backup can either be restored using the RestoreChannelBackup
    method once lnd is running, or via the InitWallet and UnlockWallet methods
    from the WalletUnlocker service.
    */
    rpc ExportChannelBackup (ExportChannelBackupRequest)
        returns (ChannelBackup);

    /*
    ExportAllChannelBackups returns static channel backups for all existing
    channels known to lnd. A set of regular singular static channel backups for
    each channel are returned. Additionally, a multi-channel backup is returned
    as well, which contains a single encrypted blob containing the backups of
    each channel.
    */
    rpc ExportAllChannelBackups (ChanBackupExportRequest)
        returns (ChanBackupSnapshot);

    /*
    VerifyChanBackup allows a caller to verify the integrity of a channel backup
    snapshot. This method will accept either a packed Single or a packed Multi.
    Specifying both will result in an error.
    */
    rpc VerifyChanBackup (ChanBackupSnapshot)
        returns (VerifyChanBackupResponse);

    /* lncli: `restorechanbackup`
    RestoreChannelBackups accepts a set of singular channel backups, or a
    single encrypted multi-chan backup and attempts to recover any funds
    remaining within the channel. If we are able to unpack the backup, then the
    new channel will be shown under listchannels, as well as pending channels.
    */
    rpc RestoreChannelBackups (RestoreChanBackupRequest)
        returns (RestoreBackupResponse);

    /*
    SubscribeChannelBackups allows a client to sub-subscribe to the most up to
    date information concerning the state of all channel backups. Each time a
    new channel is added, we return the new set of channels, along with a
    multi-chan backup containing the backup info for all channels. Each time a
    channel is closed, we send a new update, which contains new new chan back
    ups, but the updated set of encrypted multi-chan backups with the closed
    channel(s) removed.
    */
    rpc SubscribeChannelBackups (ChannelBackupSubscription)
        returns (stream ChanBackupSnapshot);

    /* lncli: `bakemacaroon`
    BakeMacaroon allows the creation of a new macaroon with custom read and
    write permissions. No first-party caveats are added since this can be done
    offline.
    */
    rpc BakeMacaroon (BakeMacaroonRequest) returns (BakeMacaroonResponse);

    /* lncli: `listmacaroonids`
    ListMacaroonIDs returns all root key IDs that are in use.
    */
    rpc ListMacaroonIDs (ListMacaroonIDsRequest)
        returns (ListMacaroonIDsResponse);

    /* lncli: `deletemacaroonid`
    DeleteMacaroonID deletes the specified macaroon ID and invalidates all
    macaroons derived from that ID.
    */
    rpc DeleteMacaroonID (DeleteMacaroonIDRequest)
        returns (DeleteMacaroonIDResponse);

    /* lncli: `listpermissions`
    ListPermissions lists all RPC method URIs and their required macaroon
    permissions to access them.
    */
    rpc ListPermissions (ListPermissionsRequest)
        returns (ListPermissionsResponse);

    /*
    CheckMacaroonPermissions checks whether a request follows the constraints
    imposed on the macaroon and that the macaroon is authorized to follow the
    provided permissions.
    */
    rpc CheckMacaroonPermissions (CheckMacPermRequest)
        returns (CheckMacPermResponse);

    /*
    RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
    gRPC middleware is software component external to lnd that aims to add
    additional business logic to lnd by observing/intercepting/validating
    incoming gRPC client requests and (if needed) replacing/overwriting outgoing
    messages before they're sent to the client. When registering the middleware
    must identify itself and indicate what custom macaroon caveats it wants to
    be responsible for. Only requests that contain a macaroon with that specific
    custom caveat are then sent to the middleware for inspection. The other
    option is to register for the read-only mode in which all requests/responses
    are forwarded for interception to the middleware but the middleware is not
    allowed to modify any responses. As a security measure, _no_ middleware can
    modify responses for requests made with _unencumbered_ macaroons!
    */
    rpc RegisterRPCMiddleware (stream RPCMiddlewareResponse)
        returns (stream RPCMiddlewareRequest);

    /* lncli: `sendcustom`
    SendCustomMessage sends a custom peer message.
    */
    rpc SendCustomMessage (SendCustomMessageRequest)
        returns (SendCustomMessageResponse);

    /* lncli: `subscribecustom`
    SubscribeCustomMessages subscribes to a stream of incoming custom peer
    messages.
    */
    rpc SubscribeCustomMessages (SubscribeCustomMessagesRequest)
        returns (stream CustomMessage);
}

message SubscribeCustomMessagesRequest {
}

message CustomMessage {
    // Peer from which the message originates
    bytes peer = 1;

    // Message type. This value will be in the custom range (>= 32768).
    uint32 type = 2;

    // Raw message data
    bytes data = 3;
}

message SendCustomMessageRequest {
    // Peer to send the message to
    bytes peer = 1;

    // Message type. This value needs to be in the custom range (>= 32768).
    uint32 type = 2;

    // Raw message data.
    bytes data = 3;
}

message SendCustomMessageResponse {
}

message Utxo {
    // The type of address
    AddressType address_type = 1;

    // The address
    string address = 2;

    // The value of the unspent coin in satoshis
    int64 amount_sat = 3;

    // The pkscript in hex
    string pk_script = 4;

    // The outpoint in format txid:n
    OutPoint outpoint = 5;

    // The number of confirmations for the Utxo
    int64 confirmations = 6;
}

message Transaction {
    // The transaction hash
    string tx_hash = 1;

    // The transaction amount, denominated in satoshis
    int64 amount = 2;

    // The number of confirmations
    int32 num_confirmations = 3;

    // The hash of the block this transaction was included in
    string block_hash = 4;

    // The height of the block this transaction was included in
    int32 block_height = 5;

    // Timestamp of this transaction
    int64 time_stamp = 6;

    // Fees paid for this transaction
    int64 total_fees = 7;

    // Addresses that received funds for this transaction
    repeated string dest_addresses = 8;

    // The raw transaction hex.
    string raw_tx_hex = 9;

    // A label that was optionally set on transaction broadcast.
    string label = 10;
}
message GetTransactionsRequest {
    /*
    The height from which to list transactions, inclusive. If this value is
    greater than end_height, transactions will be read in reverse.
    */
    int32 start_height = 1;

    /*
    The height until which to list transactions, inclusive. To include
    unconfirmed transactions, this value should be set to -1, which will
    return transactions from start_height until the current chain tip and
    unconfirmed transactions. If no end_height is provided, the call will
    default to this option.
    */
    int32 end_height = 2;

    // An optional filter to only include transactions relevant to an account.
    string account = 3;
}

message TransactionDetails {
    // The list of transactions relevant to the wallet.
    repeated Transaction transactions = 1;
}

message SendRequest {
    /*
    The identity pubkey of the payment recipient. When using REST, this field
    must be encoded as base64.
    */
    bytes dest = 1;

    /*
    The hex-encoded identity pubkey of the payment recipient. Deprecated now
    that the REST gateway supports base64 encoding of bytes fields.
    */
    string dest_string = 2 [deprecated = true];

    /*
    The amount to send expressed in satoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt = 3;

    /*
    The amount to send expressed in millisatoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt_msat = 12;

    /*
    The hash to use within the payment's HTLC. When using REST, this field
    must be encoded as base64.
    */
    bytes payment_hash = 4;

    /*
    The hex-encoded hash to use within the payment's HTLC. Deprecated now
    that the REST gateway supports base64 encoding of bytes fields.
    */
    string payment_hash_string = 5 [deprecated = true];

    /*
    A bare-bones invoice for a payment within the Lightning Network. With the
    details of the invoice, the sender has all the data necessary to send a
    payment to the recipient.
    */
    string payment_request = 6;

    /*
    The CLTV delta from the current height that should be used to set the
    timelock for the final hop.
    */
    int32 final_cltv_delta = 7;

    /*
    The maximum number of satoshis that will be paid as a fee of the payment.
    This value can be represented either as a percentage of the amount being
    sent, or as a fixed amount of the maximum fee the user is willing the pay to
    send the payment.
    */
    FeeLimit fee_limit = 8;

    /*
    The channel id of the channel that must be taken to the first hop. If zero,
    any channel may be used.
    */
    uint64 outgoing_chan_id = 9 [jstype = JS_STRING];

    /*
    The pubkey of the last hop of the route. If empty, any hop may be used.
    */
    bytes last_hop_pubkey = 13;

    /*
    An optional maximum total time lock for the route. This should not exceed
    lnd's `--max-cltv-expiry` setting. If zero, then the value of
    `--max-cltv-expiry` is enforced.
    */
    uint32 cltv_limit = 10;

    /*
    An optional field that can be used to pass an arbitrary set of TLV records
    to a peer which understands the new records. This can be used to pass
    application specific data during the payment attempt. Record types are
    required to be in the custom range >= 65536. When using REST, the values
    must be encoded as base64.
    */
    map<uint64, bytes> dest_custom_records = 11;

    // If set, circular payments to self are permitted.
    bool allow_self_payment = 14;

    /*
    Features assumed to be supported by the final node. All transitive feature
    dependencies must also be set properly. For a given feature bit pair, either
    optional or remote may be set, but not both. If this field is nil or empty,
    the router will try to load destination features from the graph as a
    fallback.
    */
    repeated FeatureBit dest_features = 15;

    /*
    The payment address of the generated invoice.
    */
    bytes payment_addr = 16;
}

message SendResponse {
    string payment_error = 1;
    bytes payment_preimage = 2;
    Route payment_route = 3;
    bytes payment_hash = 4;
}

message SendToRouteRequest {
    /*
    The payment hash to use for the HTLC. When using REST, this field must be
    encoded as base64.
    */
    bytes payment_hash = 1;

    /*
    An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
    that the REST gateway supports base64 encoding of bytes fields.
    */
    string payment_hash_string = 2 [deprecated = true];

    reserved 3;

    // Route that should be used to attempt to complete the payment.
    Route route = 4;
}

message ChannelAcceptRequest {
    // The pubkey of the node that wishes to open an inbound channel.
    bytes node_pubkey = 1;

    // The hash of the genesis block that the proposed channel resides in.
    bytes chain_hash = 2;

    // The pending channel id.
    bytes pending_chan_id = 3;

    // The funding amount in satoshis that initiator wishes to use in the
    // channel.
    uint64 funding_amt = 4;

    // The push amount of the proposed channel in millisatoshis.
    uint64 push_amt = 5;

    // The dust limit of the initiator's commitment tx.
    uint64 dust_limit = 6;

    // The maximum amount of coins in millisatoshis that can be pending in this
    // channel.
    uint64 max_value_in_flight = 7;

    // The minimum amount of satoshis the initiator requires us to have at all
    // times.
    uint64 channel_reserve = 8;

    // The smallest HTLC in millisatoshis that the initiator will accept.
    uint64 min_htlc = 9;

    // The initial fee rate that the initiator suggests for both commitment
    // transactions.
    uint64 fee_per_kw = 10;

    /*
    The number of blocks to use for the relative time lock in the pay-to-self
    output of both commitment transactions.
    */
    uint32 csv_delay = 11;

    // The total number of incoming HTLC's that the initiator will accept.
    uint32 max_accepted_htlcs = 12;

    // A bit-field which the initiator uses to specify proposed channel
    // behavior.
    uint32 channel_flags = 13;

    // The commitment type the initiator wishes to use for the proposed channel.
    CommitmentType commitment_type = 14;
}

message ChannelAcceptResponse {
    // Whether or not the client accepts the channel.
    bool accept = 1;

    // The pending channel id to which this response applies.
    bytes pending_chan_id = 2;

    /*
    An optional error to send the initiating party to indicate why the channel
    was rejected. This field *should not* contain sensitive information, it will
    be sent to the initiating party. This field should only be set if accept is
    false, the channel will be rejected if an error is set with accept=true
    because the meaning of this response is ambiguous. Limited to 500
    characters.
    */
    string error = 3;

    /*
    The upfront shutdown address to use if the initiating peer supports option
    upfront shutdown script (see ListPeers for the features supported). Note
    that the channel open will fail if this value is set for a peer that does
    not support this feature bit.
    */
    string upfront_shutdown = 4;

    /*
    The csv delay (in blocks) that we require for the remote party.
    */
    uint32 csv_delay = 5;

    /*
    The reserve amount in satoshis that we require the remote peer to adhere to.
    We require that the remote peer always have some reserve amount allocated to
    them so that there is always a disincentive to broadcast old state (if they
    hold 0 sats on their side of the channel, there is nothing to lose).
    */
    uint64 reserve_sat = 6;

    /*
    The maximum amount of funds in millisatoshis that we allow the remote peer
    to have in outstanding htlcs.
    */
    uint64 in_flight_max_msat = 7;

    /*
    The maximum number of htlcs that the remote peer can offer us.
    */
    uint32 max_htlc_count = 8;

    /*
    The minimum value in millisatoshis for incoming htlcs on the channel.
    */
    uint64 min_htlc_in = 9;

    /*
    The number of confirmations we require before we consider the channel open.
    */
    uint32 min_accept_depth = 10;
}

message LightningAddress {
    // The identity pubkey of the Lightning node
    string pubkey = 1;

    // The network location of the lightning node, e.g. `69.69.69.69:1337` or
    // `localhost:10011`
    string host = 2;
}

message EstimateFeeRequest {
    // The map from addresses to amounts for the transaction.
    map<string, int64> AddrToAmount = 1;

    // The target number of blocks that this transaction should be confirmed
    // by.
    int32 target_conf = 2;

    // The minimum number of confirmations each one of your outputs used for
    // the transaction must satisfy.
    int32 min_confs = 3;

    // Whether unconfirmed outputs should be used as inputs for the transaction.
    bool spend_unconfirmed = 4;
}

message EstimateFeeResponse {
    // The total fee in satoshis.
    int64 fee_sat = 1;

    // Deprecated, use sat_per_vbyte.
    // The fee rate in satoshi/vbyte.
    int64 feerate_sat_per_byte = 2 [deprecated = true];

    // The fee rate in satoshi/vbyte.
    uint64 sat_per_vbyte = 3;
}

message SendManyRequest {
    // The map from addresses to amounts
    map<string, int64> AddrToAmount = 1;

    // The target number of blocks that this transaction should be confirmed
    // by.
    int32 target_conf = 3;

    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // transaction.
    uint64 sat_per_vbyte = 4;

    // Deprecated, use sat_per_vbyte.
    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // transaction.
    int64 sat_per_byte = 5 [deprecated = true];

    // An optional label for the transaction, limited to 500 characters.
    string label = 6;

    // The minimum number of confirmations each one of your outputs used for
    // the transaction must satisfy.
    int32 min_confs = 7;

    // Whether unconfirmed outputs should be used as inputs for the transaction.
    bool spend_unconfirmed = 8;
}
message SendManyResponse {
    // The id of the transaction
    string txid = 1;
}

message SendCoinsRequest {
    // The address to send coins to
    string addr = 1;

    // The amount in satoshis to send
    int64 amount = 2;

    // The target number of blocks that this transaction should be confirmed
    // by.
    int32 target_conf = 3;

    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // transaction.
    uint64 sat_per_vbyte = 4;

    // Deprecated, use sat_per_vbyte.
    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // transaction.
    int64 sat_per_byte = 5 [deprecated = true];

    /*
    If set, then the amount field will be ignored, and lnd will attempt to
    send all the coins under control of the internal wallet to the specified
    address.
    */
    bool send_all = 6;

    // An optional label for the transaction, limited to 500 characters.
    string label = 7;

    // The minimum number of confirmations each one of your outputs used for
    // the transaction must satisfy.
    int32 min_confs = 8;

    // Whether unconfirmed outputs should be used as inputs for the transaction.
    bool spend_unconfirmed = 9;
}
message SendCoinsResponse {
    // The transaction ID of the transaction
    string txid = 1;
}

message ListUnspentRequest {
    // The minimum number of confirmations to be included.
    int32 min_confs = 1;

    // The maximum number of confirmations to be included.
    int32 max_confs = 2;

    // An optional filter to only include outputs belonging to an account.
    string account = 3;
}
message ListUnspentResponse {
    // A list of utxos
    repeated Utxo utxos = 1;
}

/*
`AddressType` has to be one of:

- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
*/
enum AddressType {
    WITNESS_PUBKEY_HASH = 0;
    NESTED_PUBKEY_HASH = 1;
    UNUSED_WITNESS_PUBKEY_HASH = 2;
    UNUSED_NESTED_PUBKEY_HASH = 3;
}

message NewAddressRequest {
    // The type of address to generate.
    AddressType type = 1;

    /*
    The name of the account to generate a new address for. If empty, the
    default wallet account is used.
    */
    string account = 2;
}
message NewAddressResponse {
    // The newly generated wallet address
    string address = 1;
}

message SignMessageRequest {
    /*
    The message to be signed. When using REST, this field must be encoded as
    base64.
    */
    bytes msg = 1;

    /*
    Instead of the default double-SHA256 hashing of the message before signing,
    only use one round of hashing instead.
    */
    bool single_hash = 2;
}
message SignMessageResponse {
    // The signature for the given message
    string signature = 1;
}

message VerifyMessageRequest {
    /*
    The message over which the signature is to be verified. When using REST,
    this field must be encoded as base64.
    */
    bytes msg = 1;

    // The signature to be verified over the given message
    string signature = 2;
}
message VerifyMessageResponse {
    // Whether the signature was valid over the given message
    bool valid = 1;

    // The pubkey recovered from the signature
    string pubkey = 2;
}

message ConnectPeerRequest {
    // Lightning address of the peer, in the format `<pubkey>@host`
    LightningAddress addr = 1;

    /* If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous. */
    bool perm = 2;

    /*
    The connection timeout value (in seconds) for this request. It won't affect
    other requests.
    */
    uint64 timeout = 3;
}
message ConnectPeerResponse {
}

message DisconnectPeerRequest {
    // The pubkey of the node to disconnect from
    string pub_key = 1;
}
message DisconnectPeerResponse {
}

message ListChannelsRequest {
    bool active_only = 1;
    bool inactive_only = 2;
    bool public_only = 3;
    bool private_only = 4;

    /*
    Filters the response for channels with a target peer's pubkey. If peer is
    empty, all channels will be returned.
    */
    bytes peer = 5;
}
message ListChannelsResponse {
    // The list of active channels
    repeated Channel channels = 11;
}

message ClosedChannelsRequest {
    bool cooperative = 1;
    bool local_force = 2;
    bool remote_force = 3;
    bool breach = 4;
    bool funding_canceled = 5;
    bool abandoned = 6;
}

message ClosedChannelsResponse {
    repeated ChannelCloseSummary channels = 1;
}

message Peer {
    // The identity pubkey of the peer
    string pub_key = 1;

    // Network address of the peer; eg `127.0.0.1:10011`
    string address = 3;

    // Bytes of data transmitted to this peer
    uint64 bytes_sent = 4;

    // Bytes of data transmitted from this peer
    uint64 bytes_recv = 5;

    // Satoshis sent to this peer
    int64 sat_sent = 6;

    // Satoshis received from this peer
    int64 sat_recv = 7;

    // A channel is inbound if the counterparty initiated the channel
    bool inbound = 8;

    // Ping time to this peer
    int64 ping_time = 9;

    enum SyncType {
        /*
        Denotes that we cannot determine the peer's current sync type.
        */
        UNKNOWN_SYNC = 0;

        /*
        Denotes that we are actively receiving new graph updates from the peer.
        */
        ACTIVE_SYNC = 1;

        /*
        Denotes that we are not receiving new graph updates from the peer.
        */
        PASSIVE_SYNC = 2;

        /*
        Denotes that this peer is pinned into an active sync.
        */
        PINNED_SYNC = 3;
    }

    // The type of sync we are currently performing with this peer.
    SyncType sync_type = 10;

    // Features advertised by the remote peer in their init message.
    map<uint32, Feature> features = 11;

    /*
    The latest errors received from our peer with timestamps, limited to the 10
    most recent errors. These errors are tracked across peer connections, but
    are not persisted across lnd restarts. Note that these errors are only
    stored for peers that we have channels open with, to prevent peers from
    spamming us with errors at no cost.
    */
    repeated TimestampedError errors = 12;

    /*
    The number of times we have recorded this peer going offline or coming
    online, recorded across restarts. Note that this value is decreased over
    time if the peer has not recently flapped, so that we can forgive peers
    with historically high flap counts.
    */
    int32 flap_count = 13;

    /*
    The timestamp of the last flap we observed for this peer. If this value is
    zero, we have not observed any flaps for this peer.
    */
    int64 last_flap_ns = 14;

    /*
    The last ping payload the peer has sent to us.
    */
    bytes last_ping_payload = 15;
}

message TimestampedError {
    // The unix timestamp in seconds when the error occurred.
    uint64 timestamp = 1;

    // The string representation of the error sent by our peer.
    string error = 2;
}

message ListPeersRequest {
    /*
    If true, only the last error that our peer sent us will be returned with
    the peer's information, rather than the full set of historic errors we have
    stored.
    */
    bool latest_error = 1;
}
message ListPeersResponse {
    // The list of currently connected peers
    repeated Peer peers = 1;
}

message PeerEventSubscription {
}

message PeerEvent {
    // The identity pubkey of the peer.
    string pub_key = 1;

    enum EventType {
        PEER_ONLINE = 0;
        PEER_OFFLINE = 1;
    }

    EventType type = 2;
}

message GetInfoRequest {
}
message GetInfoResponse {
    // The version of the LND software that the node is running.
    string version = 14;

    // The SHA1 commit hash that the daemon is compiled with.
    string commit_hash = 20;

    // The identity pubkey of the current node.
    string identity_pubkey = 1;

    // If applicable, the alias of the current node, e.g. "bob"
    string alias = 2;

    // The color of the current node in hex code format
    string color = 17;

    // Number of pending channels
    uint32 num_pending_channels = 3;

    // Number of active channels
    uint32 num_active_channels = 4;

    // Number of inactive channels
    uint32 num_inactive_channels = 15;

    // Number of peers
    uint32 num_peers = 5;

    // The node's current view of the height of the best block
    uint32 block_height = 6;

    // The node's current view of the hash of the best block
    string block_hash = 8;

    // Timestamp of the block best known to the wallet
    int64 best_header_timestamp = 13;

    // Whether the wallet's view is synced to the main chain
    bool synced_to_chain = 9;

    // Whether we consider ourselves synced with the public channel graph.
    bool synced_to_graph = 18;

    /*
    Whether the current node is connected to testnet. This field is
    deprecated and the network field should be used instead
    **/
    bool testnet = 10 [deprecated = true];

    reserved 11;

    // A list of active chains the node is connected to
    repeated Chain chains = 16;

    // The URIs of the current node.
    repeated string uris = 12;

    /*
    Features that our node has advertised in our init message, node
    announcements and invoices.
    */
    map<uint32, Feature> features = 19;
}

message GetRecoveryInfoRequest {
}
message GetRecoveryInfoResponse {
    // Whether the wallet is in recovery mode
    bool recovery_mode = 1;

    // Whether the wallet recovery progress is finished
    bool recovery_finished = 2;

    // The recovery progress, ranging from 0 to 1.
    double progress = 3;
}

message Chain {
    // The blockchain the node is on (eg bitcoin, litecoin)
    string chain = 1;

    // The network the node is on (eg regtest, testnet, mainnet)
    string network = 2;
}

message ConfirmationUpdate {
    bytes block_sha = 1;
    int32 block_height = 2;

    uint32 num_confs_left = 3;
}

message ChannelOpenUpdate {
    ChannelPoint channel_point = 1;
}

message ChannelCloseUpdate {
    bytes closing_txid = 1;

    bool success = 2;
}

message CloseChannelRequest {
    /*
    The outpoint (txid:index) of the funding transaction. With this value, Bob
    will be able to generate a signature for Alice's version of the commitment
    transaction.
    */
    ChannelPoint channel_point = 1;

    // If true, then the channel will be closed forcibly. This means the
    // current commitment transaction will be signed and broadcast.
    bool force = 2;

    // The target number of blocks that the closure transaction should be
    // confirmed by.
    int32 target_conf = 3;

    // Deprecated, use sat_per_vbyte.
    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // closure transaction.
    int64 sat_per_byte = 4 [deprecated = true];

    /*
    An optional address to send funds to in the case of a cooperative close.
    If the channel was opened with an upfront shutdown script and this field
    is set, the request to close will fail because the channel must pay out
    to the upfront shutdown addresss.
    */
    string delivery_address = 5;

    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // closure transaction.
    uint64 sat_per_vbyte = 6;
}

message CloseStatusUpdate {
    oneof update {
        PendingUpdate close_pending = 1;
        ChannelCloseUpdate chan_close = 3;
    }
}

message ReadyForPsbtFunding {
    /*
    The P2WSH address of the channel funding multisig address that the below
    specified amount in satoshis needs to be sent to.
    */
    string funding_address = 1;

    /*
    The exact amount in satoshis that needs to be sent to the above address to
    fund the pending channel.
    */
    int64 funding_amount = 2;

    /*
    A raw PSBT that contains the pending channel output. If a base PSBT was
    provided in the PsbtShim, this is the base PSBT with one additional output.
    If no base PSBT was specified, this is an otherwise empty PSBT with exactly
    one output.
    */
    bytes psbt = 3;
}

message BatchOpenChannelRequest {
    // The list of channels to open.
    repeated BatchOpenChannel channels = 1;

    // The target number of blocks that the funding transaction should be
    // confirmed by.
    int32 target_conf = 2;

    // A manual fee rate set in sat/vByte that should be used when crafting the
    // funding transaction.
    int64 sat_per_vbyte = 3;

    // The minimum number of confirmations each one of your outputs used for
    // the funding transaction must satisfy.
    int32 min_confs = 4;

    // Whether unconfirmed outputs should be used as inputs for the funding
    // transaction.
    bool spend_unconfirmed = 5;

    // An optional label for the batch transaction, limited to 500 characters.
    string label = 6;
}

message BatchOpenChannel {
    // The pubkey of the node to open a channel with. When using REST, this
    // field must be encoded as base64.
    bytes node_pubkey = 1;

    // The number of satoshis the wallet should commit to the channel.
    int64 local_funding_amount = 2;

    // The number of satoshis to push to the remote side as part of the initial
    // commitment state.
    int64 push_sat = 3;

    // Whether this channel should be private, not announced to the greater
    // network.
    bool private = 4;

    // The minimum value in millisatoshi we will require for incoming HTLCs on
    // the channel.
    int64 min_htlc_msat = 5;

    // The delay we require on the remote's commitment transaction. If this is
    // not set, it will be scaled automatically with the channel size.
    uint32 remote_csv_delay = 6;

    /*
    Close address is an optional address which specifies the address to which
    funds should be paid out to upon cooperative close. This field may only be
    set if the peer supports the option upfront feature bit (call listpeers
    to check). The remote peer will only accept cooperative closes to this
    address if it is set.

    Note: If this value is set on channel creation, you will *not* be able to
    cooperatively close out to a different address.
    */
    string close_address = 7;

    /*
    An optional, unique identifier of 32 random bytes that will be used as the
    pending channel ID to identify the channel while it is in the pre-pending
    state.
    */
    bytes pending_chan_id = 8;

    /*
    The explicit commitment type to use. Note this field will only be used if
    the remote peer supports explicit channel negotiation.
    */
    CommitmentType commitment_type = 9;
}

message BatchOpenChannelResponse {
    repeated PendingUpdate pending_channels = 1;
}

message OpenChannelRequest {
    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // funding transaction.
    uint64 sat_per_vbyte = 1;

    /*
    The pubkey of the node to open a channel with. When using REST, this field
    must be encoded as base64.
    */
    bytes node_pubkey = 2;

    /*
    The hex encoded pubkey of the node to open a channel with. Deprecated now
    that the REST gateway supports base64 encoding of bytes fields.
    */
    string node_pubkey_string = 3 [deprecated = true];

    // The number of satoshis the wallet should commit to the channel
    int64 local_funding_amount = 4;

    // The number of satoshis to push to the remote side as part of the initial
    // commitment state
    int64 push_sat = 5;

    // The target number of blocks that the funding transaction should be
    // confirmed by.
    int32 target_conf = 6;

    // Deprecated, use sat_per_vbyte.
    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // funding transaction.
    int64 sat_per_byte = 7 [deprecated = true];

    // Whether this channel should be private, not announced to the greater
    // network.
    bool private = 8;

    // The minimum value in millisatoshi we will require for incoming HTLCs on
    // the channel.
    int64 min_htlc_msat = 9;

    // The delay we require on the remote's commitment transaction. If this is
    // not set, it will be scaled automatically with the channel size.
    uint32 remote_csv_delay = 10;

    // The minimum number of confirmations each one of your outputs used for
    // the funding transaction must satisfy.
    int32 min_confs = 11;

    // Whether unconfirmed outputs should be used as inputs for the funding
    // transaction.
    bool spend_unconfirmed = 12;

    /*
    Close address is an optional address which specifies the address to which
    funds should be paid out to upon cooperative close. This field may only be
    set if the peer supports the option upfront feature bit (call listpeers
    to check). The remote peer will only accept cooperative closes to this
    address if it is set.

    Note: If this value is set on channel creation, you will *not* be able to
    cooperatively close out to a different address.
    */
    string close_address = 13;

    /*
    Funding shims are an optional argument that allow the caller to intercept
    certain funding functionality. For example, a shim can be provided to use a
    particular key for the commitment key (ideally cold) rather than use one
    that is generated by the wallet as normal, or signal that signing will be
    carried out in an interactive manner (PSBT based).
    */
    FundingShim funding_shim = 14;

    /*
    The maximum amount of coins in millisatoshi that can be pending within
    the channel. It only applies to the remote party.
    */
    uint64 remote_max_value_in_flight_msat = 15;

    /*
    The maximum number of concurrent HTLCs we will allow the remote party to add
    to the commitment transaction.
    */
    uint32 remote_max_htlcs = 16;

    /*
    Max local csv is the maximum csv delay we will allow for our own commitment
    transaction.
    */
    uint32 max_local_csv = 17;

    /*
    The explicit commitment type to use. Note this field will only be used if
    the remote peer supports explicit channel negotiation.
    */
    CommitmentType commitment_type = 18;
}
message OpenStatusUpdate {
    oneof update {
        /*
        Signals that the channel is now fully negotiated and the funding
        transaction published.
        */
        PendingUpdate chan_pending = 1;

        /*
        Signals that the channel's funding transaction has now reached the
        required number of confirmations on chain and can be used.
        */
        ChannelOpenUpdate chan_open = 3;

        /*
        Signals that the funding process has been suspended and the construction
        of a PSBT that funds the channel PK script is now required.
        */
        ReadyForPsbtFunding psbt_fund = 5;
    }

    /*
    The pending channel ID of the created channel. This value may be used to
    further the funding flow manually via the FundingStateStep method.
    */
    bytes pending_chan_id = 4;
}
